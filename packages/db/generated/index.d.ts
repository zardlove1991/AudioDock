
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Track
 * 
 */
export type Track = $Result.DefaultSelection<Prisma.$TrackPayload>
/**
 * Model Album
 * 
 */
export type Album = $Result.DefaultSelection<Prisma.$AlbumPayload>
/**
 * Model Artist
 * 
 */
export type Artist = $Result.DefaultSelection<Prisma.$ArtistPayload>
/**
 * Model UserTrackLike
 * 
 */
export type UserTrackLike = $Result.DefaultSelection<Prisma.$UserTrackLikePayload>
/**
 * Model UserTrackHistory
 * 
 */
export type UserTrackHistory = $Result.DefaultSelection<Prisma.$UserTrackHistoryPayload>
/**
 * Model UserAlbumLike
 * 
 */
export type UserAlbumLike = $Result.DefaultSelection<Prisma.$UserAlbumLikePayload>
/**
 * Model UserAlbumHistory
 * 
 */
export type UserAlbumHistory = $Result.DefaultSelection<Prisma.$UserAlbumHistoryPayload>
/**
 * Model UserAudiobookLike
 * 
 */
export type UserAudiobookLike = $Result.DefaultSelection<Prisma.$UserAudiobookLikePayload>
/**
 * Model UserAudiobookHistory
 * 
 */
export type UserAudiobookHistory = $Result.DefaultSelection<Prisma.$UserAudiobookHistoryPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model SearchRecord
 * 
 */
export type SearchRecord = $Result.DefaultSelection<Prisma.$SearchRecordPayload>
/**
 * Model Device
 * 
 */
export type Device = $Result.DefaultSelection<Prisma.$DevicePayload>
/**
 * Model Playlist
 * 
 */
export type Playlist = $Result.DefaultSelection<Prisma.$PlaylistPayload>
/**
 * Model Folder
 * 
 */
export type Folder = $Result.DefaultSelection<Prisma.$FolderPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TrackType: {
  MUSIC: 'MUSIC',
  AUDIOBOOK: 'AUDIOBOOK'
};

export type TrackType = (typeof TrackType)[keyof typeof TrackType]

}

export type TrackType = $Enums.TrackType

export const TrackType: typeof $Enums.TrackType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tracks
 * const tracks = await prisma.track.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tracks
   * const tracks = await prisma.track.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.track`: Exposes CRUD operations for the **Track** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tracks
    * const tracks = await prisma.track.findMany()
    * ```
    */
  get track(): Prisma.TrackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.album`: Exposes CRUD operations for the **Album** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Albums
    * const albums = await prisma.album.findMany()
    * ```
    */
  get album(): Prisma.AlbumDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artist`: Exposes CRUD operations for the **Artist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Artists
    * const artists = await prisma.artist.findMany()
    * ```
    */
  get artist(): Prisma.ArtistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userTrackLike`: Exposes CRUD operations for the **UserTrackLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTrackLikes
    * const userTrackLikes = await prisma.userTrackLike.findMany()
    * ```
    */
  get userTrackLike(): Prisma.UserTrackLikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userTrackHistory`: Exposes CRUD operations for the **UserTrackHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTrackHistories
    * const userTrackHistories = await prisma.userTrackHistory.findMany()
    * ```
    */
  get userTrackHistory(): Prisma.UserTrackHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAlbumLike`: Exposes CRUD operations for the **UserAlbumLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAlbumLikes
    * const userAlbumLikes = await prisma.userAlbumLike.findMany()
    * ```
    */
  get userAlbumLike(): Prisma.UserAlbumLikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAlbumHistory`: Exposes CRUD operations for the **UserAlbumHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAlbumHistories
    * const userAlbumHistories = await prisma.userAlbumHistory.findMany()
    * ```
    */
  get userAlbumHistory(): Prisma.UserAlbumHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAudiobookLike`: Exposes CRUD operations for the **UserAudiobookLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAudiobookLikes
    * const userAudiobookLikes = await prisma.userAudiobookLike.findMany()
    * ```
    */
  get userAudiobookLike(): Prisma.UserAudiobookLikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAudiobookHistory`: Exposes CRUD operations for the **UserAudiobookHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAudiobookHistories
    * const userAudiobookHistories = await prisma.userAudiobookHistory.findMany()
    * ```
    */
  get userAudiobookHistory(): Prisma.UserAudiobookHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.searchRecord`: Exposes CRUD operations for the **SearchRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchRecords
    * const searchRecords = await prisma.searchRecord.findMany()
    * ```
    */
  get searchRecord(): Prisma.SearchRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **Device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.DeviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playlist`: Exposes CRUD operations for the **Playlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Playlists
    * const playlists = await prisma.playlist.findMany()
    * ```
    */
  get playlist(): Prisma.PlaylistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.folder`: Exposes CRUD operations for the **Folder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Folders
    * const folders = await prisma.folder.findMany()
    * ```
    */
  get folder(): Prisma.FolderDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Track: 'Track',
    Album: 'Album',
    Artist: 'Artist',
    UserTrackLike: 'UserTrackLike',
    UserTrackHistory: 'UserTrackHistory',
    UserAlbumLike: 'UserAlbumLike',
    UserAlbumHistory: 'UserAlbumHistory',
    UserAudiobookLike: 'UserAudiobookLike',
    UserAudiobookHistory: 'UserAudiobookHistory',
    User: 'User',
    SearchRecord: 'SearchRecord',
    Device: 'Device',
    Playlist: 'Playlist',
    Folder: 'Folder'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "track" | "album" | "artist" | "userTrackLike" | "userTrackHistory" | "userAlbumLike" | "userAlbumHistory" | "userAudiobookLike" | "userAudiobookHistory" | "user" | "searchRecord" | "device" | "playlist" | "folder"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Track: {
        payload: Prisma.$TrackPayload<ExtArgs>
        fields: Prisma.TrackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackPayload>
          }
          findFirst: {
            args: Prisma.TrackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackPayload>
          }
          findMany: {
            args: Prisma.TrackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackPayload>[]
          }
          create: {
            args: Prisma.TrackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackPayload>
          }
          createMany: {
            args: Prisma.TrackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackPayload>[]
          }
          delete: {
            args: Prisma.TrackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackPayload>
          }
          update: {
            args: Prisma.TrackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackPayload>
          }
          deleteMany: {
            args: Prisma.TrackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackPayload>[]
          }
          upsert: {
            args: Prisma.TrackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackPayload>
          }
          aggregate: {
            args: Prisma.TrackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrack>
          }
          groupBy: {
            args: Prisma.TrackGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrackGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrackCountArgs<ExtArgs>
            result: $Utils.Optional<TrackCountAggregateOutputType> | number
          }
        }
      }
      Album: {
        payload: Prisma.$AlbumPayload<ExtArgs>
        fields: Prisma.AlbumFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlbumFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlbumFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          findFirst: {
            args: Prisma.AlbumFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlbumFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          findMany: {
            args: Prisma.AlbumFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>[]
          }
          create: {
            args: Prisma.AlbumCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          createMany: {
            args: Prisma.AlbumCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlbumCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>[]
          }
          delete: {
            args: Prisma.AlbumDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          update: {
            args: Prisma.AlbumUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          deleteMany: {
            args: Prisma.AlbumDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlbumUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlbumUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>[]
          }
          upsert: {
            args: Prisma.AlbumUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          aggregate: {
            args: Prisma.AlbumAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlbum>
          }
          groupBy: {
            args: Prisma.AlbumGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlbumGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlbumCountArgs<ExtArgs>
            result: $Utils.Optional<AlbumCountAggregateOutputType> | number
          }
        }
      }
      Artist: {
        payload: Prisma.$ArtistPayload<ExtArgs>
        fields: Prisma.ArtistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArtistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArtistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>
          }
          findFirst: {
            args: Prisma.ArtistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArtistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>
          }
          findMany: {
            args: Prisma.ArtistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>[]
          }
          create: {
            args: Prisma.ArtistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>
          }
          createMany: {
            args: Prisma.ArtistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArtistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>[]
          }
          delete: {
            args: Prisma.ArtistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>
          }
          update: {
            args: Prisma.ArtistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>
          }
          deleteMany: {
            args: Prisma.ArtistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArtistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArtistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>[]
          }
          upsert: {
            args: Prisma.ArtistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>
          }
          aggregate: {
            args: Prisma.ArtistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtist>
          }
          groupBy: {
            args: Prisma.ArtistGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtistGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArtistCountArgs<ExtArgs>
            result: $Utils.Optional<ArtistCountAggregateOutputType> | number
          }
        }
      }
      UserTrackLike: {
        payload: Prisma.$UserTrackLikePayload<ExtArgs>
        fields: Prisma.UserTrackLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTrackLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTrackLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackLikePayload>
          }
          findFirst: {
            args: Prisma.UserTrackLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTrackLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackLikePayload>
          }
          findMany: {
            args: Prisma.UserTrackLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackLikePayload>[]
          }
          create: {
            args: Prisma.UserTrackLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackLikePayload>
          }
          createMany: {
            args: Prisma.UserTrackLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTrackLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackLikePayload>[]
          }
          delete: {
            args: Prisma.UserTrackLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackLikePayload>
          }
          update: {
            args: Prisma.UserTrackLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackLikePayload>
          }
          deleteMany: {
            args: Prisma.UserTrackLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTrackLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserTrackLikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackLikePayload>[]
          }
          upsert: {
            args: Prisma.UserTrackLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackLikePayload>
          }
          aggregate: {
            args: Prisma.UserTrackLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTrackLike>
          }
          groupBy: {
            args: Prisma.UserTrackLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTrackLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTrackLikeCountArgs<ExtArgs>
            result: $Utils.Optional<UserTrackLikeCountAggregateOutputType> | number
          }
        }
      }
      UserTrackHistory: {
        payload: Prisma.$UserTrackHistoryPayload<ExtArgs>
        fields: Prisma.UserTrackHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTrackHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTrackHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackHistoryPayload>
          }
          findFirst: {
            args: Prisma.UserTrackHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTrackHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackHistoryPayload>
          }
          findMany: {
            args: Prisma.UserTrackHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackHistoryPayload>[]
          }
          create: {
            args: Prisma.UserTrackHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackHistoryPayload>
          }
          createMany: {
            args: Prisma.UserTrackHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTrackHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackHistoryPayload>[]
          }
          delete: {
            args: Prisma.UserTrackHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackHistoryPayload>
          }
          update: {
            args: Prisma.UserTrackHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackHistoryPayload>
          }
          deleteMany: {
            args: Prisma.UserTrackHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTrackHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserTrackHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackHistoryPayload>[]
          }
          upsert: {
            args: Prisma.UserTrackHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrackHistoryPayload>
          }
          aggregate: {
            args: Prisma.UserTrackHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTrackHistory>
          }
          groupBy: {
            args: Prisma.UserTrackHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTrackHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTrackHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<UserTrackHistoryCountAggregateOutputType> | number
          }
        }
      }
      UserAlbumLike: {
        payload: Prisma.$UserAlbumLikePayload<ExtArgs>
        fields: Prisma.UserAlbumLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAlbumLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAlbumLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumLikePayload>
          }
          findFirst: {
            args: Prisma.UserAlbumLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAlbumLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumLikePayload>
          }
          findMany: {
            args: Prisma.UserAlbumLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumLikePayload>[]
          }
          create: {
            args: Prisma.UserAlbumLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumLikePayload>
          }
          createMany: {
            args: Prisma.UserAlbumLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAlbumLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumLikePayload>[]
          }
          delete: {
            args: Prisma.UserAlbumLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumLikePayload>
          }
          update: {
            args: Prisma.UserAlbumLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumLikePayload>
          }
          deleteMany: {
            args: Prisma.UserAlbumLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAlbumLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAlbumLikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumLikePayload>[]
          }
          upsert: {
            args: Prisma.UserAlbumLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumLikePayload>
          }
          aggregate: {
            args: Prisma.UserAlbumLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAlbumLike>
          }
          groupBy: {
            args: Prisma.UserAlbumLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAlbumLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAlbumLikeCountArgs<ExtArgs>
            result: $Utils.Optional<UserAlbumLikeCountAggregateOutputType> | number
          }
        }
      }
      UserAlbumHistory: {
        payload: Prisma.$UserAlbumHistoryPayload<ExtArgs>
        fields: Prisma.UserAlbumHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAlbumHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAlbumHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumHistoryPayload>
          }
          findFirst: {
            args: Prisma.UserAlbumHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAlbumHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumHistoryPayload>
          }
          findMany: {
            args: Prisma.UserAlbumHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumHistoryPayload>[]
          }
          create: {
            args: Prisma.UserAlbumHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumHistoryPayload>
          }
          createMany: {
            args: Prisma.UserAlbumHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAlbumHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumHistoryPayload>[]
          }
          delete: {
            args: Prisma.UserAlbumHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumHistoryPayload>
          }
          update: {
            args: Prisma.UserAlbumHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumHistoryPayload>
          }
          deleteMany: {
            args: Prisma.UserAlbumHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAlbumHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAlbumHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumHistoryPayload>[]
          }
          upsert: {
            args: Prisma.UserAlbumHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlbumHistoryPayload>
          }
          aggregate: {
            args: Prisma.UserAlbumHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAlbumHistory>
          }
          groupBy: {
            args: Prisma.UserAlbumHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAlbumHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAlbumHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<UserAlbumHistoryCountAggregateOutputType> | number
          }
        }
      }
      UserAudiobookLike: {
        payload: Prisma.$UserAudiobookLikePayload<ExtArgs>
        fields: Prisma.UserAudiobookLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAudiobookLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAudiobookLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookLikePayload>
          }
          findFirst: {
            args: Prisma.UserAudiobookLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAudiobookLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookLikePayload>
          }
          findMany: {
            args: Prisma.UserAudiobookLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookLikePayload>[]
          }
          create: {
            args: Prisma.UserAudiobookLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookLikePayload>
          }
          createMany: {
            args: Prisma.UserAudiobookLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAudiobookLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookLikePayload>[]
          }
          delete: {
            args: Prisma.UserAudiobookLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookLikePayload>
          }
          update: {
            args: Prisma.UserAudiobookLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookLikePayload>
          }
          deleteMany: {
            args: Prisma.UserAudiobookLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAudiobookLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAudiobookLikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookLikePayload>[]
          }
          upsert: {
            args: Prisma.UserAudiobookLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookLikePayload>
          }
          aggregate: {
            args: Prisma.UserAudiobookLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAudiobookLike>
          }
          groupBy: {
            args: Prisma.UserAudiobookLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAudiobookLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAudiobookLikeCountArgs<ExtArgs>
            result: $Utils.Optional<UserAudiobookLikeCountAggregateOutputType> | number
          }
        }
      }
      UserAudiobookHistory: {
        payload: Prisma.$UserAudiobookHistoryPayload<ExtArgs>
        fields: Prisma.UserAudiobookHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAudiobookHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAudiobookHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookHistoryPayload>
          }
          findFirst: {
            args: Prisma.UserAudiobookHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAudiobookHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookHistoryPayload>
          }
          findMany: {
            args: Prisma.UserAudiobookHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookHistoryPayload>[]
          }
          create: {
            args: Prisma.UserAudiobookHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookHistoryPayload>
          }
          createMany: {
            args: Prisma.UserAudiobookHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAudiobookHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookHistoryPayload>[]
          }
          delete: {
            args: Prisma.UserAudiobookHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookHistoryPayload>
          }
          update: {
            args: Prisma.UserAudiobookHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookHistoryPayload>
          }
          deleteMany: {
            args: Prisma.UserAudiobookHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAudiobookHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAudiobookHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookHistoryPayload>[]
          }
          upsert: {
            args: Prisma.UserAudiobookHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAudiobookHistoryPayload>
          }
          aggregate: {
            args: Prisma.UserAudiobookHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAudiobookHistory>
          }
          groupBy: {
            args: Prisma.UserAudiobookHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAudiobookHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAudiobookHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<UserAudiobookHistoryCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      SearchRecord: {
        payload: Prisma.$SearchRecordPayload<ExtArgs>
        fields: Prisma.SearchRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchRecordPayload>
          }
          findFirst: {
            args: Prisma.SearchRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchRecordPayload>
          }
          findMany: {
            args: Prisma.SearchRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchRecordPayload>[]
          }
          create: {
            args: Prisma.SearchRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchRecordPayload>
          }
          createMany: {
            args: Prisma.SearchRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SearchRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchRecordPayload>[]
          }
          delete: {
            args: Prisma.SearchRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchRecordPayload>
          }
          update: {
            args: Prisma.SearchRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchRecordPayload>
          }
          deleteMany: {
            args: Prisma.SearchRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SearchRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchRecordPayload>[]
          }
          upsert: {
            args: Prisma.SearchRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchRecordPayload>
          }
          aggregate: {
            args: Prisma.SearchRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchRecord>
          }
          groupBy: {
            args: Prisma.SearchRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchRecordCountArgs<ExtArgs>
            result: $Utils.Optional<SearchRecordCountAggregateOutputType> | number
          }
        }
      }
      Device: {
        payload: Prisma.$DevicePayload<ExtArgs>
        fields: Prisma.DeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findFirst: {
            args: Prisma.DeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findMany: {
            args: Prisma.DeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          create: {
            args: Prisma.DeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          createMany: {
            args: Prisma.DeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          delete: {
            args: Prisma.DeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          update: {
            args: Prisma.DeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          deleteMany: {
            args: Prisma.DeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          upsert: {
            args: Prisma.DeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          aggregate: {
            args: Prisma.DeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice>
          }
          groupBy: {
            args: Prisma.DeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceCountAggregateOutputType> | number
          }
        }
      }
      Playlist: {
        payload: Prisma.$PlaylistPayload<ExtArgs>
        fields: Prisma.PlaylistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaylistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaylistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          findFirst: {
            args: Prisma.PlaylistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaylistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          findMany: {
            args: Prisma.PlaylistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>[]
          }
          create: {
            args: Prisma.PlaylistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          createMany: {
            args: Prisma.PlaylistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaylistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>[]
          }
          delete: {
            args: Prisma.PlaylistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          update: {
            args: Prisma.PlaylistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          deleteMany: {
            args: Prisma.PlaylistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaylistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaylistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>[]
          }
          upsert: {
            args: Prisma.PlaylistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          aggregate: {
            args: Prisma.PlaylistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaylist>
          }
          groupBy: {
            args: Prisma.PlaylistGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaylistGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaylistCountArgs<ExtArgs>
            result: $Utils.Optional<PlaylistCountAggregateOutputType> | number
          }
        }
      }
      Folder: {
        payload: Prisma.$FolderPayload<ExtArgs>
        fields: Prisma.FolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findFirst: {
            args: Prisma.FolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findMany: {
            args: Prisma.FolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          create: {
            args: Prisma.FolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          createMany: {
            args: Prisma.FolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FolderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          delete: {
            args: Prisma.FolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          update: {
            args: Prisma.FolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          deleteMany: {
            args: Prisma.FolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FolderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          upsert: {
            args: Prisma.FolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          aggregate: {
            args: Prisma.FolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFolder>
          }
          groupBy: {
            args: Prisma.FolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<FolderGroupByOutputType>[]
          }
          count: {
            args: Prisma.FolderCountArgs<ExtArgs>
            result: $Utils.Optional<FolderCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    track?: TrackOmit
    album?: AlbumOmit
    artist?: ArtistOmit
    userTrackLike?: UserTrackLikeOmit
    userTrackHistory?: UserTrackHistoryOmit
    userAlbumLike?: UserAlbumLikeOmit
    userAlbumHistory?: UserAlbumHistoryOmit
    userAudiobookLike?: UserAudiobookLikeOmit
    userAudiobookHistory?: UserAudiobookHistoryOmit
    user?: UserOmit
    searchRecord?: SearchRecordOmit
    device?: DeviceOmit
    playlist?: PlaylistOmit
    folder?: FolderOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TrackCountOutputType
   */

  export type TrackCountOutputType = {
    likedByUsers: number
    listenedByUsers: number
    likedAsAudiobookByUsers: number
    listenedAsAudiobookByUsers: number
    playlists: number
  }

  export type TrackCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    likedByUsers?: boolean | TrackCountOutputTypeCountLikedByUsersArgs
    listenedByUsers?: boolean | TrackCountOutputTypeCountListenedByUsersArgs
    likedAsAudiobookByUsers?: boolean | TrackCountOutputTypeCountLikedAsAudiobookByUsersArgs
    listenedAsAudiobookByUsers?: boolean | TrackCountOutputTypeCountListenedAsAudiobookByUsersArgs
    playlists?: boolean | TrackCountOutputTypeCountPlaylistsArgs
  }

  // Custom InputTypes
  /**
   * TrackCountOutputType without action
   */
  export type TrackCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackCountOutputType
     */
    select?: TrackCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrackCountOutputType without action
   */
  export type TrackCountOutputTypeCountLikedByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTrackLikeWhereInput
  }

  /**
   * TrackCountOutputType without action
   */
  export type TrackCountOutputTypeCountListenedByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTrackHistoryWhereInput
  }

  /**
   * TrackCountOutputType without action
   */
  export type TrackCountOutputTypeCountLikedAsAudiobookByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAudiobookLikeWhereInput
  }

  /**
   * TrackCountOutputType without action
   */
  export type TrackCountOutputTypeCountListenedAsAudiobookByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAudiobookHistoryWhereInput
  }

  /**
   * TrackCountOutputType without action
   */
  export type TrackCountOutputTypeCountPlaylistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistWhereInput
  }


  /**
   * Count Type AlbumCountOutputType
   */

  export type AlbumCountOutputType = {
    tracks: number
    likedByUsers: number
    listenedByUsers: number
  }

  export type AlbumCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tracks?: boolean | AlbumCountOutputTypeCountTracksArgs
    likedByUsers?: boolean | AlbumCountOutputTypeCountLikedByUsersArgs
    listenedByUsers?: boolean | AlbumCountOutputTypeCountListenedByUsersArgs
  }

  // Custom InputTypes
  /**
   * AlbumCountOutputType without action
   */
  export type AlbumCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumCountOutputType
     */
    select?: AlbumCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlbumCountOutputType without action
   */
  export type AlbumCountOutputTypeCountTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrackWhereInput
  }

  /**
   * AlbumCountOutputType without action
   */
  export type AlbumCountOutputTypeCountLikedByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAlbumLikeWhereInput
  }

  /**
   * AlbumCountOutputType without action
   */
  export type AlbumCountOutputTypeCountListenedByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAlbumHistoryWhereInput
  }


  /**
   * Count Type ArtistCountOutputType
   */

  export type ArtistCountOutputType = {
    tracks: number
  }

  export type ArtistCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tracks?: boolean | ArtistCountOutputTypeCountTracksArgs
  }

  // Custom InputTypes
  /**
   * ArtistCountOutputType without action
   */
  export type ArtistCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistCountOutputType
     */
    select?: ArtistCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArtistCountOutputType without action
   */
  export type ArtistCountOutputTypeCountTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrackWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    likedTracks: number
    listenedTracks: number
    likedAlbums: number
    listenedAlbums: number
    likedAudiobooks: number
    listenedAudiobooks: number
    playlists: number
    devices: number
    searchRecords: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    likedTracks?: boolean | UserCountOutputTypeCountLikedTracksArgs
    listenedTracks?: boolean | UserCountOutputTypeCountListenedTracksArgs
    likedAlbums?: boolean | UserCountOutputTypeCountLikedAlbumsArgs
    listenedAlbums?: boolean | UserCountOutputTypeCountListenedAlbumsArgs
    likedAudiobooks?: boolean | UserCountOutputTypeCountLikedAudiobooksArgs
    listenedAudiobooks?: boolean | UserCountOutputTypeCountListenedAudiobooksArgs
    playlists?: boolean | UserCountOutputTypeCountPlaylistsArgs
    devices?: boolean | UserCountOutputTypeCountDevicesArgs
    searchRecords?: boolean | UserCountOutputTypeCountSearchRecordsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikedTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTrackLikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountListenedTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTrackHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikedAlbumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAlbumLikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountListenedAlbumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAlbumHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikedAudiobooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAudiobookLikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountListenedAudiobooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAudiobookHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlaylistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSearchRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchRecordWhereInput
  }


  /**
   * Count Type DeviceCountOutputType
   */

  export type DeviceCountOutputType = {
    histories: number
  }

  export type DeviceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    histories?: boolean | DeviceCountOutputTypeCountHistoriesArgs
  }

  // Custom InputTypes
  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCountOutputType
     */
    select?: DeviceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTrackHistoryWhereInput
  }


  /**
   * Count Type PlaylistCountOutputType
   */

  export type PlaylistCountOutputType = {
    tracks: number
  }

  export type PlaylistCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tracks?: boolean | PlaylistCountOutputTypeCountTracksArgs
  }

  // Custom InputTypes
  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistCountOutputType
     */
    select?: PlaylistCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeCountTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrackWhereInput
  }


  /**
   * Count Type FolderCountOutputType
   */

  export type FolderCountOutputType = {
    children: number
    tracks: number
  }

  export type FolderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | FolderCountOutputTypeCountChildrenArgs
    tracks?: boolean | FolderCountOutputTypeCountTracksArgs
  }

  // Custom InputTypes
  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderCountOutputType
     */
    select?: FolderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrackWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Track
   */

  export type AggregateTrack = {
    _count: TrackCountAggregateOutputType | null
    _avg: TrackAvgAggregateOutputType | null
    _sum: TrackSumAggregateOutputType | null
    _min: TrackMinAggregateOutputType | null
    _max: TrackMaxAggregateOutputType | null
  }

  export type TrackAvgAggregateOutputType = {
    id: number | null
    duration: number | null
    index: number | null
    episodeNumber: number | null
    artistId: number | null
    albumId: number | null
    folderId: number | null
  }

  export type TrackSumAggregateOutputType = {
    id: number | null
    duration: number | null
    index: number | null
    episodeNumber: number | null
    artistId: number | null
    albumId: number | null
    folderId: number | null
  }

  export type TrackMinAggregateOutputType = {
    id: number | null
    name: string | null
    path: string | null
    artist: string | null
    album: string | null
    cover: string | null
    duration: number | null
    lyrics: string | null
    index: number | null
    type: $Enums.TrackType | null
    createdAt: Date | null
    fileModifiedAt: Date | null
    episodeNumber: number | null
    artistId: number | null
    albumId: number | null
    folderId: number | null
  }

  export type TrackMaxAggregateOutputType = {
    id: number | null
    name: string | null
    path: string | null
    artist: string | null
    album: string | null
    cover: string | null
    duration: number | null
    lyrics: string | null
    index: number | null
    type: $Enums.TrackType | null
    createdAt: Date | null
    fileModifiedAt: Date | null
    episodeNumber: number | null
    artistId: number | null
    albumId: number | null
    folderId: number | null
  }

  export type TrackCountAggregateOutputType = {
    id: number
    name: number
    path: number
    artist: number
    album: number
    cover: number
    duration: number
    lyrics: number
    index: number
    type: number
    createdAt: number
    fileModifiedAt: number
    episodeNumber: number
    artistId: number
    albumId: number
    folderId: number
    _all: number
  }


  export type TrackAvgAggregateInputType = {
    id?: true
    duration?: true
    index?: true
    episodeNumber?: true
    artistId?: true
    albumId?: true
    folderId?: true
  }

  export type TrackSumAggregateInputType = {
    id?: true
    duration?: true
    index?: true
    episodeNumber?: true
    artistId?: true
    albumId?: true
    folderId?: true
  }

  export type TrackMinAggregateInputType = {
    id?: true
    name?: true
    path?: true
    artist?: true
    album?: true
    cover?: true
    duration?: true
    lyrics?: true
    index?: true
    type?: true
    createdAt?: true
    fileModifiedAt?: true
    episodeNumber?: true
    artistId?: true
    albumId?: true
    folderId?: true
  }

  export type TrackMaxAggregateInputType = {
    id?: true
    name?: true
    path?: true
    artist?: true
    album?: true
    cover?: true
    duration?: true
    lyrics?: true
    index?: true
    type?: true
    createdAt?: true
    fileModifiedAt?: true
    episodeNumber?: true
    artistId?: true
    albumId?: true
    folderId?: true
  }

  export type TrackCountAggregateInputType = {
    id?: true
    name?: true
    path?: true
    artist?: true
    album?: true
    cover?: true
    duration?: true
    lyrics?: true
    index?: true
    type?: true
    createdAt?: true
    fileModifiedAt?: true
    episodeNumber?: true
    artistId?: true
    albumId?: true
    folderId?: true
    _all?: true
  }

  export type TrackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Track to aggregate.
     */
    where?: TrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tracks to fetch.
     */
    orderBy?: TrackOrderByWithRelationInput | TrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tracks
    **/
    _count?: true | TrackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrackMaxAggregateInputType
  }

  export type GetTrackAggregateType<T extends TrackAggregateArgs> = {
        [P in keyof T & keyof AggregateTrack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrack[P]>
      : GetScalarType<T[P], AggregateTrack[P]>
  }




  export type TrackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrackWhereInput
    orderBy?: TrackOrderByWithAggregationInput | TrackOrderByWithAggregationInput[]
    by: TrackScalarFieldEnum[] | TrackScalarFieldEnum
    having?: TrackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrackCountAggregateInputType | true
    _avg?: TrackAvgAggregateInputType
    _sum?: TrackSumAggregateInputType
    _min?: TrackMinAggregateInputType
    _max?: TrackMaxAggregateInputType
  }

  export type TrackGroupByOutputType = {
    id: number
    name: string
    path: string
    artist: string
    album: string
    cover: string | null
    duration: number | null
    lyrics: string | null
    index: number | null
    type: $Enums.TrackType
    createdAt: Date
    fileModifiedAt: Date | null
    episodeNumber: number | null
    artistId: number | null
    albumId: number | null
    folderId: number | null
    _count: TrackCountAggregateOutputType | null
    _avg: TrackAvgAggregateOutputType | null
    _sum: TrackSumAggregateOutputType | null
    _min: TrackMinAggregateOutputType | null
    _max: TrackMaxAggregateOutputType | null
  }

  type GetTrackGroupByPayload<T extends TrackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrackGroupByOutputType[P]>
            : GetScalarType<T[P], TrackGroupByOutputType[P]>
        }
      >
    >


  export type TrackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    path?: boolean
    artist?: boolean
    album?: boolean
    cover?: boolean
    duration?: boolean
    lyrics?: boolean
    index?: boolean
    type?: boolean
    createdAt?: boolean
    fileModifiedAt?: boolean
    episodeNumber?: boolean
    artistId?: boolean
    albumId?: boolean
    folderId?: boolean
    artistEntity?: boolean | Track$artistEntityArgs<ExtArgs>
    albumEntity?: boolean | Track$albumEntityArgs<ExtArgs>
    likedByUsers?: boolean | Track$likedByUsersArgs<ExtArgs>
    listenedByUsers?: boolean | Track$listenedByUsersArgs<ExtArgs>
    likedAsAudiobookByUsers?: boolean | Track$likedAsAudiobookByUsersArgs<ExtArgs>
    listenedAsAudiobookByUsers?: boolean | Track$listenedAsAudiobookByUsersArgs<ExtArgs>
    playlists?: boolean | Track$playlistsArgs<ExtArgs>
    folder?: boolean | Track$folderArgs<ExtArgs>
    _count?: boolean | TrackCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["track"]>

  export type TrackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    path?: boolean
    artist?: boolean
    album?: boolean
    cover?: boolean
    duration?: boolean
    lyrics?: boolean
    index?: boolean
    type?: boolean
    createdAt?: boolean
    fileModifiedAt?: boolean
    episodeNumber?: boolean
    artistId?: boolean
    albumId?: boolean
    folderId?: boolean
    artistEntity?: boolean | Track$artistEntityArgs<ExtArgs>
    albumEntity?: boolean | Track$albumEntityArgs<ExtArgs>
    folder?: boolean | Track$folderArgs<ExtArgs>
  }, ExtArgs["result"]["track"]>

  export type TrackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    path?: boolean
    artist?: boolean
    album?: boolean
    cover?: boolean
    duration?: boolean
    lyrics?: boolean
    index?: boolean
    type?: boolean
    createdAt?: boolean
    fileModifiedAt?: boolean
    episodeNumber?: boolean
    artistId?: boolean
    albumId?: boolean
    folderId?: boolean
    artistEntity?: boolean | Track$artistEntityArgs<ExtArgs>
    albumEntity?: boolean | Track$albumEntityArgs<ExtArgs>
    folder?: boolean | Track$folderArgs<ExtArgs>
  }, ExtArgs["result"]["track"]>

  export type TrackSelectScalar = {
    id?: boolean
    name?: boolean
    path?: boolean
    artist?: boolean
    album?: boolean
    cover?: boolean
    duration?: boolean
    lyrics?: boolean
    index?: boolean
    type?: boolean
    createdAt?: boolean
    fileModifiedAt?: boolean
    episodeNumber?: boolean
    artistId?: boolean
    albumId?: boolean
    folderId?: boolean
  }

  export type TrackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "path" | "artist" | "album" | "cover" | "duration" | "lyrics" | "index" | "type" | "createdAt" | "fileModifiedAt" | "episodeNumber" | "artistId" | "albumId" | "folderId", ExtArgs["result"]["track"]>
  export type TrackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artistEntity?: boolean | Track$artistEntityArgs<ExtArgs>
    albumEntity?: boolean | Track$albumEntityArgs<ExtArgs>
    likedByUsers?: boolean | Track$likedByUsersArgs<ExtArgs>
    listenedByUsers?: boolean | Track$listenedByUsersArgs<ExtArgs>
    likedAsAudiobookByUsers?: boolean | Track$likedAsAudiobookByUsersArgs<ExtArgs>
    listenedAsAudiobookByUsers?: boolean | Track$listenedAsAudiobookByUsersArgs<ExtArgs>
    playlists?: boolean | Track$playlistsArgs<ExtArgs>
    folder?: boolean | Track$folderArgs<ExtArgs>
    _count?: boolean | TrackCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artistEntity?: boolean | Track$artistEntityArgs<ExtArgs>
    albumEntity?: boolean | Track$albumEntityArgs<ExtArgs>
    folder?: boolean | Track$folderArgs<ExtArgs>
  }
  export type TrackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artistEntity?: boolean | Track$artistEntityArgs<ExtArgs>
    albumEntity?: boolean | Track$albumEntityArgs<ExtArgs>
    folder?: boolean | Track$folderArgs<ExtArgs>
  }

  export type $TrackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Track"
    objects: {
      artistEntity: Prisma.$ArtistPayload<ExtArgs> | null
      albumEntity: Prisma.$AlbumPayload<ExtArgs> | null
      /**
       * 🔁 反向关系
       */
      likedByUsers: Prisma.$UserTrackLikePayload<ExtArgs>[]
      listenedByUsers: Prisma.$UserTrackHistoryPayload<ExtArgs>[]
      likedAsAudiobookByUsers: Prisma.$UserAudiobookLikePayload<ExtArgs>[]
      listenedAsAudiobookByUsers: Prisma.$UserAudiobookHistoryPayload<ExtArgs>[]
      playlists: Prisma.$PlaylistPayload<ExtArgs>[]
      folder: Prisma.$FolderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      path: string
      artist: string
      album: string
      cover: string | null
      duration: number | null
      lyrics: string | null
      index: number | null
      type: $Enums.TrackType
      createdAt: Date
      fileModifiedAt: Date | null
      episodeNumber: number | null
      artistId: number | null
      albumId: number | null
      folderId: number | null
    }, ExtArgs["result"]["track"]>
    composites: {}
  }

  type TrackGetPayload<S extends boolean | null | undefined | TrackDefaultArgs> = $Result.GetResult<Prisma.$TrackPayload, S>

  type TrackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrackCountAggregateInputType | true
    }

  export interface TrackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Track'], meta: { name: 'Track' } }
    /**
     * Find zero or one Track that matches the filter.
     * @param {TrackFindUniqueArgs} args - Arguments to find a Track
     * @example
     * // Get one Track
     * const track = await prisma.track.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrackFindUniqueArgs>(args: SelectSubset<T, TrackFindUniqueArgs<ExtArgs>>): Prisma__TrackClient<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Track that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrackFindUniqueOrThrowArgs} args - Arguments to find a Track
     * @example
     * // Get one Track
     * const track = await prisma.track.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrackFindUniqueOrThrowArgs>(args: SelectSubset<T, TrackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrackClient<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Track that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackFindFirstArgs} args - Arguments to find a Track
     * @example
     * // Get one Track
     * const track = await prisma.track.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrackFindFirstArgs>(args?: SelectSubset<T, TrackFindFirstArgs<ExtArgs>>): Prisma__TrackClient<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Track that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackFindFirstOrThrowArgs} args - Arguments to find a Track
     * @example
     * // Get one Track
     * const track = await prisma.track.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrackFindFirstOrThrowArgs>(args?: SelectSubset<T, TrackFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrackClient<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tracks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tracks
     * const tracks = await prisma.track.findMany()
     * 
     * // Get first 10 Tracks
     * const tracks = await prisma.track.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trackWithIdOnly = await prisma.track.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrackFindManyArgs>(args?: SelectSubset<T, TrackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Track.
     * @param {TrackCreateArgs} args - Arguments to create a Track.
     * @example
     * // Create one Track
     * const Track = await prisma.track.create({
     *   data: {
     *     // ... data to create a Track
     *   }
     * })
     * 
     */
    create<T extends TrackCreateArgs>(args: SelectSubset<T, TrackCreateArgs<ExtArgs>>): Prisma__TrackClient<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tracks.
     * @param {TrackCreateManyArgs} args - Arguments to create many Tracks.
     * @example
     * // Create many Tracks
     * const track = await prisma.track.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrackCreateManyArgs>(args?: SelectSubset<T, TrackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tracks and returns the data saved in the database.
     * @param {TrackCreateManyAndReturnArgs} args - Arguments to create many Tracks.
     * @example
     * // Create many Tracks
     * const track = await prisma.track.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tracks and only return the `id`
     * const trackWithIdOnly = await prisma.track.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrackCreateManyAndReturnArgs>(args?: SelectSubset<T, TrackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Track.
     * @param {TrackDeleteArgs} args - Arguments to delete one Track.
     * @example
     * // Delete one Track
     * const Track = await prisma.track.delete({
     *   where: {
     *     // ... filter to delete one Track
     *   }
     * })
     * 
     */
    delete<T extends TrackDeleteArgs>(args: SelectSubset<T, TrackDeleteArgs<ExtArgs>>): Prisma__TrackClient<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Track.
     * @param {TrackUpdateArgs} args - Arguments to update one Track.
     * @example
     * // Update one Track
     * const track = await prisma.track.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrackUpdateArgs>(args: SelectSubset<T, TrackUpdateArgs<ExtArgs>>): Prisma__TrackClient<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tracks.
     * @param {TrackDeleteManyArgs} args - Arguments to filter Tracks to delete.
     * @example
     * // Delete a few Tracks
     * const { count } = await prisma.track.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrackDeleteManyArgs>(args?: SelectSubset<T, TrackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tracks
     * const track = await prisma.track.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrackUpdateManyArgs>(args: SelectSubset<T, TrackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tracks and returns the data updated in the database.
     * @param {TrackUpdateManyAndReturnArgs} args - Arguments to update many Tracks.
     * @example
     * // Update many Tracks
     * const track = await prisma.track.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tracks and only return the `id`
     * const trackWithIdOnly = await prisma.track.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrackUpdateManyAndReturnArgs>(args: SelectSubset<T, TrackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Track.
     * @param {TrackUpsertArgs} args - Arguments to update or create a Track.
     * @example
     * // Update or create a Track
     * const track = await prisma.track.upsert({
     *   create: {
     *     // ... data to create a Track
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Track we want to update
     *   }
     * })
     */
    upsert<T extends TrackUpsertArgs>(args: SelectSubset<T, TrackUpsertArgs<ExtArgs>>): Prisma__TrackClient<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackCountArgs} args - Arguments to filter Tracks to count.
     * @example
     * // Count the number of Tracks
     * const count = await prisma.track.count({
     *   where: {
     *     // ... the filter for the Tracks we want to count
     *   }
     * })
    **/
    count<T extends TrackCountArgs>(
      args?: Subset<T, TrackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Track.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrackAggregateArgs>(args: Subset<T, TrackAggregateArgs>): Prisma.PrismaPromise<GetTrackAggregateType<T>>

    /**
     * Group by Track.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrackGroupByArgs['orderBy'] }
        : { orderBy?: TrackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Track model
   */
  readonly fields: TrackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Track.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artistEntity<T extends Track$artistEntityArgs<ExtArgs> = {}>(args?: Subset<T, Track$artistEntityArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    albumEntity<T extends Track$albumEntityArgs<ExtArgs> = {}>(args?: Subset<T, Track$albumEntityArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    likedByUsers<T extends Track$likedByUsersArgs<ExtArgs> = {}>(args?: Subset<T, Track$likedByUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTrackLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    listenedByUsers<T extends Track$listenedByUsersArgs<ExtArgs> = {}>(args?: Subset<T, Track$listenedByUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTrackHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likedAsAudiobookByUsers<T extends Track$likedAsAudiobookByUsersArgs<ExtArgs> = {}>(args?: Subset<T, Track$likedAsAudiobookByUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAudiobookLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    listenedAsAudiobookByUsers<T extends Track$listenedAsAudiobookByUsersArgs<ExtArgs> = {}>(args?: Subset<T, Track$listenedAsAudiobookByUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAudiobookHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playlists<T extends Track$playlistsArgs<ExtArgs> = {}>(args?: Subset<T, Track$playlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    folder<T extends Track$folderArgs<ExtArgs> = {}>(args?: Subset<T, Track$folderArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Track model
   */
  interface TrackFieldRefs {
    readonly id: FieldRef<"Track", 'Int'>
    readonly name: FieldRef<"Track", 'String'>
    readonly path: FieldRef<"Track", 'String'>
    readonly artist: FieldRef<"Track", 'String'>
    readonly album: FieldRef<"Track", 'String'>
    readonly cover: FieldRef<"Track", 'String'>
    readonly duration: FieldRef<"Track", 'Int'>
    readonly lyrics: FieldRef<"Track", 'String'>
    readonly index: FieldRef<"Track", 'Int'>
    readonly type: FieldRef<"Track", 'TrackType'>
    readonly createdAt: FieldRef<"Track", 'DateTime'>
    readonly fileModifiedAt: FieldRef<"Track", 'DateTime'>
    readonly episodeNumber: FieldRef<"Track", 'Int'>
    readonly artistId: FieldRef<"Track", 'Int'>
    readonly albumId: FieldRef<"Track", 'Int'>
    readonly folderId: FieldRef<"Track", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Track findUnique
   */
  export type TrackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Track
     */
    omit?: TrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null
    /**
     * Filter, which Track to fetch.
     */
    where: TrackWhereUniqueInput
  }

  /**
   * Track findUniqueOrThrow
   */
  export type TrackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Track
     */
    omit?: TrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null
    /**
     * Filter, which Track to fetch.
     */
    where: TrackWhereUniqueInput
  }

  /**
   * Track findFirst
   */
  export type TrackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Track
     */
    omit?: TrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null
    /**
     * Filter, which Track to fetch.
     */
    where?: TrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tracks to fetch.
     */
    orderBy?: TrackOrderByWithRelationInput | TrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tracks.
     */
    cursor?: TrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tracks.
     */
    distinct?: TrackScalarFieldEnum | TrackScalarFieldEnum[]
  }

  /**
   * Track findFirstOrThrow
   */
  export type TrackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Track
     */
    omit?: TrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null
    /**
     * Filter, which Track to fetch.
     */
    where?: TrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tracks to fetch.
     */
    orderBy?: TrackOrderByWithRelationInput | TrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tracks.
     */
    cursor?: TrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tracks.
     */
    distinct?: TrackScalarFieldEnum | TrackScalarFieldEnum[]
  }

  /**
   * Track findMany
   */
  export type TrackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Track
     */
    omit?: TrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null
    /**
     * Filter, which Tracks to fetch.
     */
    where?: TrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tracks to fetch.
     */
    orderBy?: TrackOrderByWithRelationInput | TrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tracks.
     */
    cursor?: TrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tracks.
     */
    skip?: number
    distinct?: TrackScalarFieldEnum | TrackScalarFieldEnum[]
  }

  /**
   * Track create
   */
  export type TrackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Track
     */
    omit?: TrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null
    /**
     * The data needed to create a Track.
     */
    data: XOR<TrackCreateInput, TrackUncheckedCreateInput>
  }

  /**
   * Track createMany
   */
  export type TrackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tracks.
     */
    data: TrackCreateManyInput | TrackCreateManyInput[]
  }

  /**
   * Track createManyAndReturn
   */
  export type TrackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Track
     */
    omit?: TrackOmit<ExtArgs> | null
    /**
     * The data used to create many Tracks.
     */
    data: TrackCreateManyInput | TrackCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Track update
   */
  export type TrackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Track
     */
    omit?: TrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null
    /**
     * The data needed to update a Track.
     */
    data: XOR<TrackUpdateInput, TrackUncheckedUpdateInput>
    /**
     * Choose, which Track to update.
     */
    where: TrackWhereUniqueInput
  }

  /**
   * Track updateMany
   */
  export type TrackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tracks.
     */
    data: XOR<TrackUpdateManyMutationInput, TrackUncheckedUpdateManyInput>
    /**
     * Filter which Tracks to update
     */
    where?: TrackWhereInput
    /**
     * Limit how many Tracks to update.
     */
    limit?: number
  }

  /**
   * Track updateManyAndReturn
   */
  export type TrackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Track
     */
    omit?: TrackOmit<ExtArgs> | null
    /**
     * The data used to update Tracks.
     */
    data: XOR<TrackUpdateManyMutationInput, TrackUncheckedUpdateManyInput>
    /**
     * Filter which Tracks to update
     */
    where?: TrackWhereInput
    /**
     * Limit how many Tracks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Track upsert
   */
  export type TrackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Track
     */
    omit?: TrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null
    /**
     * The filter to search for the Track to update in case it exists.
     */
    where: TrackWhereUniqueInput
    /**
     * In case the Track found by the `where` argument doesn't exist, create a new Track with this data.
     */
    create: XOR<TrackCreateInput, TrackUncheckedCreateInput>
    /**
     * In case the Track was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrackUpdateInput, TrackUncheckedUpdateInput>
  }

  /**
   * Track delete
   */
  export type TrackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Track
     */
    omit?: TrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null
    /**
     * Filter which Track to delete.
     */
    where: TrackWhereUniqueInput
  }

  /**
   * Track deleteMany
   */
  export type TrackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tracks to delete
     */
    where?: TrackWhereInput
    /**
     * Limit how many Tracks to delete.
     */
    limit?: number
  }

  /**
   * Track.artistEntity
   */
  export type Track$artistEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    where?: ArtistWhereInput
  }

  /**
   * Track.albumEntity
   */
  export type Track$albumEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    where?: AlbumWhereInput
  }

  /**
   * Track.likedByUsers
   */
  export type Track$likedByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackLike
     */
    select?: UserTrackLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackLike
     */
    omit?: UserTrackLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackLikeInclude<ExtArgs> | null
    where?: UserTrackLikeWhereInput
    orderBy?: UserTrackLikeOrderByWithRelationInput | UserTrackLikeOrderByWithRelationInput[]
    cursor?: UserTrackLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTrackLikeScalarFieldEnum | UserTrackLikeScalarFieldEnum[]
  }

  /**
   * Track.listenedByUsers
   */
  export type Track$listenedByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackHistory
     */
    select?: UserTrackHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackHistory
     */
    omit?: UserTrackHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackHistoryInclude<ExtArgs> | null
    where?: UserTrackHistoryWhereInput
    orderBy?: UserTrackHistoryOrderByWithRelationInput | UserTrackHistoryOrderByWithRelationInput[]
    cursor?: UserTrackHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTrackHistoryScalarFieldEnum | UserTrackHistoryScalarFieldEnum[]
  }

  /**
   * Track.likedAsAudiobookByUsers
   */
  export type Track$likedAsAudiobookByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookLike
     */
    select?: UserAudiobookLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookLike
     */
    omit?: UserAudiobookLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookLikeInclude<ExtArgs> | null
    where?: UserAudiobookLikeWhereInput
    orderBy?: UserAudiobookLikeOrderByWithRelationInput | UserAudiobookLikeOrderByWithRelationInput[]
    cursor?: UserAudiobookLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAudiobookLikeScalarFieldEnum | UserAudiobookLikeScalarFieldEnum[]
  }

  /**
   * Track.listenedAsAudiobookByUsers
   */
  export type Track$listenedAsAudiobookByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookHistory
     */
    select?: UserAudiobookHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookHistory
     */
    omit?: UserAudiobookHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookHistoryInclude<ExtArgs> | null
    where?: UserAudiobookHistoryWhereInput
    orderBy?: UserAudiobookHistoryOrderByWithRelationInput | UserAudiobookHistoryOrderByWithRelationInput[]
    cursor?: UserAudiobookHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAudiobookHistoryScalarFieldEnum | UserAudiobookHistoryScalarFieldEnum[]
  }

  /**
   * Track.playlists
   */
  export type Track$playlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    where?: PlaylistWhereInput
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    cursor?: PlaylistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * Track.folder
   */
  export type Track$folderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
  }

  /**
   * Track without action
   */
  export type TrackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Track
     */
    omit?: TrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null
  }


  /**
   * Model Album
   */

  export type AggregateAlbum = {
    _count: AlbumCountAggregateOutputType | null
    _avg: AlbumAvgAggregateOutputType | null
    _sum: AlbumSumAggregateOutputType | null
    _min: AlbumMinAggregateOutputType | null
    _max: AlbumMaxAggregateOutputType | null
  }

  export type AlbumAvgAggregateOutputType = {
    id: number | null
  }

  export type AlbumSumAggregateOutputType = {
    id: number | null
  }

  export type AlbumMinAggregateOutputType = {
    id: number | null
    name: string | null
    artist: string | null
    cover: string | null
    year: string | null
    type: $Enums.TrackType | null
  }

  export type AlbumMaxAggregateOutputType = {
    id: number | null
    name: string | null
    artist: string | null
    cover: string | null
    year: string | null
    type: $Enums.TrackType | null
  }

  export type AlbumCountAggregateOutputType = {
    id: number
    name: number
    artist: number
    cover: number
    year: number
    type: number
    _all: number
  }


  export type AlbumAvgAggregateInputType = {
    id?: true
  }

  export type AlbumSumAggregateInputType = {
    id?: true
  }

  export type AlbumMinAggregateInputType = {
    id?: true
    name?: true
    artist?: true
    cover?: true
    year?: true
    type?: true
  }

  export type AlbumMaxAggregateInputType = {
    id?: true
    name?: true
    artist?: true
    cover?: true
    year?: true
    type?: true
  }

  export type AlbumCountAggregateInputType = {
    id?: true
    name?: true
    artist?: true
    cover?: true
    year?: true
    type?: true
    _all?: true
  }

  export type AlbumAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Album to aggregate.
     */
    where?: AlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Albums to fetch.
     */
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Albums
    **/
    _count?: true | AlbumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlbumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlbumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlbumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlbumMaxAggregateInputType
  }

  export type GetAlbumAggregateType<T extends AlbumAggregateArgs> = {
        [P in keyof T & keyof AggregateAlbum]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlbum[P]>
      : GetScalarType<T[P], AggregateAlbum[P]>
  }




  export type AlbumGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlbumWhereInput
    orderBy?: AlbumOrderByWithAggregationInput | AlbumOrderByWithAggregationInput[]
    by: AlbumScalarFieldEnum[] | AlbumScalarFieldEnum
    having?: AlbumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlbumCountAggregateInputType | true
    _avg?: AlbumAvgAggregateInputType
    _sum?: AlbumSumAggregateInputType
    _min?: AlbumMinAggregateInputType
    _max?: AlbumMaxAggregateInputType
  }

  export type AlbumGroupByOutputType = {
    id: number
    name: string
    artist: string
    cover: string | null
    year: string | null
    type: $Enums.TrackType
    _count: AlbumCountAggregateOutputType | null
    _avg: AlbumAvgAggregateOutputType | null
    _sum: AlbumSumAggregateOutputType | null
    _min: AlbumMinAggregateOutputType | null
    _max: AlbumMaxAggregateOutputType | null
  }

  type GetAlbumGroupByPayload<T extends AlbumGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlbumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlbumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlbumGroupByOutputType[P]>
            : GetScalarType<T[P], AlbumGroupByOutputType[P]>
        }
      >
    >


  export type AlbumSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    artist?: boolean
    cover?: boolean
    year?: boolean
    type?: boolean
    tracks?: boolean | Album$tracksArgs<ExtArgs>
    likedByUsers?: boolean | Album$likedByUsersArgs<ExtArgs>
    listenedByUsers?: boolean | Album$listenedByUsersArgs<ExtArgs>
    _count?: boolean | AlbumCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["album"]>

  export type AlbumSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    artist?: boolean
    cover?: boolean
    year?: boolean
    type?: boolean
  }, ExtArgs["result"]["album"]>

  export type AlbumSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    artist?: boolean
    cover?: boolean
    year?: boolean
    type?: boolean
  }, ExtArgs["result"]["album"]>

  export type AlbumSelectScalar = {
    id?: boolean
    name?: boolean
    artist?: boolean
    cover?: boolean
    year?: boolean
    type?: boolean
  }

  export type AlbumOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "artist" | "cover" | "year" | "type", ExtArgs["result"]["album"]>
  export type AlbumInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tracks?: boolean | Album$tracksArgs<ExtArgs>
    likedByUsers?: boolean | Album$likedByUsersArgs<ExtArgs>
    listenedByUsers?: boolean | Album$listenedByUsersArgs<ExtArgs>
    _count?: boolean | AlbumCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlbumIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AlbumIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AlbumPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Album"
    objects: {
      tracks: Prisma.$TrackPayload<ExtArgs>[]
      /**
       * 🔁 反向关系
       */
      likedByUsers: Prisma.$UserAlbumLikePayload<ExtArgs>[]
      listenedByUsers: Prisma.$UserAlbumHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      artist: string
      cover: string | null
      year: string | null
      type: $Enums.TrackType
    }, ExtArgs["result"]["album"]>
    composites: {}
  }

  type AlbumGetPayload<S extends boolean | null | undefined | AlbumDefaultArgs> = $Result.GetResult<Prisma.$AlbumPayload, S>

  type AlbumCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlbumFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlbumCountAggregateInputType | true
    }

  export interface AlbumDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Album'], meta: { name: 'Album' } }
    /**
     * Find zero or one Album that matches the filter.
     * @param {AlbumFindUniqueArgs} args - Arguments to find a Album
     * @example
     * // Get one Album
     * const album = await prisma.album.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlbumFindUniqueArgs>(args: SelectSubset<T, AlbumFindUniqueArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Album that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlbumFindUniqueOrThrowArgs} args - Arguments to find a Album
     * @example
     * // Get one Album
     * const album = await prisma.album.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlbumFindUniqueOrThrowArgs>(args: SelectSubset<T, AlbumFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Album that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumFindFirstArgs} args - Arguments to find a Album
     * @example
     * // Get one Album
     * const album = await prisma.album.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlbumFindFirstArgs>(args?: SelectSubset<T, AlbumFindFirstArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Album that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumFindFirstOrThrowArgs} args - Arguments to find a Album
     * @example
     * // Get one Album
     * const album = await prisma.album.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlbumFindFirstOrThrowArgs>(args?: SelectSubset<T, AlbumFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Albums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Albums
     * const albums = await prisma.album.findMany()
     * 
     * // Get first 10 Albums
     * const albums = await prisma.album.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const albumWithIdOnly = await prisma.album.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlbumFindManyArgs>(args?: SelectSubset<T, AlbumFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Album.
     * @param {AlbumCreateArgs} args - Arguments to create a Album.
     * @example
     * // Create one Album
     * const Album = await prisma.album.create({
     *   data: {
     *     // ... data to create a Album
     *   }
     * })
     * 
     */
    create<T extends AlbumCreateArgs>(args: SelectSubset<T, AlbumCreateArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Albums.
     * @param {AlbumCreateManyArgs} args - Arguments to create many Albums.
     * @example
     * // Create many Albums
     * const album = await prisma.album.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlbumCreateManyArgs>(args?: SelectSubset<T, AlbumCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Albums and returns the data saved in the database.
     * @param {AlbumCreateManyAndReturnArgs} args - Arguments to create many Albums.
     * @example
     * // Create many Albums
     * const album = await prisma.album.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Albums and only return the `id`
     * const albumWithIdOnly = await prisma.album.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlbumCreateManyAndReturnArgs>(args?: SelectSubset<T, AlbumCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Album.
     * @param {AlbumDeleteArgs} args - Arguments to delete one Album.
     * @example
     * // Delete one Album
     * const Album = await prisma.album.delete({
     *   where: {
     *     // ... filter to delete one Album
     *   }
     * })
     * 
     */
    delete<T extends AlbumDeleteArgs>(args: SelectSubset<T, AlbumDeleteArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Album.
     * @param {AlbumUpdateArgs} args - Arguments to update one Album.
     * @example
     * // Update one Album
     * const album = await prisma.album.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlbumUpdateArgs>(args: SelectSubset<T, AlbumUpdateArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Albums.
     * @param {AlbumDeleteManyArgs} args - Arguments to filter Albums to delete.
     * @example
     * // Delete a few Albums
     * const { count } = await prisma.album.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlbumDeleteManyArgs>(args?: SelectSubset<T, AlbumDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Albums
     * const album = await prisma.album.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlbumUpdateManyArgs>(args: SelectSubset<T, AlbumUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Albums and returns the data updated in the database.
     * @param {AlbumUpdateManyAndReturnArgs} args - Arguments to update many Albums.
     * @example
     * // Update many Albums
     * const album = await prisma.album.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Albums and only return the `id`
     * const albumWithIdOnly = await prisma.album.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlbumUpdateManyAndReturnArgs>(args: SelectSubset<T, AlbumUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Album.
     * @param {AlbumUpsertArgs} args - Arguments to update or create a Album.
     * @example
     * // Update or create a Album
     * const album = await prisma.album.upsert({
     *   create: {
     *     // ... data to create a Album
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Album we want to update
     *   }
     * })
     */
    upsert<T extends AlbumUpsertArgs>(args: SelectSubset<T, AlbumUpsertArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumCountArgs} args - Arguments to filter Albums to count.
     * @example
     * // Count the number of Albums
     * const count = await prisma.album.count({
     *   where: {
     *     // ... the filter for the Albums we want to count
     *   }
     * })
    **/
    count<T extends AlbumCountArgs>(
      args?: Subset<T, AlbumCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlbumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Album.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlbumAggregateArgs>(args: Subset<T, AlbumAggregateArgs>): Prisma.PrismaPromise<GetAlbumAggregateType<T>>

    /**
     * Group by Album.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlbumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlbumGroupByArgs['orderBy'] }
        : { orderBy?: AlbumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlbumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlbumGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Album model
   */
  readonly fields: AlbumFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Album.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlbumClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tracks<T extends Album$tracksArgs<ExtArgs> = {}>(args?: Subset<T, Album$tracksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likedByUsers<T extends Album$likedByUsersArgs<ExtArgs> = {}>(args?: Subset<T, Album$likedByUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlbumLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    listenedByUsers<T extends Album$listenedByUsersArgs<ExtArgs> = {}>(args?: Subset<T, Album$listenedByUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlbumHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Album model
   */
  interface AlbumFieldRefs {
    readonly id: FieldRef<"Album", 'Int'>
    readonly name: FieldRef<"Album", 'String'>
    readonly artist: FieldRef<"Album", 'String'>
    readonly cover: FieldRef<"Album", 'String'>
    readonly year: FieldRef<"Album", 'String'>
    readonly type: FieldRef<"Album", 'TrackType'>
  }
    

  // Custom InputTypes
  /**
   * Album findUnique
   */
  export type AlbumFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Album to fetch.
     */
    where: AlbumWhereUniqueInput
  }

  /**
   * Album findUniqueOrThrow
   */
  export type AlbumFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Album to fetch.
     */
    where: AlbumWhereUniqueInput
  }

  /**
   * Album findFirst
   */
  export type AlbumFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Album to fetch.
     */
    where?: AlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Albums to fetch.
     */
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Albums.
     */
    cursor?: AlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Albums.
     */
    distinct?: AlbumScalarFieldEnum | AlbumScalarFieldEnum[]
  }

  /**
   * Album findFirstOrThrow
   */
  export type AlbumFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Album to fetch.
     */
    where?: AlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Albums to fetch.
     */
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Albums.
     */
    cursor?: AlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Albums.
     */
    distinct?: AlbumScalarFieldEnum | AlbumScalarFieldEnum[]
  }

  /**
   * Album findMany
   */
  export type AlbumFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Albums to fetch.
     */
    where?: AlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Albums to fetch.
     */
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Albums.
     */
    cursor?: AlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Albums.
     */
    skip?: number
    distinct?: AlbumScalarFieldEnum | AlbumScalarFieldEnum[]
  }

  /**
   * Album create
   */
  export type AlbumCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * The data needed to create a Album.
     */
    data: XOR<AlbumCreateInput, AlbumUncheckedCreateInput>
  }

  /**
   * Album createMany
   */
  export type AlbumCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Albums.
     */
    data: AlbumCreateManyInput | AlbumCreateManyInput[]
  }

  /**
   * Album createManyAndReturn
   */
  export type AlbumCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * The data used to create many Albums.
     */
    data: AlbumCreateManyInput | AlbumCreateManyInput[]
  }

  /**
   * Album update
   */
  export type AlbumUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * The data needed to update a Album.
     */
    data: XOR<AlbumUpdateInput, AlbumUncheckedUpdateInput>
    /**
     * Choose, which Album to update.
     */
    where: AlbumWhereUniqueInput
  }

  /**
   * Album updateMany
   */
  export type AlbumUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Albums.
     */
    data: XOR<AlbumUpdateManyMutationInput, AlbumUncheckedUpdateManyInput>
    /**
     * Filter which Albums to update
     */
    where?: AlbumWhereInput
    /**
     * Limit how many Albums to update.
     */
    limit?: number
  }

  /**
   * Album updateManyAndReturn
   */
  export type AlbumUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * The data used to update Albums.
     */
    data: XOR<AlbumUpdateManyMutationInput, AlbumUncheckedUpdateManyInput>
    /**
     * Filter which Albums to update
     */
    where?: AlbumWhereInput
    /**
     * Limit how many Albums to update.
     */
    limit?: number
  }

  /**
   * Album upsert
   */
  export type AlbumUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * The filter to search for the Album to update in case it exists.
     */
    where: AlbumWhereUniqueInput
    /**
     * In case the Album found by the `where` argument doesn't exist, create a new Album with this data.
     */
    create: XOR<AlbumCreateInput, AlbumUncheckedCreateInput>
    /**
     * In case the Album was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlbumUpdateInput, AlbumUncheckedUpdateInput>
  }

  /**
   * Album delete
   */
  export type AlbumDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter which Album to delete.
     */
    where: AlbumWhereUniqueInput
  }

  /**
   * Album deleteMany
   */
  export type AlbumDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Albums to delete
     */
    where?: AlbumWhereInput
    /**
     * Limit how many Albums to delete.
     */
    limit?: number
  }

  /**
   * Album.tracks
   */
  export type Album$tracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Track
     */
    omit?: TrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null
    where?: TrackWhereInput
    orderBy?: TrackOrderByWithRelationInput | TrackOrderByWithRelationInput[]
    cursor?: TrackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrackScalarFieldEnum | TrackScalarFieldEnum[]
  }

  /**
   * Album.likedByUsers
   */
  export type Album$likedByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumLike
     */
    select?: UserAlbumLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumLike
     */
    omit?: UserAlbumLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumLikeInclude<ExtArgs> | null
    where?: UserAlbumLikeWhereInput
    orderBy?: UserAlbumLikeOrderByWithRelationInput | UserAlbumLikeOrderByWithRelationInput[]
    cursor?: UserAlbumLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAlbumLikeScalarFieldEnum | UserAlbumLikeScalarFieldEnum[]
  }

  /**
   * Album.listenedByUsers
   */
  export type Album$listenedByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumHistory
     */
    select?: UserAlbumHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumHistory
     */
    omit?: UserAlbumHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumHistoryInclude<ExtArgs> | null
    where?: UserAlbumHistoryWhereInput
    orderBy?: UserAlbumHistoryOrderByWithRelationInput | UserAlbumHistoryOrderByWithRelationInput[]
    cursor?: UserAlbumHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAlbumHistoryScalarFieldEnum | UserAlbumHistoryScalarFieldEnum[]
  }

  /**
   * Album without action
   */
  export type AlbumDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
  }


  /**
   * Model Artist
   */

  export type AggregateArtist = {
    _count: ArtistCountAggregateOutputType | null
    _avg: ArtistAvgAggregateOutputType | null
    _sum: ArtistSumAggregateOutputType | null
    _min: ArtistMinAggregateOutputType | null
    _max: ArtistMaxAggregateOutputType | null
  }

  export type ArtistAvgAggregateOutputType = {
    id: number | null
  }

  export type ArtistSumAggregateOutputType = {
    id: number | null
  }

  export type ArtistMinAggregateOutputType = {
    id: number | null
    name: string | null
    avatar: string | null
    type: $Enums.TrackType | null
  }

  export type ArtistMaxAggregateOutputType = {
    id: number | null
    name: string | null
    avatar: string | null
    type: $Enums.TrackType | null
  }

  export type ArtistCountAggregateOutputType = {
    id: number
    name: number
    avatar: number
    type: number
    _all: number
  }


  export type ArtistAvgAggregateInputType = {
    id?: true
  }

  export type ArtistSumAggregateInputType = {
    id?: true
  }

  export type ArtistMinAggregateInputType = {
    id?: true
    name?: true
    avatar?: true
    type?: true
  }

  export type ArtistMaxAggregateInputType = {
    id?: true
    name?: true
    avatar?: true
    type?: true
  }

  export type ArtistCountAggregateInputType = {
    id?: true
    name?: true
    avatar?: true
    type?: true
    _all?: true
  }

  export type ArtistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Artist to aggregate.
     */
    where?: ArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artists to fetch.
     */
    orderBy?: ArtistOrderByWithRelationInput | ArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Artists
    **/
    _count?: true | ArtistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArtistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArtistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtistMaxAggregateInputType
  }

  export type GetArtistAggregateType<T extends ArtistAggregateArgs> = {
        [P in keyof T & keyof AggregateArtist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtist[P]>
      : GetScalarType<T[P], AggregateArtist[P]>
  }




  export type ArtistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtistWhereInput
    orderBy?: ArtistOrderByWithAggregationInput | ArtistOrderByWithAggregationInput[]
    by: ArtistScalarFieldEnum[] | ArtistScalarFieldEnum
    having?: ArtistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtistCountAggregateInputType | true
    _avg?: ArtistAvgAggregateInputType
    _sum?: ArtistSumAggregateInputType
    _min?: ArtistMinAggregateInputType
    _max?: ArtistMaxAggregateInputType
  }

  export type ArtistGroupByOutputType = {
    id: number
    name: string
    avatar: string | null
    type: $Enums.TrackType
    _count: ArtistCountAggregateOutputType | null
    _avg: ArtistAvgAggregateOutputType | null
    _sum: ArtistSumAggregateOutputType | null
    _min: ArtistMinAggregateOutputType | null
    _max: ArtistMaxAggregateOutputType | null
  }

  type GetArtistGroupByPayload<T extends ArtistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtistGroupByOutputType[P]>
            : GetScalarType<T[P], ArtistGroupByOutputType[P]>
        }
      >
    >


  export type ArtistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    avatar?: boolean
    type?: boolean
    tracks?: boolean | Artist$tracksArgs<ExtArgs>
    _count?: boolean | ArtistCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artist"]>

  export type ArtistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    avatar?: boolean
    type?: boolean
  }, ExtArgs["result"]["artist"]>

  export type ArtistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    avatar?: boolean
    type?: boolean
  }, ExtArgs["result"]["artist"]>

  export type ArtistSelectScalar = {
    id?: boolean
    name?: boolean
    avatar?: boolean
    type?: boolean
  }

  export type ArtistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "avatar" | "type", ExtArgs["result"]["artist"]>
  export type ArtistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tracks?: boolean | Artist$tracksArgs<ExtArgs>
    _count?: boolean | ArtistCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ArtistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ArtistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ArtistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Artist"
    objects: {
      tracks: Prisma.$TrackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      avatar: string | null
      type: $Enums.TrackType
    }, ExtArgs["result"]["artist"]>
    composites: {}
  }

  type ArtistGetPayload<S extends boolean | null | undefined | ArtistDefaultArgs> = $Result.GetResult<Prisma.$ArtistPayload, S>

  type ArtistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArtistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArtistCountAggregateInputType | true
    }

  export interface ArtistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Artist'], meta: { name: 'Artist' } }
    /**
     * Find zero or one Artist that matches the filter.
     * @param {ArtistFindUniqueArgs} args - Arguments to find a Artist
     * @example
     * // Get one Artist
     * const artist = await prisma.artist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtistFindUniqueArgs>(args: SelectSubset<T, ArtistFindUniqueArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Artist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtistFindUniqueOrThrowArgs} args - Arguments to find a Artist
     * @example
     * // Get one Artist
     * const artist = await prisma.artist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtistFindUniqueOrThrowArgs>(args: SelectSubset<T, ArtistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistFindFirstArgs} args - Arguments to find a Artist
     * @example
     * // Get one Artist
     * const artist = await prisma.artist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtistFindFirstArgs>(args?: SelectSubset<T, ArtistFindFirstArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistFindFirstOrThrowArgs} args - Arguments to find a Artist
     * @example
     * // Get one Artist
     * const artist = await prisma.artist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtistFindFirstOrThrowArgs>(args?: SelectSubset<T, ArtistFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Artists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Artists
     * const artists = await prisma.artist.findMany()
     * 
     * // Get first 10 Artists
     * const artists = await prisma.artist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const artistWithIdOnly = await prisma.artist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArtistFindManyArgs>(args?: SelectSubset<T, ArtistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Artist.
     * @param {ArtistCreateArgs} args - Arguments to create a Artist.
     * @example
     * // Create one Artist
     * const Artist = await prisma.artist.create({
     *   data: {
     *     // ... data to create a Artist
     *   }
     * })
     * 
     */
    create<T extends ArtistCreateArgs>(args: SelectSubset<T, ArtistCreateArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Artists.
     * @param {ArtistCreateManyArgs} args - Arguments to create many Artists.
     * @example
     * // Create many Artists
     * const artist = await prisma.artist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArtistCreateManyArgs>(args?: SelectSubset<T, ArtistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Artists and returns the data saved in the database.
     * @param {ArtistCreateManyAndReturnArgs} args - Arguments to create many Artists.
     * @example
     * // Create many Artists
     * const artist = await prisma.artist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Artists and only return the `id`
     * const artistWithIdOnly = await prisma.artist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArtistCreateManyAndReturnArgs>(args?: SelectSubset<T, ArtistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Artist.
     * @param {ArtistDeleteArgs} args - Arguments to delete one Artist.
     * @example
     * // Delete one Artist
     * const Artist = await prisma.artist.delete({
     *   where: {
     *     // ... filter to delete one Artist
     *   }
     * })
     * 
     */
    delete<T extends ArtistDeleteArgs>(args: SelectSubset<T, ArtistDeleteArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Artist.
     * @param {ArtistUpdateArgs} args - Arguments to update one Artist.
     * @example
     * // Update one Artist
     * const artist = await prisma.artist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArtistUpdateArgs>(args: SelectSubset<T, ArtistUpdateArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Artists.
     * @param {ArtistDeleteManyArgs} args - Arguments to filter Artists to delete.
     * @example
     * // Delete a few Artists
     * const { count } = await prisma.artist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArtistDeleteManyArgs>(args?: SelectSubset<T, ArtistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Artists
     * const artist = await prisma.artist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArtistUpdateManyArgs>(args: SelectSubset<T, ArtistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artists and returns the data updated in the database.
     * @param {ArtistUpdateManyAndReturnArgs} args - Arguments to update many Artists.
     * @example
     * // Update many Artists
     * const artist = await prisma.artist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Artists and only return the `id`
     * const artistWithIdOnly = await prisma.artist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArtistUpdateManyAndReturnArgs>(args: SelectSubset<T, ArtistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Artist.
     * @param {ArtistUpsertArgs} args - Arguments to update or create a Artist.
     * @example
     * // Update or create a Artist
     * const artist = await prisma.artist.upsert({
     *   create: {
     *     // ... data to create a Artist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Artist we want to update
     *   }
     * })
     */
    upsert<T extends ArtistUpsertArgs>(args: SelectSubset<T, ArtistUpsertArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Artists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistCountArgs} args - Arguments to filter Artists to count.
     * @example
     * // Count the number of Artists
     * const count = await prisma.artist.count({
     *   where: {
     *     // ... the filter for the Artists we want to count
     *   }
     * })
    **/
    count<T extends ArtistCountArgs>(
      args?: Subset<T, ArtistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Artist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtistAggregateArgs>(args: Subset<T, ArtistAggregateArgs>): Prisma.PrismaPromise<GetArtistAggregateType<T>>

    /**
     * Group by Artist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArtistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtistGroupByArgs['orderBy'] }
        : { orderBy?: ArtistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArtistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Artist model
   */
  readonly fields: ArtistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Artist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tracks<T extends Artist$tracksArgs<ExtArgs> = {}>(args?: Subset<T, Artist$tracksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Artist model
   */
  interface ArtistFieldRefs {
    readonly id: FieldRef<"Artist", 'Int'>
    readonly name: FieldRef<"Artist", 'String'>
    readonly avatar: FieldRef<"Artist", 'String'>
    readonly type: FieldRef<"Artist", 'TrackType'>
  }
    

  // Custom InputTypes
  /**
   * Artist findUnique
   */
  export type ArtistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artist to fetch.
     */
    where: ArtistWhereUniqueInput
  }

  /**
   * Artist findUniqueOrThrow
   */
  export type ArtistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artist to fetch.
     */
    where: ArtistWhereUniqueInput
  }

  /**
   * Artist findFirst
   */
  export type ArtistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artist to fetch.
     */
    where?: ArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artists to fetch.
     */
    orderBy?: ArtistOrderByWithRelationInput | ArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Artists.
     */
    cursor?: ArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Artists.
     */
    distinct?: ArtistScalarFieldEnum | ArtistScalarFieldEnum[]
  }

  /**
   * Artist findFirstOrThrow
   */
  export type ArtistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artist to fetch.
     */
    where?: ArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artists to fetch.
     */
    orderBy?: ArtistOrderByWithRelationInput | ArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Artists.
     */
    cursor?: ArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Artists.
     */
    distinct?: ArtistScalarFieldEnum | ArtistScalarFieldEnum[]
  }

  /**
   * Artist findMany
   */
  export type ArtistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artists to fetch.
     */
    where?: ArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artists to fetch.
     */
    orderBy?: ArtistOrderByWithRelationInput | ArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Artists.
     */
    cursor?: ArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artists.
     */
    skip?: number
    distinct?: ArtistScalarFieldEnum | ArtistScalarFieldEnum[]
  }

  /**
   * Artist create
   */
  export type ArtistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * The data needed to create a Artist.
     */
    data: XOR<ArtistCreateInput, ArtistUncheckedCreateInput>
  }

  /**
   * Artist createMany
   */
  export type ArtistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Artists.
     */
    data: ArtistCreateManyInput | ArtistCreateManyInput[]
  }

  /**
   * Artist createManyAndReturn
   */
  export type ArtistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * The data used to create many Artists.
     */
    data: ArtistCreateManyInput | ArtistCreateManyInput[]
  }

  /**
   * Artist update
   */
  export type ArtistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * The data needed to update a Artist.
     */
    data: XOR<ArtistUpdateInput, ArtistUncheckedUpdateInput>
    /**
     * Choose, which Artist to update.
     */
    where: ArtistWhereUniqueInput
  }

  /**
   * Artist updateMany
   */
  export type ArtistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Artists.
     */
    data: XOR<ArtistUpdateManyMutationInput, ArtistUncheckedUpdateManyInput>
    /**
     * Filter which Artists to update
     */
    where?: ArtistWhereInput
    /**
     * Limit how many Artists to update.
     */
    limit?: number
  }

  /**
   * Artist updateManyAndReturn
   */
  export type ArtistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * The data used to update Artists.
     */
    data: XOR<ArtistUpdateManyMutationInput, ArtistUncheckedUpdateManyInput>
    /**
     * Filter which Artists to update
     */
    where?: ArtistWhereInput
    /**
     * Limit how many Artists to update.
     */
    limit?: number
  }

  /**
   * Artist upsert
   */
  export type ArtistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * The filter to search for the Artist to update in case it exists.
     */
    where: ArtistWhereUniqueInput
    /**
     * In case the Artist found by the `where` argument doesn't exist, create a new Artist with this data.
     */
    create: XOR<ArtistCreateInput, ArtistUncheckedCreateInput>
    /**
     * In case the Artist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtistUpdateInput, ArtistUncheckedUpdateInput>
  }

  /**
   * Artist delete
   */
  export type ArtistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * Filter which Artist to delete.
     */
    where: ArtistWhereUniqueInput
  }

  /**
   * Artist deleteMany
   */
  export type ArtistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Artists to delete
     */
    where?: ArtistWhereInput
    /**
     * Limit how many Artists to delete.
     */
    limit?: number
  }

  /**
   * Artist.tracks
   */
  export type Artist$tracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Track
     */
    omit?: TrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null
    where?: TrackWhereInput
    orderBy?: TrackOrderByWithRelationInput | TrackOrderByWithRelationInput[]
    cursor?: TrackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrackScalarFieldEnum | TrackScalarFieldEnum[]
  }

  /**
   * Artist without action
   */
  export type ArtistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
  }


  /**
   * Model UserTrackLike
   */

  export type AggregateUserTrackLike = {
    _count: UserTrackLikeCountAggregateOutputType | null
    _avg: UserTrackLikeAvgAggregateOutputType | null
    _sum: UserTrackLikeSumAggregateOutputType | null
    _min: UserTrackLikeMinAggregateOutputType | null
    _max: UserTrackLikeMaxAggregateOutputType | null
  }

  export type UserTrackLikeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    trackId: number | null
  }

  export type UserTrackLikeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    trackId: number | null
  }

  export type UserTrackLikeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    trackId: number | null
    createdAt: Date | null
  }

  export type UserTrackLikeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    trackId: number | null
    createdAt: Date | null
  }

  export type UserTrackLikeCountAggregateOutputType = {
    id: number
    userId: number
    trackId: number
    createdAt: number
    _all: number
  }


  export type UserTrackLikeAvgAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
  }

  export type UserTrackLikeSumAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
  }

  export type UserTrackLikeMinAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
    createdAt?: true
  }

  export type UserTrackLikeMaxAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
    createdAt?: true
  }

  export type UserTrackLikeCountAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
    createdAt?: true
    _all?: true
  }

  export type UserTrackLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTrackLike to aggregate.
     */
    where?: UserTrackLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTrackLikes to fetch.
     */
    orderBy?: UserTrackLikeOrderByWithRelationInput | UserTrackLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTrackLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTrackLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTrackLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTrackLikes
    **/
    _count?: true | UserTrackLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTrackLikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTrackLikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTrackLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTrackLikeMaxAggregateInputType
  }

  export type GetUserTrackLikeAggregateType<T extends UserTrackLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTrackLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTrackLike[P]>
      : GetScalarType<T[P], AggregateUserTrackLike[P]>
  }




  export type UserTrackLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTrackLikeWhereInput
    orderBy?: UserTrackLikeOrderByWithAggregationInput | UserTrackLikeOrderByWithAggregationInput[]
    by: UserTrackLikeScalarFieldEnum[] | UserTrackLikeScalarFieldEnum
    having?: UserTrackLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTrackLikeCountAggregateInputType | true
    _avg?: UserTrackLikeAvgAggregateInputType
    _sum?: UserTrackLikeSumAggregateInputType
    _min?: UserTrackLikeMinAggregateInputType
    _max?: UserTrackLikeMaxAggregateInputType
  }

  export type UserTrackLikeGroupByOutputType = {
    id: number
    userId: number
    trackId: number
    createdAt: Date
    _count: UserTrackLikeCountAggregateOutputType | null
    _avg: UserTrackLikeAvgAggregateOutputType | null
    _sum: UserTrackLikeSumAggregateOutputType | null
    _min: UserTrackLikeMinAggregateOutputType | null
    _max: UserTrackLikeMaxAggregateOutputType | null
  }

  type GetUserTrackLikeGroupByPayload<T extends UserTrackLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTrackLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTrackLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTrackLikeGroupByOutputType[P]>
            : GetScalarType<T[P], UserTrackLikeGroupByOutputType[P]>
        }
      >
    >


  export type UserTrackLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    trackId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTrackLike"]>

  export type UserTrackLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    trackId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTrackLike"]>

  export type UserTrackLikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    trackId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTrackLike"]>

  export type UserTrackLikeSelectScalar = {
    id?: boolean
    userId?: boolean
    trackId?: boolean
    createdAt?: boolean
  }

  export type UserTrackLikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "trackId" | "createdAt", ExtArgs["result"]["userTrackLike"]>
  export type UserTrackLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
  }
  export type UserTrackLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
  }
  export type UserTrackLikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
  }

  export type $UserTrackLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTrackLike"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      track: Prisma.$TrackPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      trackId: number
      createdAt: Date
    }, ExtArgs["result"]["userTrackLike"]>
    composites: {}
  }

  type UserTrackLikeGetPayload<S extends boolean | null | undefined | UserTrackLikeDefaultArgs> = $Result.GetResult<Prisma.$UserTrackLikePayload, S>

  type UserTrackLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserTrackLikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserTrackLikeCountAggregateInputType | true
    }

  export interface UserTrackLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTrackLike'], meta: { name: 'UserTrackLike' } }
    /**
     * Find zero or one UserTrackLike that matches the filter.
     * @param {UserTrackLikeFindUniqueArgs} args - Arguments to find a UserTrackLike
     * @example
     * // Get one UserTrackLike
     * const userTrackLike = await prisma.userTrackLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTrackLikeFindUniqueArgs>(args: SelectSubset<T, UserTrackLikeFindUniqueArgs<ExtArgs>>): Prisma__UserTrackLikeClient<$Result.GetResult<Prisma.$UserTrackLikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserTrackLike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserTrackLikeFindUniqueOrThrowArgs} args - Arguments to find a UserTrackLike
     * @example
     * // Get one UserTrackLike
     * const userTrackLike = await prisma.userTrackLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTrackLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTrackLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTrackLikeClient<$Result.GetResult<Prisma.$UserTrackLikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTrackLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrackLikeFindFirstArgs} args - Arguments to find a UserTrackLike
     * @example
     * // Get one UserTrackLike
     * const userTrackLike = await prisma.userTrackLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTrackLikeFindFirstArgs>(args?: SelectSubset<T, UserTrackLikeFindFirstArgs<ExtArgs>>): Prisma__UserTrackLikeClient<$Result.GetResult<Prisma.$UserTrackLikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTrackLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrackLikeFindFirstOrThrowArgs} args - Arguments to find a UserTrackLike
     * @example
     * // Get one UserTrackLike
     * const userTrackLike = await prisma.userTrackLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTrackLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTrackLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTrackLikeClient<$Result.GetResult<Prisma.$UserTrackLikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTrackLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrackLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTrackLikes
     * const userTrackLikes = await prisma.userTrackLike.findMany()
     * 
     * // Get first 10 UserTrackLikes
     * const userTrackLikes = await prisma.userTrackLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTrackLikeWithIdOnly = await prisma.userTrackLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTrackLikeFindManyArgs>(args?: SelectSubset<T, UserTrackLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTrackLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserTrackLike.
     * @param {UserTrackLikeCreateArgs} args - Arguments to create a UserTrackLike.
     * @example
     * // Create one UserTrackLike
     * const UserTrackLike = await prisma.userTrackLike.create({
     *   data: {
     *     // ... data to create a UserTrackLike
     *   }
     * })
     * 
     */
    create<T extends UserTrackLikeCreateArgs>(args: SelectSubset<T, UserTrackLikeCreateArgs<ExtArgs>>): Prisma__UserTrackLikeClient<$Result.GetResult<Prisma.$UserTrackLikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserTrackLikes.
     * @param {UserTrackLikeCreateManyArgs} args - Arguments to create many UserTrackLikes.
     * @example
     * // Create many UserTrackLikes
     * const userTrackLike = await prisma.userTrackLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTrackLikeCreateManyArgs>(args?: SelectSubset<T, UserTrackLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTrackLikes and returns the data saved in the database.
     * @param {UserTrackLikeCreateManyAndReturnArgs} args - Arguments to create many UserTrackLikes.
     * @example
     * // Create many UserTrackLikes
     * const userTrackLike = await prisma.userTrackLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTrackLikes and only return the `id`
     * const userTrackLikeWithIdOnly = await prisma.userTrackLike.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTrackLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTrackLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTrackLikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserTrackLike.
     * @param {UserTrackLikeDeleteArgs} args - Arguments to delete one UserTrackLike.
     * @example
     * // Delete one UserTrackLike
     * const UserTrackLike = await prisma.userTrackLike.delete({
     *   where: {
     *     // ... filter to delete one UserTrackLike
     *   }
     * })
     * 
     */
    delete<T extends UserTrackLikeDeleteArgs>(args: SelectSubset<T, UserTrackLikeDeleteArgs<ExtArgs>>): Prisma__UserTrackLikeClient<$Result.GetResult<Prisma.$UserTrackLikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserTrackLike.
     * @param {UserTrackLikeUpdateArgs} args - Arguments to update one UserTrackLike.
     * @example
     * // Update one UserTrackLike
     * const userTrackLike = await prisma.userTrackLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTrackLikeUpdateArgs>(args: SelectSubset<T, UserTrackLikeUpdateArgs<ExtArgs>>): Prisma__UserTrackLikeClient<$Result.GetResult<Prisma.$UserTrackLikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserTrackLikes.
     * @param {UserTrackLikeDeleteManyArgs} args - Arguments to filter UserTrackLikes to delete.
     * @example
     * // Delete a few UserTrackLikes
     * const { count } = await prisma.userTrackLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTrackLikeDeleteManyArgs>(args?: SelectSubset<T, UserTrackLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTrackLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrackLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTrackLikes
     * const userTrackLike = await prisma.userTrackLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTrackLikeUpdateManyArgs>(args: SelectSubset<T, UserTrackLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTrackLikes and returns the data updated in the database.
     * @param {UserTrackLikeUpdateManyAndReturnArgs} args - Arguments to update many UserTrackLikes.
     * @example
     * // Update many UserTrackLikes
     * const userTrackLike = await prisma.userTrackLike.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserTrackLikes and only return the `id`
     * const userTrackLikeWithIdOnly = await prisma.userTrackLike.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserTrackLikeUpdateManyAndReturnArgs>(args: SelectSubset<T, UserTrackLikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTrackLikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserTrackLike.
     * @param {UserTrackLikeUpsertArgs} args - Arguments to update or create a UserTrackLike.
     * @example
     * // Update or create a UserTrackLike
     * const userTrackLike = await prisma.userTrackLike.upsert({
     *   create: {
     *     // ... data to create a UserTrackLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTrackLike we want to update
     *   }
     * })
     */
    upsert<T extends UserTrackLikeUpsertArgs>(args: SelectSubset<T, UserTrackLikeUpsertArgs<ExtArgs>>): Prisma__UserTrackLikeClient<$Result.GetResult<Prisma.$UserTrackLikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserTrackLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrackLikeCountArgs} args - Arguments to filter UserTrackLikes to count.
     * @example
     * // Count the number of UserTrackLikes
     * const count = await prisma.userTrackLike.count({
     *   where: {
     *     // ... the filter for the UserTrackLikes we want to count
     *   }
     * })
    **/
    count<T extends UserTrackLikeCountArgs>(
      args?: Subset<T, UserTrackLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTrackLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTrackLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrackLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTrackLikeAggregateArgs>(args: Subset<T, UserTrackLikeAggregateArgs>): Prisma.PrismaPromise<GetUserTrackLikeAggregateType<T>>

    /**
     * Group by UserTrackLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrackLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTrackLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTrackLikeGroupByArgs['orderBy'] }
        : { orderBy?: UserTrackLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTrackLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTrackLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTrackLike model
   */
  readonly fields: UserTrackLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTrackLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTrackLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    track<T extends TrackDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrackDefaultArgs<ExtArgs>>): Prisma__TrackClient<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTrackLike model
   */
  interface UserTrackLikeFieldRefs {
    readonly id: FieldRef<"UserTrackLike", 'Int'>
    readonly userId: FieldRef<"UserTrackLike", 'Int'>
    readonly trackId: FieldRef<"UserTrackLike", 'Int'>
    readonly createdAt: FieldRef<"UserTrackLike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserTrackLike findUnique
   */
  export type UserTrackLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackLike
     */
    select?: UserTrackLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackLike
     */
    omit?: UserTrackLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackLikeInclude<ExtArgs> | null
    /**
     * Filter, which UserTrackLike to fetch.
     */
    where: UserTrackLikeWhereUniqueInput
  }

  /**
   * UserTrackLike findUniqueOrThrow
   */
  export type UserTrackLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackLike
     */
    select?: UserTrackLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackLike
     */
    omit?: UserTrackLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackLikeInclude<ExtArgs> | null
    /**
     * Filter, which UserTrackLike to fetch.
     */
    where: UserTrackLikeWhereUniqueInput
  }

  /**
   * UserTrackLike findFirst
   */
  export type UserTrackLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackLike
     */
    select?: UserTrackLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackLike
     */
    omit?: UserTrackLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackLikeInclude<ExtArgs> | null
    /**
     * Filter, which UserTrackLike to fetch.
     */
    where?: UserTrackLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTrackLikes to fetch.
     */
    orderBy?: UserTrackLikeOrderByWithRelationInput | UserTrackLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTrackLikes.
     */
    cursor?: UserTrackLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTrackLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTrackLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTrackLikes.
     */
    distinct?: UserTrackLikeScalarFieldEnum | UserTrackLikeScalarFieldEnum[]
  }

  /**
   * UserTrackLike findFirstOrThrow
   */
  export type UserTrackLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackLike
     */
    select?: UserTrackLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackLike
     */
    omit?: UserTrackLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackLikeInclude<ExtArgs> | null
    /**
     * Filter, which UserTrackLike to fetch.
     */
    where?: UserTrackLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTrackLikes to fetch.
     */
    orderBy?: UserTrackLikeOrderByWithRelationInput | UserTrackLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTrackLikes.
     */
    cursor?: UserTrackLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTrackLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTrackLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTrackLikes.
     */
    distinct?: UserTrackLikeScalarFieldEnum | UserTrackLikeScalarFieldEnum[]
  }

  /**
   * UserTrackLike findMany
   */
  export type UserTrackLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackLike
     */
    select?: UserTrackLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackLike
     */
    omit?: UserTrackLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackLikeInclude<ExtArgs> | null
    /**
     * Filter, which UserTrackLikes to fetch.
     */
    where?: UserTrackLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTrackLikes to fetch.
     */
    orderBy?: UserTrackLikeOrderByWithRelationInput | UserTrackLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTrackLikes.
     */
    cursor?: UserTrackLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTrackLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTrackLikes.
     */
    skip?: number
    distinct?: UserTrackLikeScalarFieldEnum | UserTrackLikeScalarFieldEnum[]
  }

  /**
   * UserTrackLike create
   */
  export type UserTrackLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackLike
     */
    select?: UserTrackLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackLike
     */
    omit?: UserTrackLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTrackLike.
     */
    data: XOR<UserTrackLikeCreateInput, UserTrackLikeUncheckedCreateInput>
  }

  /**
   * UserTrackLike createMany
   */
  export type UserTrackLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTrackLikes.
     */
    data: UserTrackLikeCreateManyInput | UserTrackLikeCreateManyInput[]
  }

  /**
   * UserTrackLike createManyAndReturn
   */
  export type UserTrackLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackLike
     */
    select?: UserTrackLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackLike
     */
    omit?: UserTrackLikeOmit<ExtArgs> | null
    /**
     * The data used to create many UserTrackLikes.
     */
    data: UserTrackLikeCreateManyInput | UserTrackLikeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTrackLike update
   */
  export type UserTrackLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackLike
     */
    select?: UserTrackLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackLike
     */
    omit?: UserTrackLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTrackLike.
     */
    data: XOR<UserTrackLikeUpdateInput, UserTrackLikeUncheckedUpdateInput>
    /**
     * Choose, which UserTrackLike to update.
     */
    where: UserTrackLikeWhereUniqueInput
  }

  /**
   * UserTrackLike updateMany
   */
  export type UserTrackLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTrackLikes.
     */
    data: XOR<UserTrackLikeUpdateManyMutationInput, UserTrackLikeUncheckedUpdateManyInput>
    /**
     * Filter which UserTrackLikes to update
     */
    where?: UserTrackLikeWhereInput
    /**
     * Limit how many UserTrackLikes to update.
     */
    limit?: number
  }

  /**
   * UserTrackLike updateManyAndReturn
   */
  export type UserTrackLikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackLike
     */
    select?: UserTrackLikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackLike
     */
    omit?: UserTrackLikeOmit<ExtArgs> | null
    /**
     * The data used to update UserTrackLikes.
     */
    data: XOR<UserTrackLikeUpdateManyMutationInput, UserTrackLikeUncheckedUpdateManyInput>
    /**
     * Filter which UserTrackLikes to update
     */
    where?: UserTrackLikeWhereInput
    /**
     * Limit how many UserTrackLikes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackLikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTrackLike upsert
   */
  export type UserTrackLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackLike
     */
    select?: UserTrackLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackLike
     */
    omit?: UserTrackLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTrackLike to update in case it exists.
     */
    where: UserTrackLikeWhereUniqueInput
    /**
     * In case the UserTrackLike found by the `where` argument doesn't exist, create a new UserTrackLike with this data.
     */
    create: XOR<UserTrackLikeCreateInput, UserTrackLikeUncheckedCreateInput>
    /**
     * In case the UserTrackLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTrackLikeUpdateInput, UserTrackLikeUncheckedUpdateInput>
  }

  /**
   * UserTrackLike delete
   */
  export type UserTrackLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackLike
     */
    select?: UserTrackLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackLike
     */
    omit?: UserTrackLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackLikeInclude<ExtArgs> | null
    /**
     * Filter which UserTrackLike to delete.
     */
    where: UserTrackLikeWhereUniqueInput
  }

  /**
   * UserTrackLike deleteMany
   */
  export type UserTrackLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTrackLikes to delete
     */
    where?: UserTrackLikeWhereInput
    /**
     * Limit how many UserTrackLikes to delete.
     */
    limit?: number
  }

  /**
   * UserTrackLike without action
   */
  export type UserTrackLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackLike
     */
    select?: UserTrackLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackLike
     */
    omit?: UserTrackLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackLikeInclude<ExtArgs> | null
  }


  /**
   * Model UserTrackHistory
   */

  export type AggregateUserTrackHistory = {
    _count: UserTrackHistoryCountAggregateOutputType | null
    _avg: UserTrackHistoryAvgAggregateOutputType | null
    _sum: UserTrackHistorySumAggregateOutputType | null
    _min: UserTrackHistoryMinAggregateOutputType | null
    _max: UserTrackHistoryMaxAggregateOutputType | null
  }

  export type UserTrackHistoryAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    trackId: number | null
    progress: number | null
    deviceId: number | null
  }

  export type UserTrackHistorySumAggregateOutputType = {
    id: number | null
    userId: number | null
    trackId: number | null
    progress: number | null
    deviceId: number | null
  }

  export type UserTrackHistoryMinAggregateOutputType = {
    id: number | null
    userId: number | null
    trackId: number | null
    listenedAt: Date | null
    progress: number | null
    deviceName: string | null
    deviceId: number | null
    isSyncMode: boolean | null
  }

  export type UserTrackHistoryMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    trackId: number | null
    listenedAt: Date | null
    progress: number | null
    deviceName: string | null
    deviceId: number | null
    isSyncMode: boolean | null
  }

  export type UserTrackHistoryCountAggregateOutputType = {
    id: number
    userId: number
    trackId: number
    listenedAt: number
    progress: number
    deviceName: number
    deviceId: number
    isSyncMode: number
    _all: number
  }


  export type UserTrackHistoryAvgAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
    progress?: true
    deviceId?: true
  }

  export type UserTrackHistorySumAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
    progress?: true
    deviceId?: true
  }

  export type UserTrackHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
    listenedAt?: true
    progress?: true
    deviceName?: true
    deviceId?: true
    isSyncMode?: true
  }

  export type UserTrackHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
    listenedAt?: true
    progress?: true
    deviceName?: true
    deviceId?: true
    isSyncMode?: true
  }

  export type UserTrackHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
    listenedAt?: true
    progress?: true
    deviceName?: true
    deviceId?: true
    isSyncMode?: true
    _all?: true
  }

  export type UserTrackHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTrackHistory to aggregate.
     */
    where?: UserTrackHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTrackHistories to fetch.
     */
    orderBy?: UserTrackHistoryOrderByWithRelationInput | UserTrackHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTrackHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTrackHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTrackHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTrackHistories
    **/
    _count?: true | UserTrackHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTrackHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTrackHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTrackHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTrackHistoryMaxAggregateInputType
  }

  export type GetUserTrackHistoryAggregateType<T extends UserTrackHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTrackHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTrackHistory[P]>
      : GetScalarType<T[P], AggregateUserTrackHistory[P]>
  }




  export type UserTrackHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTrackHistoryWhereInput
    orderBy?: UserTrackHistoryOrderByWithAggregationInput | UserTrackHistoryOrderByWithAggregationInput[]
    by: UserTrackHistoryScalarFieldEnum[] | UserTrackHistoryScalarFieldEnum
    having?: UserTrackHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTrackHistoryCountAggregateInputType | true
    _avg?: UserTrackHistoryAvgAggregateInputType
    _sum?: UserTrackHistorySumAggregateInputType
    _min?: UserTrackHistoryMinAggregateInputType
    _max?: UserTrackHistoryMaxAggregateInputType
  }

  export type UserTrackHistoryGroupByOutputType = {
    id: number
    userId: number
    trackId: number
    listenedAt: Date
    progress: number
    deviceName: string
    deviceId: number
    isSyncMode: boolean
    _count: UserTrackHistoryCountAggregateOutputType | null
    _avg: UserTrackHistoryAvgAggregateOutputType | null
    _sum: UserTrackHistorySumAggregateOutputType | null
    _min: UserTrackHistoryMinAggregateOutputType | null
    _max: UserTrackHistoryMaxAggregateOutputType | null
  }

  type GetUserTrackHistoryGroupByPayload<T extends UserTrackHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTrackHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTrackHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTrackHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], UserTrackHistoryGroupByOutputType[P]>
        }
      >
    >


  export type UserTrackHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    trackId?: boolean
    listenedAt?: boolean
    progress?: boolean
    deviceName?: boolean
    deviceId?: boolean
    isSyncMode?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTrackHistory"]>

  export type UserTrackHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    trackId?: boolean
    listenedAt?: boolean
    progress?: boolean
    deviceName?: boolean
    deviceId?: boolean
    isSyncMode?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTrackHistory"]>

  export type UserTrackHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    trackId?: boolean
    listenedAt?: boolean
    progress?: boolean
    deviceName?: boolean
    deviceId?: boolean
    isSyncMode?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTrackHistory"]>

  export type UserTrackHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    trackId?: boolean
    listenedAt?: boolean
    progress?: boolean
    deviceName?: boolean
    deviceId?: boolean
    isSyncMode?: boolean
  }

  export type UserTrackHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "trackId" | "listenedAt" | "progress" | "deviceName" | "deviceId" | "isSyncMode", ExtArgs["result"]["userTrackHistory"]>
  export type UserTrackHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }
  export type UserTrackHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }
  export type UserTrackHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }

  export type $UserTrackHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTrackHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      track: Prisma.$TrackPayload<ExtArgs>
      device: Prisma.$DevicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      trackId: number
      listenedAt: Date
      progress: number
      deviceName: string
      deviceId: number
      isSyncMode: boolean
    }, ExtArgs["result"]["userTrackHistory"]>
    composites: {}
  }

  type UserTrackHistoryGetPayload<S extends boolean | null | undefined | UserTrackHistoryDefaultArgs> = $Result.GetResult<Prisma.$UserTrackHistoryPayload, S>

  type UserTrackHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserTrackHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserTrackHistoryCountAggregateInputType | true
    }

  export interface UserTrackHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTrackHistory'], meta: { name: 'UserTrackHistory' } }
    /**
     * Find zero or one UserTrackHistory that matches the filter.
     * @param {UserTrackHistoryFindUniqueArgs} args - Arguments to find a UserTrackHistory
     * @example
     * // Get one UserTrackHistory
     * const userTrackHistory = await prisma.userTrackHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTrackHistoryFindUniqueArgs>(args: SelectSubset<T, UserTrackHistoryFindUniqueArgs<ExtArgs>>): Prisma__UserTrackHistoryClient<$Result.GetResult<Prisma.$UserTrackHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserTrackHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserTrackHistoryFindUniqueOrThrowArgs} args - Arguments to find a UserTrackHistory
     * @example
     * // Get one UserTrackHistory
     * const userTrackHistory = await prisma.userTrackHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTrackHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTrackHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTrackHistoryClient<$Result.GetResult<Prisma.$UserTrackHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTrackHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrackHistoryFindFirstArgs} args - Arguments to find a UserTrackHistory
     * @example
     * // Get one UserTrackHistory
     * const userTrackHistory = await prisma.userTrackHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTrackHistoryFindFirstArgs>(args?: SelectSubset<T, UserTrackHistoryFindFirstArgs<ExtArgs>>): Prisma__UserTrackHistoryClient<$Result.GetResult<Prisma.$UserTrackHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTrackHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrackHistoryFindFirstOrThrowArgs} args - Arguments to find a UserTrackHistory
     * @example
     * // Get one UserTrackHistory
     * const userTrackHistory = await prisma.userTrackHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTrackHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTrackHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTrackHistoryClient<$Result.GetResult<Prisma.$UserTrackHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTrackHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrackHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTrackHistories
     * const userTrackHistories = await prisma.userTrackHistory.findMany()
     * 
     * // Get first 10 UserTrackHistories
     * const userTrackHistories = await prisma.userTrackHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTrackHistoryWithIdOnly = await prisma.userTrackHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTrackHistoryFindManyArgs>(args?: SelectSubset<T, UserTrackHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTrackHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserTrackHistory.
     * @param {UserTrackHistoryCreateArgs} args - Arguments to create a UserTrackHistory.
     * @example
     * // Create one UserTrackHistory
     * const UserTrackHistory = await prisma.userTrackHistory.create({
     *   data: {
     *     // ... data to create a UserTrackHistory
     *   }
     * })
     * 
     */
    create<T extends UserTrackHistoryCreateArgs>(args: SelectSubset<T, UserTrackHistoryCreateArgs<ExtArgs>>): Prisma__UserTrackHistoryClient<$Result.GetResult<Prisma.$UserTrackHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserTrackHistories.
     * @param {UserTrackHistoryCreateManyArgs} args - Arguments to create many UserTrackHistories.
     * @example
     * // Create many UserTrackHistories
     * const userTrackHistory = await prisma.userTrackHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTrackHistoryCreateManyArgs>(args?: SelectSubset<T, UserTrackHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTrackHistories and returns the data saved in the database.
     * @param {UserTrackHistoryCreateManyAndReturnArgs} args - Arguments to create many UserTrackHistories.
     * @example
     * // Create many UserTrackHistories
     * const userTrackHistory = await prisma.userTrackHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTrackHistories and only return the `id`
     * const userTrackHistoryWithIdOnly = await prisma.userTrackHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTrackHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTrackHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTrackHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserTrackHistory.
     * @param {UserTrackHistoryDeleteArgs} args - Arguments to delete one UserTrackHistory.
     * @example
     * // Delete one UserTrackHistory
     * const UserTrackHistory = await prisma.userTrackHistory.delete({
     *   where: {
     *     // ... filter to delete one UserTrackHistory
     *   }
     * })
     * 
     */
    delete<T extends UserTrackHistoryDeleteArgs>(args: SelectSubset<T, UserTrackHistoryDeleteArgs<ExtArgs>>): Prisma__UserTrackHistoryClient<$Result.GetResult<Prisma.$UserTrackHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserTrackHistory.
     * @param {UserTrackHistoryUpdateArgs} args - Arguments to update one UserTrackHistory.
     * @example
     * // Update one UserTrackHistory
     * const userTrackHistory = await prisma.userTrackHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTrackHistoryUpdateArgs>(args: SelectSubset<T, UserTrackHistoryUpdateArgs<ExtArgs>>): Prisma__UserTrackHistoryClient<$Result.GetResult<Prisma.$UserTrackHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserTrackHistories.
     * @param {UserTrackHistoryDeleteManyArgs} args - Arguments to filter UserTrackHistories to delete.
     * @example
     * // Delete a few UserTrackHistories
     * const { count } = await prisma.userTrackHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTrackHistoryDeleteManyArgs>(args?: SelectSubset<T, UserTrackHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTrackHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrackHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTrackHistories
     * const userTrackHistory = await prisma.userTrackHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTrackHistoryUpdateManyArgs>(args: SelectSubset<T, UserTrackHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTrackHistories and returns the data updated in the database.
     * @param {UserTrackHistoryUpdateManyAndReturnArgs} args - Arguments to update many UserTrackHistories.
     * @example
     * // Update many UserTrackHistories
     * const userTrackHistory = await prisma.userTrackHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserTrackHistories and only return the `id`
     * const userTrackHistoryWithIdOnly = await prisma.userTrackHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserTrackHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, UserTrackHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTrackHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserTrackHistory.
     * @param {UserTrackHistoryUpsertArgs} args - Arguments to update or create a UserTrackHistory.
     * @example
     * // Update or create a UserTrackHistory
     * const userTrackHistory = await prisma.userTrackHistory.upsert({
     *   create: {
     *     // ... data to create a UserTrackHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTrackHistory we want to update
     *   }
     * })
     */
    upsert<T extends UserTrackHistoryUpsertArgs>(args: SelectSubset<T, UserTrackHistoryUpsertArgs<ExtArgs>>): Prisma__UserTrackHistoryClient<$Result.GetResult<Prisma.$UserTrackHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserTrackHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrackHistoryCountArgs} args - Arguments to filter UserTrackHistories to count.
     * @example
     * // Count the number of UserTrackHistories
     * const count = await prisma.userTrackHistory.count({
     *   where: {
     *     // ... the filter for the UserTrackHistories we want to count
     *   }
     * })
    **/
    count<T extends UserTrackHistoryCountArgs>(
      args?: Subset<T, UserTrackHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTrackHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTrackHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrackHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTrackHistoryAggregateArgs>(args: Subset<T, UserTrackHistoryAggregateArgs>): Prisma.PrismaPromise<GetUserTrackHistoryAggregateType<T>>

    /**
     * Group by UserTrackHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrackHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTrackHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTrackHistoryGroupByArgs['orderBy'] }
        : { orderBy?: UserTrackHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTrackHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTrackHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTrackHistory model
   */
  readonly fields: UserTrackHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTrackHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTrackHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    track<T extends TrackDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrackDefaultArgs<ExtArgs>>): Prisma__TrackClient<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTrackHistory model
   */
  interface UserTrackHistoryFieldRefs {
    readonly id: FieldRef<"UserTrackHistory", 'Int'>
    readonly userId: FieldRef<"UserTrackHistory", 'Int'>
    readonly trackId: FieldRef<"UserTrackHistory", 'Int'>
    readonly listenedAt: FieldRef<"UserTrackHistory", 'DateTime'>
    readonly progress: FieldRef<"UserTrackHistory", 'Int'>
    readonly deviceName: FieldRef<"UserTrackHistory", 'String'>
    readonly deviceId: FieldRef<"UserTrackHistory", 'Int'>
    readonly isSyncMode: FieldRef<"UserTrackHistory", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * UserTrackHistory findUnique
   */
  export type UserTrackHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackHistory
     */
    select?: UserTrackHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackHistory
     */
    omit?: UserTrackHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserTrackHistory to fetch.
     */
    where: UserTrackHistoryWhereUniqueInput
  }

  /**
   * UserTrackHistory findUniqueOrThrow
   */
  export type UserTrackHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackHistory
     */
    select?: UserTrackHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackHistory
     */
    omit?: UserTrackHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserTrackHistory to fetch.
     */
    where: UserTrackHistoryWhereUniqueInput
  }

  /**
   * UserTrackHistory findFirst
   */
  export type UserTrackHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackHistory
     */
    select?: UserTrackHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackHistory
     */
    omit?: UserTrackHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserTrackHistory to fetch.
     */
    where?: UserTrackHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTrackHistories to fetch.
     */
    orderBy?: UserTrackHistoryOrderByWithRelationInput | UserTrackHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTrackHistories.
     */
    cursor?: UserTrackHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTrackHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTrackHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTrackHistories.
     */
    distinct?: UserTrackHistoryScalarFieldEnum | UserTrackHistoryScalarFieldEnum[]
  }

  /**
   * UserTrackHistory findFirstOrThrow
   */
  export type UserTrackHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackHistory
     */
    select?: UserTrackHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackHistory
     */
    omit?: UserTrackHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserTrackHistory to fetch.
     */
    where?: UserTrackHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTrackHistories to fetch.
     */
    orderBy?: UserTrackHistoryOrderByWithRelationInput | UserTrackHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTrackHistories.
     */
    cursor?: UserTrackHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTrackHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTrackHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTrackHistories.
     */
    distinct?: UserTrackHistoryScalarFieldEnum | UserTrackHistoryScalarFieldEnum[]
  }

  /**
   * UserTrackHistory findMany
   */
  export type UserTrackHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackHistory
     */
    select?: UserTrackHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackHistory
     */
    omit?: UserTrackHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserTrackHistories to fetch.
     */
    where?: UserTrackHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTrackHistories to fetch.
     */
    orderBy?: UserTrackHistoryOrderByWithRelationInput | UserTrackHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTrackHistories.
     */
    cursor?: UserTrackHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTrackHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTrackHistories.
     */
    skip?: number
    distinct?: UserTrackHistoryScalarFieldEnum | UserTrackHistoryScalarFieldEnum[]
  }

  /**
   * UserTrackHistory create
   */
  export type UserTrackHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackHistory
     */
    select?: UserTrackHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackHistory
     */
    omit?: UserTrackHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTrackHistory.
     */
    data: XOR<UserTrackHistoryCreateInput, UserTrackHistoryUncheckedCreateInput>
  }

  /**
   * UserTrackHistory createMany
   */
  export type UserTrackHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTrackHistories.
     */
    data: UserTrackHistoryCreateManyInput | UserTrackHistoryCreateManyInput[]
  }

  /**
   * UserTrackHistory createManyAndReturn
   */
  export type UserTrackHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackHistory
     */
    select?: UserTrackHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackHistory
     */
    omit?: UserTrackHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many UserTrackHistories.
     */
    data: UserTrackHistoryCreateManyInput | UserTrackHistoryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTrackHistory update
   */
  export type UserTrackHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackHistory
     */
    select?: UserTrackHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackHistory
     */
    omit?: UserTrackHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTrackHistory.
     */
    data: XOR<UserTrackHistoryUpdateInput, UserTrackHistoryUncheckedUpdateInput>
    /**
     * Choose, which UserTrackHistory to update.
     */
    where: UserTrackHistoryWhereUniqueInput
  }

  /**
   * UserTrackHistory updateMany
   */
  export type UserTrackHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTrackHistories.
     */
    data: XOR<UserTrackHistoryUpdateManyMutationInput, UserTrackHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UserTrackHistories to update
     */
    where?: UserTrackHistoryWhereInput
    /**
     * Limit how many UserTrackHistories to update.
     */
    limit?: number
  }

  /**
   * UserTrackHistory updateManyAndReturn
   */
  export type UserTrackHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackHistory
     */
    select?: UserTrackHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackHistory
     */
    omit?: UserTrackHistoryOmit<ExtArgs> | null
    /**
     * The data used to update UserTrackHistories.
     */
    data: XOR<UserTrackHistoryUpdateManyMutationInput, UserTrackHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UserTrackHistories to update
     */
    where?: UserTrackHistoryWhereInput
    /**
     * Limit how many UserTrackHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTrackHistory upsert
   */
  export type UserTrackHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackHistory
     */
    select?: UserTrackHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackHistory
     */
    omit?: UserTrackHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTrackHistory to update in case it exists.
     */
    where: UserTrackHistoryWhereUniqueInput
    /**
     * In case the UserTrackHistory found by the `where` argument doesn't exist, create a new UserTrackHistory with this data.
     */
    create: XOR<UserTrackHistoryCreateInput, UserTrackHistoryUncheckedCreateInput>
    /**
     * In case the UserTrackHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTrackHistoryUpdateInput, UserTrackHistoryUncheckedUpdateInput>
  }

  /**
   * UserTrackHistory delete
   */
  export type UserTrackHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackHistory
     */
    select?: UserTrackHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackHistory
     */
    omit?: UserTrackHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackHistoryInclude<ExtArgs> | null
    /**
     * Filter which UserTrackHistory to delete.
     */
    where: UserTrackHistoryWhereUniqueInput
  }

  /**
   * UserTrackHistory deleteMany
   */
  export type UserTrackHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTrackHistories to delete
     */
    where?: UserTrackHistoryWhereInput
    /**
     * Limit how many UserTrackHistories to delete.
     */
    limit?: number
  }

  /**
   * UserTrackHistory without action
   */
  export type UserTrackHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackHistory
     */
    select?: UserTrackHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackHistory
     */
    omit?: UserTrackHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackHistoryInclude<ExtArgs> | null
  }


  /**
   * Model UserAlbumLike
   */

  export type AggregateUserAlbumLike = {
    _count: UserAlbumLikeCountAggregateOutputType | null
    _avg: UserAlbumLikeAvgAggregateOutputType | null
    _sum: UserAlbumLikeSumAggregateOutputType | null
    _min: UserAlbumLikeMinAggregateOutputType | null
    _max: UserAlbumLikeMaxAggregateOutputType | null
  }

  export type UserAlbumLikeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    albumId: number | null
  }

  export type UserAlbumLikeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    albumId: number | null
  }

  export type UserAlbumLikeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    albumId: number | null
    createdAt: Date | null
  }

  export type UserAlbumLikeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    albumId: number | null
    createdAt: Date | null
  }

  export type UserAlbumLikeCountAggregateOutputType = {
    id: number
    userId: number
    albumId: number
    createdAt: number
    _all: number
  }


  export type UserAlbumLikeAvgAggregateInputType = {
    id?: true
    userId?: true
    albumId?: true
  }

  export type UserAlbumLikeSumAggregateInputType = {
    id?: true
    userId?: true
    albumId?: true
  }

  export type UserAlbumLikeMinAggregateInputType = {
    id?: true
    userId?: true
    albumId?: true
    createdAt?: true
  }

  export type UserAlbumLikeMaxAggregateInputType = {
    id?: true
    userId?: true
    albumId?: true
    createdAt?: true
  }

  export type UserAlbumLikeCountAggregateInputType = {
    id?: true
    userId?: true
    albumId?: true
    createdAt?: true
    _all?: true
  }

  export type UserAlbumLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAlbumLike to aggregate.
     */
    where?: UserAlbumLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAlbumLikes to fetch.
     */
    orderBy?: UserAlbumLikeOrderByWithRelationInput | UserAlbumLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAlbumLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAlbumLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAlbumLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAlbumLikes
    **/
    _count?: true | UserAlbumLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAlbumLikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAlbumLikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAlbumLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAlbumLikeMaxAggregateInputType
  }

  export type GetUserAlbumLikeAggregateType<T extends UserAlbumLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAlbumLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAlbumLike[P]>
      : GetScalarType<T[P], AggregateUserAlbumLike[P]>
  }




  export type UserAlbumLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAlbumLikeWhereInput
    orderBy?: UserAlbumLikeOrderByWithAggregationInput | UserAlbumLikeOrderByWithAggregationInput[]
    by: UserAlbumLikeScalarFieldEnum[] | UserAlbumLikeScalarFieldEnum
    having?: UserAlbumLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAlbumLikeCountAggregateInputType | true
    _avg?: UserAlbumLikeAvgAggregateInputType
    _sum?: UserAlbumLikeSumAggregateInputType
    _min?: UserAlbumLikeMinAggregateInputType
    _max?: UserAlbumLikeMaxAggregateInputType
  }

  export type UserAlbumLikeGroupByOutputType = {
    id: number
    userId: number
    albumId: number
    createdAt: Date
    _count: UserAlbumLikeCountAggregateOutputType | null
    _avg: UserAlbumLikeAvgAggregateOutputType | null
    _sum: UserAlbumLikeSumAggregateOutputType | null
    _min: UserAlbumLikeMinAggregateOutputType | null
    _max: UserAlbumLikeMaxAggregateOutputType | null
  }

  type GetUserAlbumLikeGroupByPayload<T extends UserAlbumLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAlbumLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAlbumLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAlbumLikeGroupByOutputType[P]>
            : GetScalarType<T[P], UserAlbumLikeGroupByOutputType[P]>
        }
      >
    >


  export type UserAlbumLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    albumId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAlbumLike"]>

  export type UserAlbumLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    albumId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAlbumLike"]>

  export type UserAlbumLikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    albumId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAlbumLike"]>

  export type UserAlbumLikeSelectScalar = {
    id?: boolean
    userId?: boolean
    albumId?: boolean
    createdAt?: boolean
  }

  export type UserAlbumLikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "albumId" | "createdAt", ExtArgs["result"]["userAlbumLike"]>
  export type UserAlbumLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }
  export type UserAlbumLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }
  export type UserAlbumLikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }

  export type $UserAlbumLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAlbumLike"
    objects: {
      /**
       * 外键：关联用户
       */
      user: Prisma.$UserPayload<ExtArgs>
      /**
       * 外键：关联专辑
       */
      album: Prisma.$AlbumPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * 主键 ID，自增
       */
      id: number
      userId: number
      albumId: number
      /**
       * 用户点赞该专辑的时间
       */
      createdAt: Date
    }, ExtArgs["result"]["userAlbumLike"]>
    composites: {}
  }

  type UserAlbumLikeGetPayload<S extends boolean | null | undefined | UserAlbumLikeDefaultArgs> = $Result.GetResult<Prisma.$UserAlbumLikePayload, S>

  type UserAlbumLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAlbumLikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAlbumLikeCountAggregateInputType | true
    }

  export interface UserAlbumLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAlbumLike'], meta: { name: 'UserAlbumLike' } }
    /**
     * Find zero or one UserAlbumLike that matches the filter.
     * @param {UserAlbumLikeFindUniqueArgs} args - Arguments to find a UserAlbumLike
     * @example
     * // Get one UserAlbumLike
     * const userAlbumLike = await prisma.userAlbumLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAlbumLikeFindUniqueArgs>(args: SelectSubset<T, UserAlbumLikeFindUniqueArgs<ExtArgs>>): Prisma__UserAlbumLikeClient<$Result.GetResult<Prisma.$UserAlbumLikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAlbumLike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAlbumLikeFindUniqueOrThrowArgs} args - Arguments to find a UserAlbumLike
     * @example
     * // Get one UserAlbumLike
     * const userAlbumLike = await prisma.userAlbumLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAlbumLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAlbumLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAlbumLikeClient<$Result.GetResult<Prisma.$UserAlbumLikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAlbumLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlbumLikeFindFirstArgs} args - Arguments to find a UserAlbumLike
     * @example
     * // Get one UserAlbumLike
     * const userAlbumLike = await prisma.userAlbumLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAlbumLikeFindFirstArgs>(args?: SelectSubset<T, UserAlbumLikeFindFirstArgs<ExtArgs>>): Prisma__UserAlbumLikeClient<$Result.GetResult<Prisma.$UserAlbumLikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAlbumLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlbumLikeFindFirstOrThrowArgs} args - Arguments to find a UserAlbumLike
     * @example
     * // Get one UserAlbumLike
     * const userAlbumLike = await prisma.userAlbumLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAlbumLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAlbumLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAlbumLikeClient<$Result.GetResult<Prisma.$UserAlbumLikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAlbumLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlbumLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAlbumLikes
     * const userAlbumLikes = await prisma.userAlbumLike.findMany()
     * 
     * // Get first 10 UserAlbumLikes
     * const userAlbumLikes = await prisma.userAlbumLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAlbumLikeWithIdOnly = await prisma.userAlbumLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAlbumLikeFindManyArgs>(args?: SelectSubset<T, UserAlbumLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlbumLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAlbumLike.
     * @param {UserAlbumLikeCreateArgs} args - Arguments to create a UserAlbumLike.
     * @example
     * // Create one UserAlbumLike
     * const UserAlbumLike = await prisma.userAlbumLike.create({
     *   data: {
     *     // ... data to create a UserAlbumLike
     *   }
     * })
     * 
     */
    create<T extends UserAlbumLikeCreateArgs>(args: SelectSubset<T, UserAlbumLikeCreateArgs<ExtArgs>>): Prisma__UserAlbumLikeClient<$Result.GetResult<Prisma.$UserAlbumLikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAlbumLikes.
     * @param {UserAlbumLikeCreateManyArgs} args - Arguments to create many UserAlbumLikes.
     * @example
     * // Create many UserAlbumLikes
     * const userAlbumLike = await prisma.userAlbumLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAlbumLikeCreateManyArgs>(args?: SelectSubset<T, UserAlbumLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAlbumLikes and returns the data saved in the database.
     * @param {UserAlbumLikeCreateManyAndReturnArgs} args - Arguments to create many UserAlbumLikes.
     * @example
     * // Create many UserAlbumLikes
     * const userAlbumLike = await prisma.userAlbumLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAlbumLikes and only return the `id`
     * const userAlbumLikeWithIdOnly = await prisma.userAlbumLike.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAlbumLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAlbumLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlbumLikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAlbumLike.
     * @param {UserAlbumLikeDeleteArgs} args - Arguments to delete one UserAlbumLike.
     * @example
     * // Delete one UserAlbumLike
     * const UserAlbumLike = await prisma.userAlbumLike.delete({
     *   where: {
     *     // ... filter to delete one UserAlbumLike
     *   }
     * })
     * 
     */
    delete<T extends UserAlbumLikeDeleteArgs>(args: SelectSubset<T, UserAlbumLikeDeleteArgs<ExtArgs>>): Prisma__UserAlbumLikeClient<$Result.GetResult<Prisma.$UserAlbumLikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAlbumLike.
     * @param {UserAlbumLikeUpdateArgs} args - Arguments to update one UserAlbumLike.
     * @example
     * // Update one UserAlbumLike
     * const userAlbumLike = await prisma.userAlbumLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAlbumLikeUpdateArgs>(args: SelectSubset<T, UserAlbumLikeUpdateArgs<ExtArgs>>): Prisma__UserAlbumLikeClient<$Result.GetResult<Prisma.$UserAlbumLikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAlbumLikes.
     * @param {UserAlbumLikeDeleteManyArgs} args - Arguments to filter UserAlbumLikes to delete.
     * @example
     * // Delete a few UserAlbumLikes
     * const { count } = await prisma.userAlbumLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAlbumLikeDeleteManyArgs>(args?: SelectSubset<T, UserAlbumLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAlbumLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlbumLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAlbumLikes
     * const userAlbumLike = await prisma.userAlbumLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAlbumLikeUpdateManyArgs>(args: SelectSubset<T, UserAlbumLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAlbumLikes and returns the data updated in the database.
     * @param {UserAlbumLikeUpdateManyAndReturnArgs} args - Arguments to update many UserAlbumLikes.
     * @example
     * // Update many UserAlbumLikes
     * const userAlbumLike = await prisma.userAlbumLike.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAlbumLikes and only return the `id`
     * const userAlbumLikeWithIdOnly = await prisma.userAlbumLike.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAlbumLikeUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAlbumLikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlbumLikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAlbumLike.
     * @param {UserAlbumLikeUpsertArgs} args - Arguments to update or create a UserAlbumLike.
     * @example
     * // Update or create a UserAlbumLike
     * const userAlbumLike = await prisma.userAlbumLike.upsert({
     *   create: {
     *     // ... data to create a UserAlbumLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAlbumLike we want to update
     *   }
     * })
     */
    upsert<T extends UserAlbumLikeUpsertArgs>(args: SelectSubset<T, UserAlbumLikeUpsertArgs<ExtArgs>>): Prisma__UserAlbumLikeClient<$Result.GetResult<Prisma.$UserAlbumLikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAlbumLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlbumLikeCountArgs} args - Arguments to filter UserAlbumLikes to count.
     * @example
     * // Count the number of UserAlbumLikes
     * const count = await prisma.userAlbumLike.count({
     *   where: {
     *     // ... the filter for the UserAlbumLikes we want to count
     *   }
     * })
    **/
    count<T extends UserAlbumLikeCountArgs>(
      args?: Subset<T, UserAlbumLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAlbumLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAlbumLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlbumLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAlbumLikeAggregateArgs>(args: Subset<T, UserAlbumLikeAggregateArgs>): Prisma.PrismaPromise<GetUserAlbumLikeAggregateType<T>>

    /**
     * Group by UserAlbumLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlbumLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAlbumLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAlbumLikeGroupByArgs['orderBy'] }
        : { orderBy?: UserAlbumLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAlbumLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAlbumLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAlbumLike model
   */
  readonly fields: UserAlbumLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAlbumLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAlbumLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    album<T extends AlbumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlbumDefaultArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAlbumLike model
   */
  interface UserAlbumLikeFieldRefs {
    readonly id: FieldRef<"UserAlbumLike", 'Int'>
    readonly userId: FieldRef<"UserAlbumLike", 'Int'>
    readonly albumId: FieldRef<"UserAlbumLike", 'Int'>
    readonly createdAt: FieldRef<"UserAlbumLike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAlbumLike findUnique
   */
  export type UserAlbumLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumLike
     */
    select?: UserAlbumLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumLike
     */
    omit?: UserAlbumLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumLikeInclude<ExtArgs> | null
    /**
     * Filter, which UserAlbumLike to fetch.
     */
    where: UserAlbumLikeWhereUniqueInput
  }

  /**
   * UserAlbumLike findUniqueOrThrow
   */
  export type UserAlbumLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumLike
     */
    select?: UserAlbumLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumLike
     */
    omit?: UserAlbumLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumLikeInclude<ExtArgs> | null
    /**
     * Filter, which UserAlbumLike to fetch.
     */
    where: UserAlbumLikeWhereUniqueInput
  }

  /**
   * UserAlbumLike findFirst
   */
  export type UserAlbumLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumLike
     */
    select?: UserAlbumLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumLike
     */
    omit?: UserAlbumLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumLikeInclude<ExtArgs> | null
    /**
     * Filter, which UserAlbumLike to fetch.
     */
    where?: UserAlbumLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAlbumLikes to fetch.
     */
    orderBy?: UserAlbumLikeOrderByWithRelationInput | UserAlbumLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAlbumLikes.
     */
    cursor?: UserAlbumLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAlbumLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAlbumLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAlbumLikes.
     */
    distinct?: UserAlbumLikeScalarFieldEnum | UserAlbumLikeScalarFieldEnum[]
  }

  /**
   * UserAlbumLike findFirstOrThrow
   */
  export type UserAlbumLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumLike
     */
    select?: UserAlbumLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumLike
     */
    omit?: UserAlbumLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumLikeInclude<ExtArgs> | null
    /**
     * Filter, which UserAlbumLike to fetch.
     */
    where?: UserAlbumLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAlbumLikes to fetch.
     */
    orderBy?: UserAlbumLikeOrderByWithRelationInput | UserAlbumLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAlbumLikes.
     */
    cursor?: UserAlbumLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAlbumLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAlbumLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAlbumLikes.
     */
    distinct?: UserAlbumLikeScalarFieldEnum | UserAlbumLikeScalarFieldEnum[]
  }

  /**
   * UserAlbumLike findMany
   */
  export type UserAlbumLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumLike
     */
    select?: UserAlbumLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumLike
     */
    omit?: UserAlbumLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumLikeInclude<ExtArgs> | null
    /**
     * Filter, which UserAlbumLikes to fetch.
     */
    where?: UserAlbumLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAlbumLikes to fetch.
     */
    orderBy?: UserAlbumLikeOrderByWithRelationInput | UserAlbumLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAlbumLikes.
     */
    cursor?: UserAlbumLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAlbumLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAlbumLikes.
     */
    skip?: number
    distinct?: UserAlbumLikeScalarFieldEnum | UserAlbumLikeScalarFieldEnum[]
  }

  /**
   * UserAlbumLike create
   */
  export type UserAlbumLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumLike
     */
    select?: UserAlbumLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumLike
     */
    omit?: UserAlbumLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAlbumLike.
     */
    data: XOR<UserAlbumLikeCreateInput, UserAlbumLikeUncheckedCreateInput>
  }

  /**
   * UserAlbumLike createMany
   */
  export type UserAlbumLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAlbumLikes.
     */
    data: UserAlbumLikeCreateManyInput | UserAlbumLikeCreateManyInput[]
  }

  /**
   * UserAlbumLike createManyAndReturn
   */
  export type UserAlbumLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumLike
     */
    select?: UserAlbumLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumLike
     */
    omit?: UserAlbumLikeOmit<ExtArgs> | null
    /**
     * The data used to create many UserAlbumLikes.
     */
    data: UserAlbumLikeCreateManyInput | UserAlbumLikeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAlbumLike update
   */
  export type UserAlbumLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumLike
     */
    select?: UserAlbumLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumLike
     */
    omit?: UserAlbumLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAlbumLike.
     */
    data: XOR<UserAlbumLikeUpdateInput, UserAlbumLikeUncheckedUpdateInput>
    /**
     * Choose, which UserAlbumLike to update.
     */
    where: UserAlbumLikeWhereUniqueInput
  }

  /**
   * UserAlbumLike updateMany
   */
  export type UserAlbumLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAlbumLikes.
     */
    data: XOR<UserAlbumLikeUpdateManyMutationInput, UserAlbumLikeUncheckedUpdateManyInput>
    /**
     * Filter which UserAlbumLikes to update
     */
    where?: UserAlbumLikeWhereInput
    /**
     * Limit how many UserAlbumLikes to update.
     */
    limit?: number
  }

  /**
   * UserAlbumLike updateManyAndReturn
   */
  export type UserAlbumLikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumLike
     */
    select?: UserAlbumLikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumLike
     */
    omit?: UserAlbumLikeOmit<ExtArgs> | null
    /**
     * The data used to update UserAlbumLikes.
     */
    data: XOR<UserAlbumLikeUpdateManyMutationInput, UserAlbumLikeUncheckedUpdateManyInput>
    /**
     * Filter which UserAlbumLikes to update
     */
    where?: UserAlbumLikeWhereInput
    /**
     * Limit how many UserAlbumLikes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumLikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAlbumLike upsert
   */
  export type UserAlbumLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumLike
     */
    select?: UserAlbumLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumLike
     */
    omit?: UserAlbumLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAlbumLike to update in case it exists.
     */
    where: UserAlbumLikeWhereUniqueInput
    /**
     * In case the UserAlbumLike found by the `where` argument doesn't exist, create a new UserAlbumLike with this data.
     */
    create: XOR<UserAlbumLikeCreateInput, UserAlbumLikeUncheckedCreateInput>
    /**
     * In case the UserAlbumLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAlbumLikeUpdateInput, UserAlbumLikeUncheckedUpdateInput>
  }

  /**
   * UserAlbumLike delete
   */
  export type UserAlbumLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumLike
     */
    select?: UserAlbumLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumLike
     */
    omit?: UserAlbumLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumLikeInclude<ExtArgs> | null
    /**
     * Filter which UserAlbumLike to delete.
     */
    where: UserAlbumLikeWhereUniqueInput
  }

  /**
   * UserAlbumLike deleteMany
   */
  export type UserAlbumLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAlbumLikes to delete
     */
    where?: UserAlbumLikeWhereInput
    /**
     * Limit how many UserAlbumLikes to delete.
     */
    limit?: number
  }

  /**
   * UserAlbumLike without action
   */
  export type UserAlbumLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumLike
     */
    select?: UserAlbumLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumLike
     */
    omit?: UserAlbumLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumLikeInclude<ExtArgs> | null
  }


  /**
   * Model UserAlbumHistory
   */

  export type AggregateUserAlbumHistory = {
    _count: UserAlbumHistoryCountAggregateOutputType | null
    _avg: UserAlbumHistoryAvgAggregateOutputType | null
    _sum: UserAlbumHistorySumAggregateOutputType | null
    _min: UserAlbumHistoryMinAggregateOutputType | null
    _max: UserAlbumHistoryMaxAggregateOutputType | null
  }

  export type UserAlbumHistoryAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    albumId: number | null
  }

  export type UserAlbumHistorySumAggregateOutputType = {
    id: number | null
    userId: number | null
    albumId: number | null
  }

  export type UserAlbumHistoryMinAggregateOutputType = {
    id: number | null
    userId: number | null
    albumId: number | null
    listenedAt: Date | null
  }

  export type UserAlbumHistoryMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    albumId: number | null
    listenedAt: Date | null
  }

  export type UserAlbumHistoryCountAggregateOutputType = {
    id: number
    userId: number
    albumId: number
    listenedAt: number
    _all: number
  }


  export type UserAlbumHistoryAvgAggregateInputType = {
    id?: true
    userId?: true
    albumId?: true
  }

  export type UserAlbumHistorySumAggregateInputType = {
    id?: true
    userId?: true
    albumId?: true
  }

  export type UserAlbumHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    albumId?: true
    listenedAt?: true
  }

  export type UserAlbumHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    albumId?: true
    listenedAt?: true
  }

  export type UserAlbumHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    albumId?: true
    listenedAt?: true
    _all?: true
  }

  export type UserAlbumHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAlbumHistory to aggregate.
     */
    where?: UserAlbumHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAlbumHistories to fetch.
     */
    orderBy?: UserAlbumHistoryOrderByWithRelationInput | UserAlbumHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAlbumHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAlbumHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAlbumHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAlbumHistories
    **/
    _count?: true | UserAlbumHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAlbumHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAlbumHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAlbumHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAlbumHistoryMaxAggregateInputType
  }

  export type GetUserAlbumHistoryAggregateType<T extends UserAlbumHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAlbumHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAlbumHistory[P]>
      : GetScalarType<T[P], AggregateUserAlbumHistory[P]>
  }




  export type UserAlbumHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAlbumHistoryWhereInput
    orderBy?: UserAlbumHistoryOrderByWithAggregationInput | UserAlbumHistoryOrderByWithAggregationInput[]
    by: UserAlbumHistoryScalarFieldEnum[] | UserAlbumHistoryScalarFieldEnum
    having?: UserAlbumHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAlbumHistoryCountAggregateInputType | true
    _avg?: UserAlbumHistoryAvgAggregateInputType
    _sum?: UserAlbumHistorySumAggregateInputType
    _min?: UserAlbumHistoryMinAggregateInputType
    _max?: UserAlbumHistoryMaxAggregateInputType
  }

  export type UserAlbumHistoryGroupByOutputType = {
    id: number
    userId: number
    albumId: number
    listenedAt: Date
    _count: UserAlbumHistoryCountAggregateOutputType | null
    _avg: UserAlbumHistoryAvgAggregateOutputType | null
    _sum: UserAlbumHistorySumAggregateOutputType | null
    _min: UserAlbumHistoryMinAggregateOutputType | null
    _max: UserAlbumHistoryMaxAggregateOutputType | null
  }

  type GetUserAlbumHistoryGroupByPayload<T extends UserAlbumHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAlbumHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAlbumHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAlbumHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], UserAlbumHistoryGroupByOutputType[P]>
        }
      >
    >


  export type UserAlbumHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    albumId?: boolean
    listenedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAlbumHistory"]>

  export type UserAlbumHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    albumId?: boolean
    listenedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAlbumHistory"]>

  export type UserAlbumHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    albumId?: boolean
    listenedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAlbumHistory"]>

  export type UserAlbumHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    albumId?: boolean
    listenedAt?: boolean
  }

  export type UserAlbumHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "albumId" | "listenedAt", ExtArgs["result"]["userAlbumHistory"]>
  export type UserAlbumHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }
  export type UserAlbumHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }
  export type UserAlbumHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }

  export type $UserAlbumHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAlbumHistory"
    objects: {
      /**
       * 外键：关联用户
       */
      user: Prisma.$UserPayload<ExtArgs>
      /**
       * 外键：关联专辑
       */
      album: Prisma.$AlbumPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * 主键 ID，自增
       */
      id: number
      userId: number
      albumId: number
      /**
       * 用户收听该专辑的时间
       */
      listenedAt: Date
    }, ExtArgs["result"]["userAlbumHistory"]>
    composites: {}
  }

  type UserAlbumHistoryGetPayload<S extends boolean | null | undefined | UserAlbumHistoryDefaultArgs> = $Result.GetResult<Prisma.$UserAlbumHistoryPayload, S>

  type UserAlbumHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAlbumHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAlbumHistoryCountAggregateInputType | true
    }

  export interface UserAlbumHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAlbumHistory'], meta: { name: 'UserAlbumHistory' } }
    /**
     * Find zero or one UserAlbumHistory that matches the filter.
     * @param {UserAlbumHistoryFindUniqueArgs} args - Arguments to find a UserAlbumHistory
     * @example
     * // Get one UserAlbumHistory
     * const userAlbumHistory = await prisma.userAlbumHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAlbumHistoryFindUniqueArgs>(args: SelectSubset<T, UserAlbumHistoryFindUniqueArgs<ExtArgs>>): Prisma__UserAlbumHistoryClient<$Result.GetResult<Prisma.$UserAlbumHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAlbumHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAlbumHistoryFindUniqueOrThrowArgs} args - Arguments to find a UserAlbumHistory
     * @example
     * // Get one UserAlbumHistory
     * const userAlbumHistory = await prisma.userAlbumHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAlbumHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAlbumHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAlbumHistoryClient<$Result.GetResult<Prisma.$UserAlbumHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAlbumHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlbumHistoryFindFirstArgs} args - Arguments to find a UserAlbumHistory
     * @example
     * // Get one UserAlbumHistory
     * const userAlbumHistory = await prisma.userAlbumHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAlbumHistoryFindFirstArgs>(args?: SelectSubset<T, UserAlbumHistoryFindFirstArgs<ExtArgs>>): Prisma__UserAlbumHistoryClient<$Result.GetResult<Prisma.$UserAlbumHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAlbumHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlbumHistoryFindFirstOrThrowArgs} args - Arguments to find a UserAlbumHistory
     * @example
     * // Get one UserAlbumHistory
     * const userAlbumHistory = await prisma.userAlbumHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAlbumHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAlbumHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAlbumHistoryClient<$Result.GetResult<Prisma.$UserAlbumHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAlbumHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlbumHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAlbumHistories
     * const userAlbumHistories = await prisma.userAlbumHistory.findMany()
     * 
     * // Get first 10 UserAlbumHistories
     * const userAlbumHistories = await prisma.userAlbumHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAlbumHistoryWithIdOnly = await prisma.userAlbumHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAlbumHistoryFindManyArgs>(args?: SelectSubset<T, UserAlbumHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlbumHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAlbumHistory.
     * @param {UserAlbumHistoryCreateArgs} args - Arguments to create a UserAlbumHistory.
     * @example
     * // Create one UserAlbumHistory
     * const UserAlbumHistory = await prisma.userAlbumHistory.create({
     *   data: {
     *     // ... data to create a UserAlbumHistory
     *   }
     * })
     * 
     */
    create<T extends UserAlbumHistoryCreateArgs>(args: SelectSubset<T, UserAlbumHistoryCreateArgs<ExtArgs>>): Prisma__UserAlbumHistoryClient<$Result.GetResult<Prisma.$UserAlbumHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAlbumHistories.
     * @param {UserAlbumHistoryCreateManyArgs} args - Arguments to create many UserAlbumHistories.
     * @example
     * // Create many UserAlbumHistories
     * const userAlbumHistory = await prisma.userAlbumHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAlbumHistoryCreateManyArgs>(args?: SelectSubset<T, UserAlbumHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAlbumHistories and returns the data saved in the database.
     * @param {UserAlbumHistoryCreateManyAndReturnArgs} args - Arguments to create many UserAlbumHistories.
     * @example
     * // Create many UserAlbumHistories
     * const userAlbumHistory = await prisma.userAlbumHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAlbumHistories and only return the `id`
     * const userAlbumHistoryWithIdOnly = await prisma.userAlbumHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAlbumHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAlbumHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlbumHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAlbumHistory.
     * @param {UserAlbumHistoryDeleteArgs} args - Arguments to delete one UserAlbumHistory.
     * @example
     * // Delete one UserAlbumHistory
     * const UserAlbumHistory = await prisma.userAlbumHistory.delete({
     *   where: {
     *     // ... filter to delete one UserAlbumHistory
     *   }
     * })
     * 
     */
    delete<T extends UserAlbumHistoryDeleteArgs>(args: SelectSubset<T, UserAlbumHistoryDeleteArgs<ExtArgs>>): Prisma__UserAlbumHistoryClient<$Result.GetResult<Prisma.$UserAlbumHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAlbumHistory.
     * @param {UserAlbumHistoryUpdateArgs} args - Arguments to update one UserAlbumHistory.
     * @example
     * // Update one UserAlbumHistory
     * const userAlbumHistory = await prisma.userAlbumHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAlbumHistoryUpdateArgs>(args: SelectSubset<T, UserAlbumHistoryUpdateArgs<ExtArgs>>): Prisma__UserAlbumHistoryClient<$Result.GetResult<Prisma.$UserAlbumHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAlbumHistories.
     * @param {UserAlbumHistoryDeleteManyArgs} args - Arguments to filter UserAlbumHistories to delete.
     * @example
     * // Delete a few UserAlbumHistories
     * const { count } = await prisma.userAlbumHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAlbumHistoryDeleteManyArgs>(args?: SelectSubset<T, UserAlbumHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAlbumHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlbumHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAlbumHistories
     * const userAlbumHistory = await prisma.userAlbumHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAlbumHistoryUpdateManyArgs>(args: SelectSubset<T, UserAlbumHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAlbumHistories and returns the data updated in the database.
     * @param {UserAlbumHistoryUpdateManyAndReturnArgs} args - Arguments to update many UserAlbumHistories.
     * @example
     * // Update many UserAlbumHistories
     * const userAlbumHistory = await prisma.userAlbumHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAlbumHistories and only return the `id`
     * const userAlbumHistoryWithIdOnly = await prisma.userAlbumHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAlbumHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAlbumHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlbumHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAlbumHistory.
     * @param {UserAlbumHistoryUpsertArgs} args - Arguments to update or create a UserAlbumHistory.
     * @example
     * // Update or create a UserAlbumHistory
     * const userAlbumHistory = await prisma.userAlbumHistory.upsert({
     *   create: {
     *     // ... data to create a UserAlbumHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAlbumHistory we want to update
     *   }
     * })
     */
    upsert<T extends UserAlbumHistoryUpsertArgs>(args: SelectSubset<T, UserAlbumHistoryUpsertArgs<ExtArgs>>): Prisma__UserAlbumHistoryClient<$Result.GetResult<Prisma.$UserAlbumHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAlbumHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlbumHistoryCountArgs} args - Arguments to filter UserAlbumHistories to count.
     * @example
     * // Count the number of UserAlbumHistories
     * const count = await prisma.userAlbumHistory.count({
     *   where: {
     *     // ... the filter for the UserAlbumHistories we want to count
     *   }
     * })
    **/
    count<T extends UserAlbumHistoryCountArgs>(
      args?: Subset<T, UserAlbumHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAlbumHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAlbumHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlbumHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAlbumHistoryAggregateArgs>(args: Subset<T, UserAlbumHistoryAggregateArgs>): Prisma.PrismaPromise<GetUserAlbumHistoryAggregateType<T>>

    /**
     * Group by UserAlbumHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlbumHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAlbumHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAlbumHistoryGroupByArgs['orderBy'] }
        : { orderBy?: UserAlbumHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAlbumHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAlbumHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAlbumHistory model
   */
  readonly fields: UserAlbumHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAlbumHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAlbumHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    album<T extends AlbumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlbumDefaultArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAlbumHistory model
   */
  interface UserAlbumHistoryFieldRefs {
    readonly id: FieldRef<"UserAlbumHistory", 'Int'>
    readonly userId: FieldRef<"UserAlbumHistory", 'Int'>
    readonly albumId: FieldRef<"UserAlbumHistory", 'Int'>
    readonly listenedAt: FieldRef<"UserAlbumHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAlbumHistory findUnique
   */
  export type UserAlbumHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumHistory
     */
    select?: UserAlbumHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumHistory
     */
    omit?: UserAlbumHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserAlbumHistory to fetch.
     */
    where: UserAlbumHistoryWhereUniqueInput
  }

  /**
   * UserAlbumHistory findUniqueOrThrow
   */
  export type UserAlbumHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumHistory
     */
    select?: UserAlbumHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumHistory
     */
    omit?: UserAlbumHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserAlbumHistory to fetch.
     */
    where: UserAlbumHistoryWhereUniqueInput
  }

  /**
   * UserAlbumHistory findFirst
   */
  export type UserAlbumHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumHistory
     */
    select?: UserAlbumHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumHistory
     */
    omit?: UserAlbumHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserAlbumHistory to fetch.
     */
    where?: UserAlbumHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAlbumHistories to fetch.
     */
    orderBy?: UserAlbumHistoryOrderByWithRelationInput | UserAlbumHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAlbumHistories.
     */
    cursor?: UserAlbumHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAlbumHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAlbumHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAlbumHistories.
     */
    distinct?: UserAlbumHistoryScalarFieldEnum | UserAlbumHistoryScalarFieldEnum[]
  }

  /**
   * UserAlbumHistory findFirstOrThrow
   */
  export type UserAlbumHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumHistory
     */
    select?: UserAlbumHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumHistory
     */
    omit?: UserAlbumHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserAlbumHistory to fetch.
     */
    where?: UserAlbumHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAlbumHistories to fetch.
     */
    orderBy?: UserAlbumHistoryOrderByWithRelationInput | UserAlbumHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAlbumHistories.
     */
    cursor?: UserAlbumHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAlbumHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAlbumHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAlbumHistories.
     */
    distinct?: UserAlbumHistoryScalarFieldEnum | UserAlbumHistoryScalarFieldEnum[]
  }

  /**
   * UserAlbumHistory findMany
   */
  export type UserAlbumHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumHistory
     */
    select?: UserAlbumHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumHistory
     */
    omit?: UserAlbumHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserAlbumHistories to fetch.
     */
    where?: UserAlbumHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAlbumHistories to fetch.
     */
    orderBy?: UserAlbumHistoryOrderByWithRelationInput | UserAlbumHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAlbumHistories.
     */
    cursor?: UserAlbumHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAlbumHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAlbumHistories.
     */
    skip?: number
    distinct?: UserAlbumHistoryScalarFieldEnum | UserAlbumHistoryScalarFieldEnum[]
  }

  /**
   * UserAlbumHistory create
   */
  export type UserAlbumHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumHistory
     */
    select?: UserAlbumHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumHistory
     */
    omit?: UserAlbumHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAlbumHistory.
     */
    data: XOR<UserAlbumHistoryCreateInput, UserAlbumHistoryUncheckedCreateInput>
  }

  /**
   * UserAlbumHistory createMany
   */
  export type UserAlbumHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAlbumHistories.
     */
    data: UserAlbumHistoryCreateManyInput | UserAlbumHistoryCreateManyInput[]
  }

  /**
   * UserAlbumHistory createManyAndReturn
   */
  export type UserAlbumHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumHistory
     */
    select?: UserAlbumHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumHistory
     */
    omit?: UserAlbumHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many UserAlbumHistories.
     */
    data: UserAlbumHistoryCreateManyInput | UserAlbumHistoryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAlbumHistory update
   */
  export type UserAlbumHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumHistory
     */
    select?: UserAlbumHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumHistory
     */
    omit?: UserAlbumHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAlbumHistory.
     */
    data: XOR<UserAlbumHistoryUpdateInput, UserAlbumHistoryUncheckedUpdateInput>
    /**
     * Choose, which UserAlbumHistory to update.
     */
    where: UserAlbumHistoryWhereUniqueInput
  }

  /**
   * UserAlbumHistory updateMany
   */
  export type UserAlbumHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAlbumHistories.
     */
    data: XOR<UserAlbumHistoryUpdateManyMutationInput, UserAlbumHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UserAlbumHistories to update
     */
    where?: UserAlbumHistoryWhereInput
    /**
     * Limit how many UserAlbumHistories to update.
     */
    limit?: number
  }

  /**
   * UserAlbumHistory updateManyAndReturn
   */
  export type UserAlbumHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumHistory
     */
    select?: UserAlbumHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumHistory
     */
    omit?: UserAlbumHistoryOmit<ExtArgs> | null
    /**
     * The data used to update UserAlbumHistories.
     */
    data: XOR<UserAlbumHistoryUpdateManyMutationInput, UserAlbumHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UserAlbumHistories to update
     */
    where?: UserAlbumHistoryWhereInput
    /**
     * Limit how many UserAlbumHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAlbumHistory upsert
   */
  export type UserAlbumHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumHistory
     */
    select?: UserAlbumHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumHistory
     */
    omit?: UserAlbumHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAlbumHistory to update in case it exists.
     */
    where: UserAlbumHistoryWhereUniqueInput
    /**
     * In case the UserAlbumHistory found by the `where` argument doesn't exist, create a new UserAlbumHistory with this data.
     */
    create: XOR<UserAlbumHistoryCreateInput, UserAlbumHistoryUncheckedCreateInput>
    /**
     * In case the UserAlbumHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAlbumHistoryUpdateInput, UserAlbumHistoryUncheckedUpdateInput>
  }

  /**
   * UserAlbumHistory delete
   */
  export type UserAlbumHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumHistory
     */
    select?: UserAlbumHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumHistory
     */
    omit?: UserAlbumHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumHistoryInclude<ExtArgs> | null
    /**
     * Filter which UserAlbumHistory to delete.
     */
    where: UserAlbumHistoryWhereUniqueInput
  }

  /**
   * UserAlbumHistory deleteMany
   */
  export type UserAlbumHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAlbumHistories to delete
     */
    where?: UserAlbumHistoryWhereInput
    /**
     * Limit how many UserAlbumHistories to delete.
     */
    limit?: number
  }

  /**
   * UserAlbumHistory without action
   */
  export type UserAlbumHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumHistory
     */
    select?: UserAlbumHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumHistory
     */
    omit?: UserAlbumHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumHistoryInclude<ExtArgs> | null
  }


  /**
   * Model UserAudiobookLike
   */

  export type AggregateUserAudiobookLike = {
    _count: UserAudiobookLikeCountAggregateOutputType | null
    _avg: UserAudiobookLikeAvgAggregateOutputType | null
    _sum: UserAudiobookLikeSumAggregateOutputType | null
    _min: UserAudiobookLikeMinAggregateOutputType | null
    _max: UserAudiobookLikeMaxAggregateOutputType | null
  }

  export type UserAudiobookLikeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    trackId: number | null
  }

  export type UserAudiobookLikeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    trackId: number | null
  }

  export type UserAudiobookLikeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    trackId: number | null
    createdAt: Date | null
  }

  export type UserAudiobookLikeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    trackId: number | null
    createdAt: Date | null
  }

  export type UserAudiobookLikeCountAggregateOutputType = {
    id: number
    userId: number
    trackId: number
    createdAt: number
    _all: number
  }


  export type UserAudiobookLikeAvgAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
  }

  export type UserAudiobookLikeSumAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
  }

  export type UserAudiobookLikeMinAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
    createdAt?: true
  }

  export type UserAudiobookLikeMaxAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
    createdAt?: true
  }

  export type UserAudiobookLikeCountAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
    createdAt?: true
    _all?: true
  }

  export type UserAudiobookLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAudiobookLike to aggregate.
     */
    where?: UserAudiobookLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAudiobookLikes to fetch.
     */
    orderBy?: UserAudiobookLikeOrderByWithRelationInput | UserAudiobookLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAudiobookLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAudiobookLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAudiobookLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAudiobookLikes
    **/
    _count?: true | UserAudiobookLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAudiobookLikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAudiobookLikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAudiobookLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAudiobookLikeMaxAggregateInputType
  }

  export type GetUserAudiobookLikeAggregateType<T extends UserAudiobookLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAudiobookLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAudiobookLike[P]>
      : GetScalarType<T[P], AggregateUserAudiobookLike[P]>
  }




  export type UserAudiobookLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAudiobookLikeWhereInput
    orderBy?: UserAudiobookLikeOrderByWithAggregationInput | UserAudiobookLikeOrderByWithAggregationInput[]
    by: UserAudiobookLikeScalarFieldEnum[] | UserAudiobookLikeScalarFieldEnum
    having?: UserAudiobookLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAudiobookLikeCountAggregateInputType | true
    _avg?: UserAudiobookLikeAvgAggregateInputType
    _sum?: UserAudiobookLikeSumAggregateInputType
    _min?: UserAudiobookLikeMinAggregateInputType
    _max?: UserAudiobookLikeMaxAggregateInputType
  }

  export type UserAudiobookLikeGroupByOutputType = {
    id: number
    userId: number
    trackId: number
    createdAt: Date
    _count: UserAudiobookLikeCountAggregateOutputType | null
    _avg: UserAudiobookLikeAvgAggregateOutputType | null
    _sum: UserAudiobookLikeSumAggregateOutputType | null
    _min: UserAudiobookLikeMinAggregateOutputType | null
    _max: UserAudiobookLikeMaxAggregateOutputType | null
  }

  type GetUserAudiobookLikeGroupByPayload<T extends UserAudiobookLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAudiobookLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAudiobookLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAudiobookLikeGroupByOutputType[P]>
            : GetScalarType<T[P], UserAudiobookLikeGroupByOutputType[P]>
        }
      >
    >


  export type UserAudiobookLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    trackId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAudiobookLike"]>

  export type UserAudiobookLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    trackId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAudiobookLike"]>

  export type UserAudiobookLikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    trackId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAudiobookLike"]>

  export type UserAudiobookLikeSelectScalar = {
    id?: boolean
    userId?: boolean
    trackId?: boolean
    createdAt?: boolean
  }

  export type UserAudiobookLikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "trackId" | "createdAt", ExtArgs["result"]["userAudiobookLike"]>
  export type UserAudiobookLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
  }
  export type UserAudiobookLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
  }
  export type UserAudiobookLikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
  }

  export type $UserAudiobookLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAudiobookLike"
    objects: {
      /**
       * 外键：关联用户
       */
      user: Prisma.$UserPayload<ExtArgs>
      /**
       * 外键：关联有声书 Track
       */
      track: Prisma.$TrackPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * 主键 ID，自增
       */
      id: number
      userId: number
      trackId: number
      /**
       * 用户点赞该有声书的时间
       */
      createdAt: Date
    }, ExtArgs["result"]["userAudiobookLike"]>
    composites: {}
  }

  type UserAudiobookLikeGetPayload<S extends boolean | null | undefined | UserAudiobookLikeDefaultArgs> = $Result.GetResult<Prisma.$UserAudiobookLikePayload, S>

  type UserAudiobookLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAudiobookLikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAudiobookLikeCountAggregateInputType | true
    }

  export interface UserAudiobookLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAudiobookLike'], meta: { name: 'UserAudiobookLike' } }
    /**
     * Find zero or one UserAudiobookLike that matches the filter.
     * @param {UserAudiobookLikeFindUniqueArgs} args - Arguments to find a UserAudiobookLike
     * @example
     * // Get one UserAudiobookLike
     * const userAudiobookLike = await prisma.userAudiobookLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAudiobookLikeFindUniqueArgs>(args: SelectSubset<T, UserAudiobookLikeFindUniqueArgs<ExtArgs>>): Prisma__UserAudiobookLikeClient<$Result.GetResult<Prisma.$UserAudiobookLikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAudiobookLike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAudiobookLikeFindUniqueOrThrowArgs} args - Arguments to find a UserAudiobookLike
     * @example
     * // Get one UserAudiobookLike
     * const userAudiobookLike = await prisma.userAudiobookLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAudiobookLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAudiobookLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAudiobookLikeClient<$Result.GetResult<Prisma.$UserAudiobookLikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAudiobookLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAudiobookLikeFindFirstArgs} args - Arguments to find a UserAudiobookLike
     * @example
     * // Get one UserAudiobookLike
     * const userAudiobookLike = await prisma.userAudiobookLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAudiobookLikeFindFirstArgs>(args?: SelectSubset<T, UserAudiobookLikeFindFirstArgs<ExtArgs>>): Prisma__UserAudiobookLikeClient<$Result.GetResult<Prisma.$UserAudiobookLikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAudiobookLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAudiobookLikeFindFirstOrThrowArgs} args - Arguments to find a UserAudiobookLike
     * @example
     * // Get one UserAudiobookLike
     * const userAudiobookLike = await prisma.userAudiobookLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAudiobookLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAudiobookLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAudiobookLikeClient<$Result.GetResult<Prisma.$UserAudiobookLikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAudiobookLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAudiobookLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAudiobookLikes
     * const userAudiobookLikes = await prisma.userAudiobookLike.findMany()
     * 
     * // Get first 10 UserAudiobookLikes
     * const userAudiobookLikes = await prisma.userAudiobookLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAudiobookLikeWithIdOnly = await prisma.userAudiobookLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAudiobookLikeFindManyArgs>(args?: SelectSubset<T, UserAudiobookLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAudiobookLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAudiobookLike.
     * @param {UserAudiobookLikeCreateArgs} args - Arguments to create a UserAudiobookLike.
     * @example
     * // Create one UserAudiobookLike
     * const UserAudiobookLike = await prisma.userAudiobookLike.create({
     *   data: {
     *     // ... data to create a UserAudiobookLike
     *   }
     * })
     * 
     */
    create<T extends UserAudiobookLikeCreateArgs>(args: SelectSubset<T, UserAudiobookLikeCreateArgs<ExtArgs>>): Prisma__UserAudiobookLikeClient<$Result.GetResult<Prisma.$UserAudiobookLikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAudiobookLikes.
     * @param {UserAudiobookLikeCreateManyArgs} args - Arguments to create many UserAudiobookLikes.
     * @example
     * // Create many UserAudiobookLikes
     * const userAudiobookLike = await prisma.userAudiobookLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAudiobookLikeCreateManyArgs>(args?: SelectSubset<T, UserAudiobookLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAudiobookLikes and returns the data saved in the database.
     * @param {UserAudiobookLikeCreateManyAndReturnArgs} args - Arguments to create many UserAudiobookLikes.
     * @example
     * // Create many UserAudiobookLikes
     * const userAudiobookLike = await prisma.userAudiobookLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAudiobookLikes and only return the `id`
     * const userAudiobookLikeWithIdOnly = await prisma.userAudiobookLike.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAudiobookLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAudiobookLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAudiobookLikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAudiobookLike.
     * @param {UserAudiobookLikeDeleteArgs} args - Arguments to delete one UserAudiobookLike.
     * @example
     * // Delete one UserAudiobookLike
     * const UserAudiobookLike = await prisma.userAudiobookLike.delete({
     *   where: {
     *     // ... filter to delete one UserAudiobookLike
     *   }
     * })
     * 
     */
    delete<T extends UserAudiobookLikeDeleteArgs>(args: SelectSubset<T, UserAudiobookLikeDeleteArgs<ExtArgs>>): Prisma__UserAudiobookLikeClient<$Result.GetResult<Prisma.$UserAudiobookLikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAudiobookLike.
     * @param {UserAudiobookLikeUpdateArgs} args - Arguments to update one UserAudiobookLike.
     * @example
     * // Update one UserAudiobookLike
     * const userAudiobookLike = await prisma.userAudiobookLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAudiobookLikeUpdateArgs>(args: SelectSubset<T, UserAudiobookLikeUpdateArgs<ExtArgs>>): Prisma__UserAudiobookLikeClient<$Result.GetResult<Prisma.$UserAudiobookLikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAudiobookLikes.
     * @param {UserAudiobookLikeDeleteManyArgs} args - Arguments to filter UserAudiobookLikes to delete.
     * @example
     * // Delete a few UserAudiobookLikes
     * const { count } = await prisma.userAudiobookLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAudiobookLikeDeleteManyArgs>(args?: SelectSubset<T, UserAudiobookLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAudiobookLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAudiobookLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAudiobookLikes
     * const userAudiobookLike = await prisma.userAudiobookLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAudiobookLikeUpdateManyArgs>(args: SelectSubset<T, UserAudiobookLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAudiobookLikes and returns the data updated in the database.
     * @param {UserAudiobookLikeUpdateManyAndReturnArgs} args - Arguments to update many UserAudiobookLikes.
     * @example
     * // Update many UserAudiobookLikes
     * const userAudiobookLike = await prisma.userAudiobookLike.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAudiobookLikes and only return the `id`
     * const userAudiobookLikeWithIdOnly = await prisma.userAudiobookLike.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAudiobookLikeUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAudiobookLikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAudiobookLikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAudiobookLike.
     * @param {UserAudiobookLikeUpsertArgs} args - Arguments to update or create a UserAudiobookLike.
     * @example
     * // Update or create a UserAudiobookLike
     * const userAudiobookLike = await prisma.userAudiobookLike.upsert({
     *   create: {
     *     // ... data to create a UserAudiobookLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAudiobookLike we want to update
     *   }
     * })
     */
    upsert<T extends UserAudiobookLikeUpsertArgs>(args: SelectSubset<T, UserAudiobookLikeUpsertArgs<ExtArgs>>): Prisma__UserAudiobookLikeClient<$Result.GetResult<Prisma.$UserAudiobookLikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAudiobookLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAudiobookLikeCountArgs} args - Arguments to filter UserAudiobookLikes to count.
     * @example
     * // Count the number of UserAudiobookLikes
     * const count = await prisma.userAudiobookLike.count({
     *   where: {
     *     // ... the filter for the UserAudiobookLikes we want to count
     *   }
     * })
    **/
    count<T extends UserAudiobookLikeCountArgs>(
      args?: Subset<T, UserAudiobookLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAudiobookLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAudiobookLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAudiobookLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAudiobookLikeAggregateArgs>(args: Subset<T, UserAudiobookLikeAggregateArgs>): Prisma.PrismaPromise<GetUserAudiobookLikeAggregateType<T>>

    /**
     * Group by UserAudiobookLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAudiobookLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAudiobookLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAudiobookLikeGroupByArgs['orderBy'] }
        : { orderBy?: UserAudiobookLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAudiobookLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAudiobookLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAudiobookLike model
   */
  readonly fields: UserAudiobookLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAudiobookLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAudiobookLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    track<T extends TrackDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrackDefaultArgs<ExtArgs>>): Prisma__TrackClient<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAudiobookLike model
   */
  interface UserAudiobookLikeFieldRefs {
    readonly id: FieldRef<"UserAudiobookLike", 'Int'>
    readonly userId: FieldRef<"UserAudiobookLike", 'Int'>
    readonly trackId: FieldRef<"UserAudiobookLike", 'Int'>
    readonly createdAt: FieldRef<"UserAudiobookLike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAudiobookLike findUnique
   */
  export type UserAudiobookLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookLike
     */
    select?: UserAudiobookLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookLike
     */
    omit?: UserAudiobookLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookLikeInclude<ExtArgs> | null
    /**
     * Filter, which UserAudiobookLike to fetch.
     */
    where: UserAudiobookLikeWhereUniqueInput
  }

  /**
   * UserAudiobookLike findUniqueOrThrow
   */
  export type UserAudiobookLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookLike
     */
    select?: UserAudiobookLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookLike
     */
    omit?: UserAudiobookLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookLikeInclude<ExtArgs> | null
    /**
     * Filter, which UserAudiobookLike to fetch.
     */
    where: UserAudiobookLikeWhereUniqueInput
  }

  /**
   * UserAudiobookLike findFirst
   */
  export type UserAudiobookLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookLike
     */
    select?: UserAudiobookLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookLike
     */
    omit?: UserAudiobookLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookLikeInclude<ExtArgs> | null
    /**
     * Filter, which UserAudiobookLike to fetch.
     */
    where?: UserAudiobookLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAudiobookLikes to fetch.
     */
    orderBy?: UserAudiobookLikeOrderByWithRelationInput | UserAudiobookLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAudiobookLikes.
     */
    cursor?: UserAudiobookLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAudiobookLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAudiobookLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAudiobookLikes.
     */
    distinct?: UserAudiobookLikeScalarFieldEnum | UserAudiobookLikeScalarFieldEnum[]
  }

  /**
   * UserAudiobookLike findFirstOrThrow
   */
  export type UserAudiobookLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookLike
     */
    select?: UserAudiobookLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookLike
     */
    omit?: UserAudiobookLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookLikeInclude<ExtArgs> | null
    /**
     * Filter, which UserAudiobookLike to fetch.
     */
    where?: UserAudiobookLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAudiobookLikes to fetch.
     */
    orderBy?: UserAudiobookLikeOrderByWithRelationInput | UserAudiobookLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAudiobookLikes.
     */
    cursor?: UserAudiobookLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAudiobookLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAudiobookLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAudiobookLikes.
     */
    distinct?: UserAudiobookLikeScalarFieldEnum | UserAudiobookLikeScalarFieldEnum[]
  }

  /**
   * UserAudiobookLike findMany
   */
  export type UserAudiobookLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookLike
     */
    select?: UserAudiobookLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookLike
     */
    omit?: UserAudiobookLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookLikeInclude<ExtArgs> | null
    /**
     * Filter, which UserAudiobookLikes to fetch.
     */
    where?: UserAudiobookLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAudiobookLikes to fetch.
     */
    orderBy?: UserAudiobookLikeOrderByWithRelationInput | UserAudiobookLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAudiobookLikes.
     */
    cursor?: UserAudiobookLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAudiobookLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAudiobookLikes.
     */
    skip?: number
    distinct?: UserAudiobookLikeScalarFieldEnum | UserAudiobookLikeScalarFieldEnum[]
  }

  /**
   * UserAudiobookLike create
   */
  export type UserAudiobookLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookLike
     */
    select?: UserAudiobookLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookLike
     */
    omit?: UserAudiobookLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAudiobookLike.
     */
    data: XOR<UserAudiobookLikeCreateInput, UserAudiobookLikeUncheckedCreateInput>
  }

  /**
   * UserAudiobookLike createMany
   */
  export type UserAudiobookLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAudiobookLikes.
     */
    data: UserAudiobookLikeCreateManyInput | UserAudiobookLikeCreateManyInput[]
  }

  /**
   * UserAudiobookLike createManyAndReturn
   */
  export type UserAudiobookLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookLike
     */
    select?: UserAudiobookLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookLike
     */
    omit?: UserAudiobookLikeOmit<ExtArgs> | null
    /**
     * The data used to create many UserAudiobookLikes.
     */
    data: UserAudiobookLikeCreateManyInput | UserAudiobookLikeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAudiobookLike update
   */
  export type UserAudiobookLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookLike
     */
    select?: UserAudiobookLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookLike
     */
    omit?: UserAudiobookLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAudiobookLike.
     */
    data: XOR<UserAudiobookLikeUpdateInput, UserAudiobookLikeUncheckedUpdateInput>
    /**
     * Choose, which UserAudiobookLike to update.
     */
    where: UserAudiobookLikeWhereUniqueInput
  }

  /**
   * UserAudiobookLike updateMany
   */
  export type UserAudiobookLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAudiobookLikes.
     */
    data: XOR<UserAudiobookLikeUpdateManyMutationInput, UserAudiobookLikeUncheckedUpdateManyInput>
    /**
     * Filter which UserAudiobookLikes to update
     */
    where?: UserAudiobookLikeWhereInput
    /**
     * Limit how many UserAudiobookLikes to update.
     */
    limit?: number
  }

  /**
   * UserAudiobookLike updateManyAndReturn
   */
  export type UserAudiobookLikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookLike
     */
    select?: UserAudiobookLikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookLike
     */
    omit?: UserAudiobookLikeOmit<ExtArgs> | null
    /**
     * The data used to update UserAudiobookLikes.
     */
    data: XOR<UserAudiobookLikeUpdateManyMutationInput, UserAudiobookLikeUncheckedUpdateManyInput>
    /**
     * Filter which UserAudiobookLikes to update
     */
    where?: UserAudiobookLikeWhereInput
    /**
     * Limit how many UserAudiobookLikes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookLikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAudiobookLike upsert
   */
  export type UserAudiobookLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookLike
     */
    select?: UserAudiobookLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookLike
     */
    omit?: UserAudiobookLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAudiobookLike to update in case it exists.
     */
    where: UserAudiobookLikeWhereUniqueInput
    /**
     * In case the UserAudiobookLike found by the `where` argument doesn't exist, create a new UserAudiobookLike with this data.
     */
    create: XOR<UserAudiobookLikeCreateInput, UserAudiobookLikeUncheckedCreateInput>
    /**
     * In case the UserAudiobookLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAudiobookLikeUpdateInput, UserAudiobookLikeUncheckedUpdateInput>
  }

  /**
   * UserAudiobookLike delete
   */
  export type UserAudiobookLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookLike
     */
    select?: UserAudiobookLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookLike
     */
    omit?: UserAudiobookLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookLikeInclude<ExtArgs> | null
    /**
     * Filter which UserAudiobookLike to delete.
     */
    where: UserAudiobookLikeWhereUniqueInput
  }

  /**
   * UserAudiobookLike deleteMany
   */
  export type UserAudiobookLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAudiobookLikes to delete
     */
    where?: UserAudiobookLikeWhereInput
    /**
     * Limit how many UserAudiobookLikes to delete.
     */
    limit?: number
  }

  /**
   * UserAudiobookLike without action
   */
  export type UserAudiobookLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookLike
     */
    select?: UserAudiobookLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookLike
     */
    omit?: UserAudiobookLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookLikeInclude<ExtArgs> | null
  }


  /**
   * Model UserAudiobookHistory
   */

  export type AggregateUserAudiobookHistory = {
    _count: UserAudiobookHistoryCountAggregateOutputType | null
    _avg: UserAudiobookHistoryAvgAggregateOutputType | null
    _sum: UserAudiobookHistorySumAggregateOutputType | null
    _min: UserAudiobookHistoryMinAggregateOutputType | null
    _max: UserAudiobookHistoryMaxAggregateOutputType | null
  }

  export type UserAudiobookHistoryAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    trackId: number | null
    progress: number | null
  }

  export type UserAudiobookHistorySumAggregateOutputType = {
    id: number | null
    userId: number | null
    trackId: number | null
    progress: number | null
  }

  export type UserAudiobookHistoryMinAggregateOutputType = {
    id: number | null
    userId: number | null
    trackId: number | null
    listenedAt: Date | null
    progress: number | null
  }

  export type UserAudiobookHistoryMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    trackId: number | null
    listenedAt: Date | null
    progress: number | null
  }

  export type UserAudiobookHistoryCountAggregateOutputType = {
    id: number
    userId: number
    trackId: number
    listenedAt: number
    progress: number
    _all: number
  }


  export type UserAudiobookHistoryAvgAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
    progress?: true
  }

  export type UserAudiobookHistorySumAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
    progress?: true
  }

  export type UserAudiobookHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
    listenedAt?: true
    progress?: true
  }

  export type UserAudiobookHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
    listenedAt?: true
    progress?: true
  }

  export type UserAudiobookHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    trackId?: true
    listenedAt?: true
    progress?: true
    _all?: true
  }

  export type UserAudiobookHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAudiobookHistory to aggregate.
     */
    where?: UserAudiobookHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAudiobookHistories to fetch.
     */
    orderBy?: UserAudiobookHistoryOrderByWithRelationInput | UserAudiobookHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAudiobookHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAudiobookHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAudiobookHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAudiobookHistories
    **/
    _count?: true | UserAudiobookHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAudiobookHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAudiobookHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAudiobookHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAudiobookHistoryMaxAggregateInputType
  }

  export type GetUserAudiobookHistoryAggregateType<T extends UserAudiobookHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAudiobookHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAudiobookHistory[P]>
      : GetScalarType<T[P], AggregateUserAudiobookHistory[P]>
  }




  export type UserAudiobookHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAudiobookHistoryWhereInput
    orderBy?: UserAudiobookHistoryOrderByWithAggregationInput | UserAudiobookHistoryOrderByWithAggregationInput[]
    by: UserAudiobookHistoryScalarFieldEnum[] | UserAudiobookHistoryScalarFieldEnum
    having?: UserAudiobookHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAudiobookHistoryCountAggregateInputType | true
    _avg?: UserAudiobookHistoryAvgAggregateInputType
    _sum?: UserAudiobookHistorySumAggregateInputType
    _min?: UserAudiobookHistoryMinAggregateInputType
    _max?: UserAudiobookHistoryMaxAggregateInputType
  }

  export type UserAudiobookHistoryGroupByOutputType = {
    id: number
    userId: number
    trackId: number
    listenedAt: Date
    progress: number
    _count: UserAudiobookHistoryCountAggregateOutputType | null
    _avg: UserAudiobookHistoryAvgAggregateOutputType | null
    _sum: UserAudiobookHistorySumAggregateOutputType | null
    _min: UserAudiobookHistoryMinAggregateOutputType | null
    _max: UserAudiobookHistoryMaxAggregateOutputType | null
  }

  type GetUserAudiobookHistoryGroupByPayload<T extends UserAudiobookHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAudiobookHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAudiobookHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAudiobookHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], UserAudiobookHistoryGroupByOutputType[P]>
        }
      >
    >


  export type UserAudiobookHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    trackId?: boolean
    listenedAt?: boolean
    progress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAudiobookHistory"]>

  export type UserAudiobookHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    trackId?: boolean
    listenedAt?: boolean
    progress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAudiobookHistory"]>

  export type UserAudiobookHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    trackId?: boolean
    listenedAt?: boolean
    progress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAudiobookHistory"]>

  export type UserAudiobookHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    trackId?: boolean
    listenedAt?: boolean
    progress?: boolean
  }

  export type UserAudiobookHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "trackId" | "listenedAt" | "progress", ExtArgs["result"]["userAudiobookHistory"]>
  export type UserAudiobookHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
  }
  export type UserAudiobookHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
  }
  export type UserAudiobookHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    track?: boolean | TrackDefaultArgs<ExtArgs>
  }

  export type $UserAudiobookHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAudiobookHistory"
    objects: {
      /**
       * 外键：关联用户
       */
      user: Prisma.$UserPayload<ExtArgs>
      /**
       * 外键：关联有声书 Track
       */
      track: Prisma.$TrackPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * 主键 ID，自增
       */
      id: number
      userId: number
      trackId: number
      /**
       * 用户收听该有声书的时间
       */
      listenedAt: Date
      progress: number
    }, ExtArgs["result"]["userAudiobookHistory"]>
    composites: {}
  }

  type UserAudiobookHistoryGetPayload<S extends boolean | null | undefined | UserAudiobookHistoryDefaultArgs> = $Result.GetResult<Prisma.$UserAudiobookHistoryPayload, S>

  type UserAudiobookHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAudiobookHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAudiobookHistoryCountAggregateInputType | true
    }

  export interface UserAudiobookHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAudiobookHistory'], meta: { name: 'UserAudiobookHistory' } }
    /**
     * Find zero or one UserAudiobookHistory that matches the filter.
     * @param {UserAudiobookHistoryFindUniqueArgs} args - Arguments to find a UserAudiobookHistory
     * @example
     * // Get one UserAudiobookHistory
     * const userAudiobookHistory = await prisma.userAudiobookHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAudiobookHistoryFindUniqueArgs>(args: SelectSubset<T, UserAudiobookHistoryFindUniqueArgs<ExtArgs>>): Prisma__UserAudiobookHistoryClient<$Result.GetResult<Prisma.$UserAudiobookHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAudiobookHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAudiobookHistoryFindUniqueOrThrowArgs} args - Arguments to find a UserAudiobookHistory
     * @example
     * // Get one UserAudiobookHistory
     * const userAudiobookHistory = await prisma.userAudiobookHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAudiobookHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAudiobookHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAudiobookHistoryClient<$Result.GetResult<Prisma.$UserAudiobookHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAudiobookHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAudiobookHistoryFindFirstArgs} args - Arguments to find a UserAudiobookHistory
     * @example
     * // Get one UserAudiobookHistory
     * const userAudiobookHistory = await prisma.userAudiobookHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAudiobookHistoryFindFirstArgs>(args?: SelectSubset<T, UserAudiobookHistoryFindFirstArgs<ExtArgs>>): Prisma__UserAudiobookHistoryClient<$Result.GetResult<Prisma.$UserAudiobookHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAudiobookHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAudiobookHistoryFindFirstOrThrowArgs} args - Arguments to find a UserAudiobookHistory
     * @example
     * // Get one UserAudiobookHistory
     * const userAudiobookHistory = await prisma.userAudiobookHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAudiobookHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAudiobookHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAudiobookHistoryClient<$Result.GetResult<Prisma.$UserAudiobookHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAudiobookHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAudiobookHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAudiobookHistories
     * const userAudiobookHistories = await prisma.userAudiobookHistory.findMany()
     * 
     * // Get first 10 UserAudiobookHistories
     * const userAudiobookHistories = await prisma.userAudiobookHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAudiobookHistoryWithIdOnly = await prisma.userAudiobookHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAudiobookHistoryFindManyArgs>(args?: SelectSubset<T, UserAudiobookHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAudiobookHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAudiobookHistory.
     * @param {UserAudiobookHistoryCreateArgs} args - Arguments to create a UserAudiobookHistory.
     * @example
     * // Create one UserAudiobookHistory
     * const UserAudiobookHistory = await prisma.userAudiobookHistory.create({
     *   data: {
     *     // ... data to create a UserAudiobookHistory
     *   }
     * })
     * 
     */
    create<T extends UserAudiobookHistoryCreateArgs>(args: SelectSubset<T, UserAudiobookHistoryCreateArgs<ExtArgs>>): Prisma__UserAudiobookHistoryClient<$Result.GetResult<Prisma.$UserAudiobookHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAudiobookHistories.
     * @param {UserAudiobookHistoryCreateManyArgs} args - Arguments to create many UserAudiobookHistories.
     * @example
     * // Create many UserAudiobookHistories
     * const userAudiobookHistory = await prisma.userAudiobookHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAudiobookHistoryCreateManyArgs>(args?: SelectSubset<T, UserAudiobookHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAudiobookHistories and returns the data saved in the database.
     * @param {UserAudiobookHistoryCreateManyAndReturnArgs} args - Arguments to create many UserAudiobookHistories.
     * @example
     * // Create many UserAudiobookHistories
     * const userAudiobookHistory = await prisma.userAudiobookHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAudiobookHistories and only return the `id`
     * const userAudiobookHistoryWithIdOnly = await prisma.userAudiobookHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAudiobookHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAudiobookHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAudiobookHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAudiobookHistory.
     * @param {UserAudiobookHistoryDeleteArgs} args - Arguments to delete one UserAudiobookHistory.
     * @example
     * // Delete one UserAudiobookHistory
     * const UserAudiobookHistory = await prisma.userAudiobookHistory.delete({
     *   where: {
     *     // ... filter to delete one UserAudiobookHistory
     *   }
     * })
     * 
     */
    delete<T extends UserAudiobookHistoryDeleteArgs>(args: SelectSubset<T, UserAudiobookHistoryDeleteArgs<ExtArgs>>): Prisma__UserAudiobookHistoryClient<$Result.GetResult<Prisma.$UserAudiobookHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAudiobookHistory.
     * @param {UserAudiobookHistoryUpdateArgs} args - Arguments to update one UserAudiobookHistory.
     * @example
     * // Update one UserAudiobookHistory
     * const userAudiobookHistory = await prisma.userAudiobookHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAudiobookHistoryUpdateArgs>(args: SelectSubset<T, UserAudiobookHistoryUpdateArgs<ExtArgs>>): Prisma__UserAudiobookHistoryClient<$Result.GetResult<Prisma.$UserAudiobookHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAudiobookHistories.
     * @param {UserAudiobookHistoryDeleteManyArgs} args - Arguments to filter UserAudiobookHistories to delete.
     * @example
     * // Delete a few UserAudiobookHistories
     * const { count } = await prisma.userAudiobookHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAudiobookHistoryDeleteManyArgs>(args?: SelectSubset<T, UserAudiobookHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAudiobookHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAudiobookHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAudiobookHistories
     * const userAudiobookHistory = await prisma.userAudiobookHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAudiobookHistoryUpdateManyArgs>(args: SelectSubset<T, UserAudiobookHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAudiobookHistories and returns the data updated in the database.
     * @param {UserAudiobookHistoryUpdateManyAndReturnArgs} args - Arguments to update many UserAudiobookHistories.
     * @example
     * // Update many UserAudiobookHistories
     * const userAudiobookHistory = await prisma.userAudiobookHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAudiobookHistories and only return the `id`
     * const userAudiobookHistoryWithIdOnly = await prisma.userAudiobookHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAudiobookHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAudiobookHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAudiobookHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAudiobookHistory.
     * @param {UserAudiobookHistoryUpsertArgs} args - Arguments to update or create a UserAudiobookHistory.
     * @example
     * // Update or create a UserAudiobookHistory
     * const userAudiobookHistory = await prisma.userAudiobookHistory.upsert({
     *   create: {
     *     // ... data to create a UserAudiobookHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAudiobookHistory we want to update
     *   }
     * })
     */
    upsert<T extends UserAudiobookHistoryUpsertArgs>(args: SelectSubset<T, UserAudiobookHistoryUpsertArgs<ExtArgs>>): Prisma__UserAudiobookHistoryClient<$Result.GetResult<Prisma.$UserAudiobookHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAudiobookHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAudiobookHistoryCountArgs} args - Arguments to filter UserAudiobookHistories to count.
     * @example
     * // Count the number of UserAudiobookHistories
     * const count = await prisma.userAudiobookHistory.count({
     *   where: {
     *     // ... the filter for the UserAudiobookHistories we want to count
     *   }
     * })
    **/
    count<T extends UserAudiobookHistoryCountArgs>(
      args?: Subset<T, UserAudiobookHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAudiobookHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAudiobookHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAudiobookHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAudiobookHistoryAggregateArgs>(args: Subset<T, UserAudiobookHistoryAggregateArgs>): Prisma.PrismaPromise<GetUserAudiobookHistoryAggregateType<T>>

    /**
     * Group by UserAudiobookHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAudiobookHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAudiobookHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAudiobookHistoryGroupByArgs['orderBy'] }
        : { orderBy?: UserAudiobookHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAudiobookHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAudiobookHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAudiobookHistory model
   */
  readonly fields: UserAudiobookHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAudiobookHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAudiobookHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    track<T extends TrackDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrackDefaultArgs<ExtArgs>>): Prisma__TrackClient<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAudiobookHistory model
   */
  interface UserAudiobookHistoryFieldRefs {
    readonly id: FieldRef<"UserAudiobookHistory", 'Int'>
    readonly userId: FieldRef<"UserAudiobookHistory", 'Int'>
    readonly trackId: FieldRef<"UserAudiobookHistory", 'Int'>
    readonly listenedAt: FieldRef<"UserAudiobookHistory", 'DateTime'>
    readonly progress: FieldRef<"UserAudiobookHistory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserAudiobookHistory findUnique
   */
  export type UserAudiobookHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookHistory
     */
    select?: UserAudiobookHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookHistory
     */
    omit?: UserAudiobookHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserAudiobookHistory to fetch.
     */
    where: UserAudiobookHistoryWhereUniqueInput
  }

  /**
   * UserAudiobookHistory findUniqueOrThrow
   */
  export type UserAudiobookHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookHistory
     */
    select?: UserAudiobookHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookHistory
     */
    omit?: UserAudiobookHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserAudiobookHistory to fetch.
     */
    where: UserAudiobookHistoryWhereUniqueInput
  }

  /**
   * UserAudiobookHistory findFirst
   */
  export type UserAudiobookHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookHistory
     */
    select?: UserAudiobookHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookHistory
     */
    omit?: UserAudiobookHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserAudiobookHistory to fetch.
     */
    where?: UserAudiobookHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAudiobookHistories to fetch.
     */
    orderBy?: UserAudiobookHistoryOrderByWithRelationInput | UserAudiobookHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAudiobookHistories.
     */
    cursor?: UserAudiobookHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAudiobookHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAudiobookHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAudiobookHistories.
     */
    distinct?: UserAudiobookHistoryScalarFieldEnum | UserAudiobookHistoryScalarFieldEnum[]
  }

  /**
   * UserAudiobookHistory findFirstOrThrow
   */
  export type UserAudiobookHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookHistory
     */
    select?: UserAudiobookHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookHistory
     */
    omit?: UserAudiobookHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserAudiobookHistory to fetch.
     */
    where?: UserAudiobookHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAudiobookHistories to fetch.
     */
    orderBy?: UserAudiobookHistoryOrderByWithRelationInput | UserAudiobookHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAudiobookHistories.
     */
    cursor?: UserAudiobookHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAudiobookHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAudiobookHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAudiobookHistories.
     */
    distinct?: UserAudiobookHistoryScalarFieldEnum | UserAudiobookHistoryScalarFieldEnum[]
  }

  /**
   * UserAudiobookHistory findMany
   */
  export type UserAudiobookHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookHistory
     */
    select?: UserAudiobookHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookHistory
     */
    omit?: UserAudiobookHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserAudiobookHistories to fetch.
     */
    where?: UserAudiobookHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAudiobookHistories to fetch.
     */
    orderBy?: UserAudiobookHistoryOrderByWithRelationInput | UserAudiobookHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAudiobookHistories.
     */
    cursor?: UserAudiobookHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAudiobookHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAudiobookHistories.
     */
    skip?: number
    distinct?: UserAudiobookHistoryScalarFieldEnum | UserAudiobookHistoryScalarFieldEnum[]
  }

  /**
   * UserAudiobookHistory create
   */
  export type UserAudiobookHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookHistory
     */
    select?: UserAudiobookHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookHistory
     */
    omit?: UserAudiobookHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAudiobookHistory.
     */
    data: XOR<UserAudiobookHistoryCreateInput, UserAudiobookHistoryUncheckedCreateInput>
  }

  /**
   * UserAudiobookHistory createMany
   */
  export type UserAudiobookHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAudiobookHistories.
     */
    data: UserAudiobookHistoryCreateManyInput | UserAudiobookHistoryCreateManyInput[]
  }

  /**
   * UserAudiobookHistory createManyAndReturn
   */
  export type UserAudiobookHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookHistory
     */
    select?: UserAudiobookHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookHistory
     */
    omit?: UserAudiobookHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many UserAudiobookHistories.
     */
    data: UserAudiobookHistoryCreateManyInput | UserAudiobookHistoryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAudiobookHistory update
   */
  export type UserAudiobookHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookHistory
     */
    select?: UserAudiobookHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookHistory
     */
    omit?: UserAudiobookHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAudiobookHistory.
     */
    data: XOR<UserAudiobookHistoryUpdateInput, UserAudiobookHistoryUncheckedUpdateInput>
    /**
     * Choose, which UserAudiobookHistory to update.
     */
    where: UserAudiobookHistoryWhereUniqueInput
  }

  /**
   * UserAudiobookHistory updateMany
   */
  export type UserAudiobookHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAudiobookHistories.
     */
    data: XOR<UserAudiobookHistoryUpdateManyMutationInput, UserAudiobookHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UserAudiobookHistories to update
     */
    where?: UserAudiobookHistoryWhereInput
    /**
     * Limit how many UserAudiobookHistories to update.
     */
    limit?: number
  }

  /**
   * UserAudiobookHistory updateManyAndReturn
   */
  export type UserAudiobookHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookHistory
     */
    select?: UserAudiobookHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookHistory
     */
    omit?: UserAudiobookHistoryOmit<ExtArgs> | null
    /**
     * The data used to update UserAudiobookHistories.
     */
    data: XOR<UserAudiobookHistoryUpdateManyMutationInput, UserAudiobookHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UserAudiobookHistories to update
     */
    where?: UserAudiobookHistoryWhereInput
    /**
     * Limit how many UserAudiobookHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAudiobookHistory upsert
   */
  export type UserAudiobookHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookHistory
     */
    select?: UserAudiobookHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookHistory
     */
    omit?: UserAudiobookHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAudiobookHistory to update in case it exists.
     */
    where: UserAudiobookHistoryWhereUniqueInput
    /**
     * In case the UserAudiobookHistory found by the `where` argument doesn't exist, create a new UserAudiobookHistory with this data.
     */
    create: XOR<UserAudiobookHistoryCreateInput, UserAudiobookHistoryUncheckedCreateInput>
    /**
     * In case the UserAudiobookHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAudiobookHistoryUpdateInput, UserAudiobookHistoryUncheckedUpdateInput>
  }

  /**
   * UserAudiobookHistory delete
   */
  export type UserAudiobookHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookHistory
     */
    select?: UserAudiobookHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookHistory
     */
    omit?: UserAudiobookHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookHistoryInclude<ExtArgs> | null
    /**
     * Filter which UserAudiobookHistory to delete.
     */
    where: UserAudiobookHistoryWhereUniqueInput
  }

  /**
   * UserAudiobookHistory deleteMany
   */
  export type UserAudiobookHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAudiobookHistories to delete
     */
    where?: UserAudiobookHistoryWhereInput
    /**
     * Limit how many UserAudiobookHistories to delete.
     */
    limit?: number
  }

  /**
   * UserAudiobookHistory without action
   */
  export type UserAudiobookHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookHistory
     */
    select?: UserAudiobookHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookHistory
     */
    omit?: UserAudiobookHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookHistoryInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    is_admin: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    is_admin: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    is_admin: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    is_admin?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    is_admin?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    is_admin?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    is_admin: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    is_admin?: boolean
    likedTracks?: boolean | User$likedTracksArgs<ExtArgs>
    listenedTracks?: boolean | User$listenedTracksArgs<ExtArgs>
    likedAlbums?: boolean | User$likedAlbumsArgs<ExtArgs>
    listenedAlbums?: boolean | User$listenedAlbumsArgs<ExtArgs>
    likedAudiobooks?: boolean | User$likedAudiobooksArgs<ExtArgs>
    listenedAudiobooks?: boolean | User$listenedAudiobooksArgs<ExtArgs>
    playlists?: boolean | User$playlistsArgs<ExtArgs>
    devices?: boolean | User$devicesArgs<ExtArgs>
    searchRecords?: boolean | User$searchRecordsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    is_admin?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    is_admin?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    is_admin?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "is_admin", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    likedTracks?: boolean | User$likedTracksArgs<ExtArgs>
    listenedTracks?: boolean | User$listenedTracksArgs<ExtArgs>
    likedAlbums?: boolean | User$likedAlbumsArgs<ExtArgs>
    listenedAlbums?: boolean | User$listenedAlbumsArgs<ExtArgs>
    likedAudiobooks?: boolean | User$likedAudiobooksArgs<ExtArgs>
    listenedAudiobooks?: boolean | User$listenedAudiobooksArgs<ExtArgs>
    playlists?: boolean | User$playlistsArgs<ExtArgs>
    devices?: boolean | User$devicesArgs<ExtArgs>
    searchRecords?: boolean | User$searchRecordsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      /**
       * 用户喜欢的音乐单曲列表
       */
      likedTracks: Prisma.$UserTrackLikePayload<ExtArgs>[]
      /**
       * 用户听过的音乐单曲历史记录
       */
      listenedTracks: Prisma.$UserTrackHistoryPayload<ExtArgs>[]
      /**
       * 用户喜欢的专辑列表
       */
      likedAlbums: Prisma.$UserAlbumLikePayload<ExtArgs>[]
      /**
       * 用户听过的专辑历史记录
       */
      listenedAlbums: Prisma.$UserAlbumHistoryPayload<ExtArgs>[]
      /**
       * 用户喜欢的有声书列表
       */
      likedAudiobooks: Prisma.$UserAudiobookLikePayload<ExtArgs>[]
      /**
       * 用户听过的有声书历史记录
       */
      listenedAudiobooks: Prisma.$UserAudiobookHistoryPayload<ExtArgs>[]
      /**
       * 用户创建的播放列表
       */
      playlists: Prisma.$PlaylistPayload<ExtArgs>[]
      /**
       * 用户设备列表
       */
      devices: Prisma.$DevicePayload<ExtArgs>[]
      /**
       * 用户搜索记录
       */
      searchRecords: Prisma.$SearchRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * 用户 ID，自增主键
       */
      id: number
      /**
       * 用户名，唯一标识，用于登录
       */
      username: string
      /**
       * 加密后的用户密码
       */
      password: string
      /**
       * 是否为管理员用户，默认 false
       */
      is_admin: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    likedTracks<T extends User$likedTracksArgs<ExtArgs> = {}>(args?: Subset<T, User$likedTracksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTrackLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    listenedTracks<T extends User$listenedTracksArgs<ExtArgs> = {}>(args?: Subset<T, User$listenedTracksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTrackHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likedAlbums<T extends User$likedAlbumsArgs<ExtArgs> = {}>(args?: Subset<T, User$likedAlbumsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlbumLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    listenedAlbums<T extends User$listenedAlbumsArgs<ExtArgs> = {}>(args?: Subset<T, User$listenedAlbumsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlbumHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likedAudiobooks<T extends User$likedAudiobooksArgs<ExtArgs> = {}>(args?: Subset<T, User$likedAudiobooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAudiobookLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    listenedAudiobooks<T extends User$listenedAudiobooksArgs<ExtArgs> = {}>(args?: Subset<T, User$listenedAudiobooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAudiobookHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playlists<T extends User$playlistsArgs<ExtArgs> = {}>(args?: Subset<T, User$playlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    devices<T extends User$devicesArgs<ExtArgs> = {}>(args?: Subset<T, User$devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    searchRecords<T extends User$searchRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$searchRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly is_admin: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.likedTracks
   */
  export type User$likedTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackLike
     */
    select?: UserTrackLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackLike
     */
    omit?: UserTrackLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackLikeInclude<ExtArgs> | null
    where?: UserTrackLikeWhereInput
    orderBy?: UserTrackLikeOrderByWithRelationInput | UserTrackLikeOrderByWithRelationInput[]
    cursor?: UserTrackLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTrackLikeScalarFieldEnum | UserTrackLikeScalarFieldEnum[]
  }

  /**
   * User.listenedTracks
   */
  export type User$listenedTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackHistory
     */
    select?: UserTrackHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackHistory
     */
    omit?: UserTrackHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackHistoryInclude<ExtArgs> | null
    where?: UserTrackHistoryWhereInput
    orderBy?: UserTrackHistoryOrderByWithRelationInput | UserTrackHistoryOrderByWithRelationInput[]
    cursor?: UserTrackHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTrackHistoryScalarFieldEnum | UserTrackHistoryScalarFieldEnum[]
  }

  /**
   * User.likedAlbums
   */
  export type User$likedAlbumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumLike
     */
    select?: UserAlbumLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumLike
     */
    omit?: UserAlbumLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumLikeInclude<ExtArgs> | null
    where?: UserAlbumLikeWhereInput
    orderBy?: UserAlbumLikeOrderByWithRelationInput | UserAlbumLikeOrderByWithRelationInput[]
    cursor?: UserAlbumLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAlbumLikeScalarFieldEnum | UserAlbumLikeScalarFieldEnum[]
  }

  /**
   * User.listenedAlbums
   */
  export type User$listenedAlbumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlbumHistory
     */
    select?: UserAlbumHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlbumHistory
     */
    omit?: UserAlbumHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlbumHistoryInclude<ExtArgs> | null
    where?: UserAlbumHistoryWhereInput
    orderBy?: UserAlbumHistoryOrderByWithRelationInput | UserAlbumHistoryOrderByWithRelationInput[]
    cursor?: UserAlbumHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAlbumHistoryScalarFieldEnum | UserAlbumHistoryScalarFieldEnum[]
  }

  /**
   * User.likedAudiobooks
   */
  export type User$likedAudiobooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookLike
     */
    select?: UserAudiobookLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookLike
     */
    omit?: UserAudiobookLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookLikeInclude<ExtArgs> | null
    where?: UserAudiobookLikeWhereInput
    orderBy?: UserAudiobookLikeOrderByWithRelationInput | UserAudiobookLikeOrderByWithRelationInput[]
    cursor?: UserAudiobookLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAudiobookLikeScalarFieldEnum | UserAudiobookLikeScalarFieldEnum[]
  }

  /**
   * User.listenedAudiobooks
   */
  export type User$listenedAudiobooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAudiobookHistory
     */
    select?: UserAudiobookHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAudiobookHistory
     */
    omit?: UserAudiobookHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAudiobookHistoryInclude<ExtArgs> | null
    where?: UserAudiobookHistoryWhereInput
    orderBy?: UserAudiobookHistoryOrderByWithRelationInput | UserAudiobookHistoryOrderByWithRelationInput[]
    cursor?: UserAudiobookHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAudiobookHistoryScalarFieldEnum | UserAudiobookHistoryScalarFieldEnum[]
  }

  /**
   * User.playlists
   */
  export type User$playlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    where?: PlaylistWhereInput
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    cursor?: PlaylistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * User.devices
   */
  export type User$devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    cursor?: DeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * User.searchRecords
   */
  export type User$searchRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchRecord
     */
    select?: SearchRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchRecord
     */
    omit?: SearchRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchRecordInclude<ExtArgs> | null
    where?: SearchRecordWhereInput
    orderBy?: SearchRecordOrderByWithRelationInput | SearchRecordOrderByWithRelationInput[]
    cursor?: SearchRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchRecordScalarFieldEnum | SearchRecordScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model SearchRecord
   */

  export type AggregateSearchRecord = {
    _count: SearchRecordCountAggregateOutputType | null
    _avg: SearchRecordAvgAggregateOutputType | null
    _sum: SearchRecordSumAggregateOutputType | null
    _min: SearchRecordMinAggregateOutputType | null
    _max: SearchRecordMaxAggregateOutputType | null
  }

  export type SearchRecordAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SearchRecordSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SearchRecordMinAggregateOutputType = {
    id: number | null
    keyword: string | null
    createdAt: Date | null
    userId: number | null
  }

  export type SearchRecordMaxAggregateOutputType = {
    id: number | null
    keyword: string | null
    createdAt: Date | null
    userId: number | null
  }

  export type SearchRecordCountAggregateOutputType = {
    id: number
    keyword: number
    createdAt: number
    userId: number
    _all: number
  }


  export type SearchRecordAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SearchRecordSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SearchRecordMinAggregateInputType = {
    id?: true
    keyword?: true
    createdAt?: true
    userId?: true
  }

  export type SearchRecordMaxAggregateInputType = {
    id?: true
    keyword?: true
    createdAt?: true
    userId?: true
  }

  export type SearchRecordCountAggregateInputType = {
    id?: true
    keyword?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type SearchRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchRecord to aggregate.
     */
    where?: SearchRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchRecords to fetch.
     */
    orderBy?: SearchRecordOrderByWithRelationInput | SearchRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchRecords
    **/
    _count?: true | SearchRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SearchRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SearchRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchRecordMaxAggregateInputType
  }

  export type GetSearchRecordAggregateType<T extends SearchRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchRecord[P]>
      : GetScalarType<T[P], AggregateSearchRecord[P]>
  }




  export type SearchRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchRecordWhereInput
    orderBy?: SearchRecordOrderByWithAggregationInput | SearchRecordOrderByWithAggregationInput[]
    by: SearchRecordScalarFieldEnum[] | SearchRecordScalarFieldEnum
    having?: SearchRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchRecordCountAggregateInputType | true
    _avg?: SearchRecordAvgAggregateInputType
    _sum?: SearchRecordSumAggregateInputType
    _min?: SearchRecordMinAggregateInputType
    _max?: SearchRecordMaxAggregateInputType
  }

  export type SearchRecordGroupByOutputType = {
    id: number
    keyword: string
    createdAt: Date
    userId: number
    _count: SearchRecordCountAggregateOutputType | null
    _avg: SearchRecordAvgAggregateOutputType | null
    _sum: SearchRecordSumAggregateOutputType | null
    _min: SearchRecordMinAggregateOutputType | null
    _max: SearchRecordMaxAggregateOutputType | null
  }

  type GetSearchRecordGroupByPayload<T extends SearchRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchRecordGroupByOutputType[P]>
            : GetScalarType<T[P], SearchRecordGroupByOutputType[P]>
        }
      >
    >


  export type SearchRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyword?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchRecord"]>

  export type SearchRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyword?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchRecord"]>

  export type SearchRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyword?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchRecord"]>

  export type SearchRecordSelectScalar = {
    id?: boolean
    keyword?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type SearchRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "keyword" | "createdAt" | "userId", ExtArgs["result"]["searchRecord"]>
  export type SearchRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SearchRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SearchRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SearchRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchRecord"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      keyword: string
      createdAt: Date
      userId: number
    }, ExtArgs["result"]["searchRecord"]>
    composites: {}
  }

  type SearchRecordGetPayload<S extends boolean | null | undefined | SearchRecordDefaultArgs> = $Result.GetResult<Prisma.$SearchRecordPayload, S>

  type SearchRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SearchRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SearchRecordCountAggregateInputType | true
    }

  export interface SearchRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchRecord'], meta: { name: 'SearchRecord' } }
    /**
     * Find zero or one SearchRecord that matches the filter.
     * @param {SearchRecordFindUniqueArgs} args - Arguments to find a SearchRecord
     * @example
     * // Get one SearchRecord
     * const searchRecord = await prisma.searchRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchRecordFindUniqueArgs>(args: SelectSubset<T, SearchRecordFindUniqueArgs<ExtArgs>>): Prisma__SearchRecordClient<$Result.GetResult<Prisma.$SearchRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SearchRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SearchRecordFindUniqueOrThrowArgs} args - Arguments to find a SearchRecord
     * @example
     * // Get one SearchRecord
     * const searchRecord = await prisma.searchRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchRecordClient<$Result.GetResult<Prisma.$SearchRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchRecordFindFirstArgs} args - Arguments to find a SearchRecord
     * @example
     * // Get one SearchRecord
     * const searchRecord = await prisma.searchRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchRecordFindFirstArgs>(args?: SelectSubset<T, SearchRecordFindFirstArgs<ExtArgs>>): Prisma__SearchRecordClient<$Result.GetResult<Prisma.$SearchRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchRecordFindFirstOrThrowArgs} args - Arguments to find a SearchRecord
     * @example
     * // Get one SearchRecord
     * const searchRecord = await prisma.searchRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchRecordClient<$Result.GetResult<Prisma.$SearchRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SearchRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchRecords
     * const searchRecords = await prisma.searchRecord.findMany()
     * 
     * // Get first 10 SearchRecords
     * const searchRecords = await prisma.searchRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchRecordWithIdOnly = await prisma.searchRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchRecordFindManyArgs>(args?: SelectSubset<T, SearchRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SearchRecord.
     * @param {SearchRecordCreateArgs} args - Arguments to create a SearchRecord.
     * @example
     * // Create one SearchRecord
     * const SearchRecord = await prisma.searchRecord.create({
     *   data: {
     *     // ... data to create a SearchRecord
     *   }
     * })
     * 
     */
    create<T extends SearchRecordCreateArgs>(args: SelectSubset<T, SearchRecordCreateArgs<ExtArgs>>): Prisma__SearchRecordClient<$Result.GetResult<Prisma.$SearchRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SearchRecords.
     * @param {SearchRecordCreateManyArgs} args - Arguments to create many SearchRecords.
     * @example
     * // Create many SearchRecords
     * const searchRecord = await prisma.searchRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchRecordCreateManyArgs>(args?: SelectSubset<T, SearchRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SearchRecords and returns the data saved in the database.
     * @param {SearchRecordCreateManyAndReturnArgs} args - Arguments to create many SearchRecords.
     * @example
     * // Create many SearchRecords
     * const searchRecord = await prisma.searchRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SearchRecords and only return the `id`
     * const searchRecordWithIdOnly = await prisma.searchRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SearchRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SearchRecord.
     * @param {SearchRecordDeleteArgs} args - Arguments to delete one SearchRecord.
     * @example
     * // Delete one SearchRecord
     * const SearchRecord = await prisma.searchRecord.delete({
     *   where: {
     *     // ... filter to delete one SearchRecord
     *   }
     * })
     * 
     */
    delete<T extends SearchRecordDeleteArgs>(args: SelectSubset<T, SearchRecordDeleteArgs<ExtArgs>>): Prisma__SearchRecordClient<$Result.GetResult<Prisma.$SearchRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SearchRecord.
     * @param {SearchRecordUpdateArgs} args - Arguments to update one SearchRecord.
     * @example
     * // Update one SearchRecord
     * const searchRecord = await prisma.searchRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchRecordUpdateArgs>(args: SelectSubset<T, SearchRecordUpdateArgs<ExtArgs>>): Prisma__SearchRecordClient<$Result.GetResult<Prisma.$SearchRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SearchRecords.
     * @param {SearchRecordDeleteManyArgs} args - Arguments to filter SearchRecords to delete.
     * @example
     * // Delete a few SearchRecords
     * const { count } = await prisma.searchRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchRecordDeleteManyArgs>(args?: SelectSubset<T, SearchRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchRecords
     * const searchRecord = await prisma.searchRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchRecordUpdateManyArgs>(args: SelectSubset<T, SearchRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchRecords and returns the data updated in the database.
     * @param {SearchRecordUpdateManyAndReturnArgs} args - Arguments to update many SearchRecords.
     * @example
     * // Update many SearchRecords
     * const searchRecord = await prisma.searchRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SearchRecords and only return the `id`
     * const searchRecordWithIdOnly = await prisma.searchRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SearchRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, SearchRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SearchRecord.
     * @param {SearchRecordUpsertArgs} args - Arguments to update or create a SearchRecord.
     * @example
     * // Update or create a SearchRecord
     * const searchRecord = await prisma.searchRecord.upsert({
     *   create: {
     *     // ... data to create a SearchRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchRecord we want to update
     *   }
     * })
     */
    upsert<T extends SearchRecordUpsertArgs>(args: SelectSubset<T, SearchRecordUpsertArgs<ExtArgs>>): Prisma__SearchRecordClient<$Result.GetResult<Prisma.$SearchRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SearchRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchRecordCountArgs} args - Arguments to filter SearchRecords to count.
     * @example
     * // Count the number of SearchRecords
     * const count = await prisma.searchRecord.count({
     *   where: {
     *     // ... the filter for the SearchRecords we want to count
     *   }
     * })
    **/
    count<T extends SearchRecordCountArgs>(
      args?: Subset<T, SearchRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchRecordAggregateArgs>(args: Subset<T, SearchRecordAggregateArgs>): Prisma.PrismaPromise<GetSearchRecordAggregateType<T>>

    /**
     * Group by SearchRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchRecordGroupByArgs['orderBy'] }
        : { orderBy?: SearchRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchRecord model
   */
  readonly fields: SearchRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchRecord model
   */
  interface SearchRecordFieldRefs {
    readonly id: FieldRef<"SearchRecord", 'Int'>
    readonly keyword: FieldRef<"SearchRecord", 'String'>
    readonly createdAt: FieldRef<"SearchRecord", 'DateTime'>
    readonly userId: FieldRef<"SearchRecord", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SearchRecord findUnique
   */
  export type SearchRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchRecord
     */
    select?: SearchRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchRecord
     */
    omit?: SearchRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchRecordInclude<ExtArgs> | null
    /**
     * Filter, which SearchRecord to fetch.
     */
    where: SearchRecordWhereUniqueInput
  }

  /**
   * SearchRecord findUniqueOrThrow
   */
  export type SearchRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchRecord
     */
    select?: SearchRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchRecord
     */
    omit?: SearchRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchRecordInclude<ExtArgs> | null
    /**
     * Filter, which SearchRecord to fetch.
     */
    where: SearchRecordWhereUniqueInput
  }

  /**
   * SearchRecord findFirst
   */
  export type SearchRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchRecord
     */
    select?: SearchRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchRecord
     */
    omit?: SearchRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchRecordInclude<ExtArgs> | null
    /**
     * Filter, which SearchRecord to fetch.
     */
    where?: SearchRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchRecords to fetch.
     */
    orderBy?: SearchRecordOrderByWithRelationInput | SearchRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchRecords.
     */
    cursor?: SearchRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchRecords.
     */
    distinct?: SearchRecordScalarFieldEnum | SearchRecordScalarFieldEnum[]
  }

  /**
   * SearchRecord findFirstOrThrow
   */
  export type SearchRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchRecord
     */
    select?: SearchRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchRecord
     */
    omit?: SearchRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchRecordInclude<ExtArgs> | null
    /**
     * Filter, which SearchRecord to fetch.
     */
    where?: SearchRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchRecords to fetch.
     */
    orderBy?: SearchRecordOrderByWithRelationInput | SearchRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchRecords.
     */
    cursor?: SearchRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchRecords.
     */
    distinct?: SearchRecordScalarFieldEnum | SearchRecordScalarFieldEnum[]
  }

  /**
   * SearchRecord findMany
   */
  export type SearchRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchRecord
     */
    select?: SearchRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchRecord
     */
    omit?: SearchRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchRecordInclude<ExtArgs> | null
    /**
     * Filter, which SearchRecords to fetch.
     */
    where?: SearchRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchRecords to fetch.
     */
    orderBy?: SearchRecordOrderByWithRelationInput | SearchRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchRecords.
     */
    cursor?: SearchRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchRecords.
     */
    skip?: number
    distinct?: SearchRecordScalarFieldEnum | SearchRecordScalarFieldEnum[]
  }

  /**
   * SearchRecord create
   */
  export type SearchRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchRecord
     */
    select?: SearchRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchRecord
     */
    omit?: SearchRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a SearchRecord.
     */
    data: XOR<SearchRecordCreateInput, SearchRecordUncheckedCreateInput>
  }

  /**
   * SearchRecord createMany
   */
  export type SearchRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchRecords.
     */
    data: SearchRecordCreateManyInput | SearchRecordCreateManyInput[]
  }

  /**
   * SearchRecord createManyAndReturn
   */
  export type SearchRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchRecord
     */
    select?: SearchRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchRecord
     */
    omit?: SearchRecordOmit<ExtArgs> | null
    /**
     * The data used to create many SearchRecords.
     */
    data: SearchRecordCreateManyInput | SearchRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchRecord update
   */
  export type SearchRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchRecord
     */
    select?: SearchRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchRecord
     */
    omit?: SearchRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a SearchRecord.
     */
    data: XOR<SearchRecordUpdateInput, SearchRecordUncheckedUpdateInput>
    /**
     * Choose, which SearchRecord to update.
     */
    where: SearchRecordWhereUniqueInput
  }

  /**
   * SearchRecord updateMany
   */
  export type SearchRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchRecords.
     */
    data: XOR<SearchRecordUpdateManyMutationInput, SearchRecordUncheckedUpdateManyInput>
    /**
     * Filter which SearchRecords to update
     */
    where?: SearchRecordWhereInput
    /**
     * Limit how many SearchRecords to update.
     */
    limit?: number
  }

  /**
   * SearchRecord updateManyAndReturn
   */
  export type SearchRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchRecord
     */
    select?: SearchRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchRecord
     */
    omit?: SearchRecordOmit<ExtArgs> | null
    /**
     * The data used to update SearchRecords.
     */
    data: XOR<SearchRecordUpdateManyMutationInput, SearchRecordUncheckedUpdateManyInput>
    /**
     * Filter which SearchRecords to update
     */
    where?: SearchRecordWhereInput
    /**
     * Limit how many SearchRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchRecord upsert
   */
  export type SearchRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchRecord
     */
    select?: SearchRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchRecord
     */
    omit?: SearchRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the SearchRecord to update in case it exists.
     */
    where: SearchRecordWhereUniqueInput
    /**
     * In case the SearchRecord found by the `where` argument doesn't exist, create a new SearchRecord with this data.
     */
    create: XOR<SearchRecordCreateInput, SearchRecordUncheckedCreateInput>
    /**
     * In case the SearchRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchRecordUpdateInput, SearchRecordUncheckedUpdateInput>
  }

  /**
   * SearchRecord delete
   */
  export type SearchRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchRecord
     */
    select?: SearchRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchRecord
     */
    omit?: SearchRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchRecordInclude<ExtArgs> | null
    /**
     * Filter which SearchRecord to delete.
     */
    where: SearchRecordWhereUniqueInput
  }

  /**
   * SearchRecord deleteMany
   */
  export type SearchRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchRecords to delete
     */
    where?: SearchRecordWhereInput
    /**
     * Limit how many SearchRecords to delete.
     */
    limit?: number
  }

  /**
   * SearchRecord without action
   */
  export type SearchRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchRecord
     */
    select?: SearchRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchRecord
     */
    omit?: SearchRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchRecordInclude<ExtArgs> | null
  }


  /**
   * Model Device
   */

  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DeviceSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DeviceMinAggregateOutputType = {
    id: number | null
    name: string | null
    userId: number | null
    isOnline: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    userId: number | null
    isOnline: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    name: number
    userId: number
    isOnline: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeviceAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DeviceSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DeviceMinAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    isOnline?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    isOnline?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    isOnline?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Device to aggregate.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type DeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithAggregationInput | DeviceOrderByWithAggregationInput[]
    by: DeviceScalarFieldEnum[] | DeviceScalarFieldEnum
    having?: DeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _avg?: DeviceAvgAggregateInputType
    _sum?: DeviceSumAggregateInputType
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }

  export type DeviceGroupByOutputType = {
    id: number
    name: string
    userId: number
    isOnline: boolean
    createdAt: Date
    updatedAt: Date
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends DeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    userId?: boolean
    isOnline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    histories?: boolean | Device$historiesArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    userId?: boolean
    isOnline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    userId?: boolean
    isOnline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectScalar = {
    id?: boolean
    name?: boolean
    userId?: boolean
    isOnline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "userId" | "isOnline" | "createdAt" | "updatedAt", ExtArgs["result"]["device"]>
  export type DeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    histories?: boolean | Device$historiesArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeviceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Device"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      histories: Prisma.$UserTrackHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      userId: number
      isOnline: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["device"]>
    composites: {}
  }

  type DeviceGetPayload<S extends boolean | null | undefined | DeviceDefaultArgs> = $Result.GetResult<Prisma.$DevicePayload, S>

  type DeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceCountAggregateInputType | true
    }

  export interface DeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Device'], meta: { name: 'Device' } }
    /**
     * Find zero or one Device that matches the filter.
     * @param {DeviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceFindUniqueArgs>(args: SelectSubset<T, DeviceFindUniqueArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Device that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceFindFirstArgs>(args?: SelectSubset<T, DeviceFindFirstArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceFindManyArgs>(args?: SelectSubset<T, DeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Device.
     * @param {DeviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
     */
    create<T extends DeviceCreateArgs>(args: SelectSubset<T, DeviceCreateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Devices.
     * @param {DeviceCreateManyArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceCreateManyArgs>(args?: SelectSubset<T, DeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Devices and returns the data saved in the database.
     * @param {DeviceCreateManyAndReturnArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Device.
     * @param {DeviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
     */
    delete<T extends DeviceDeleteArgs>(args: SelectSubset<T, DeviceDeleteArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Device.
     * @param {DeviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceUpdateArgs>(args: SelectSubset<T, DeviceUpdateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Devices.
     * @param {DeviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceDeleteManyArgs>(args?: SelectSubset<T, DeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceUpdateManyArgs>(args: SelectSubset<T, DeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices and returns the data updated in the database.
     * @param {DeviceUpdateManyAndReturnArgs} args - Arguments to update many Devices.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Device.
     * @param {DeviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
     */
    upsert<T extends DeviceUpsertArgs>(args: SelectSubset<T, DeviceUpsertArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends DeviceCountArgs>(
      args?: Subset<T, DeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Device model
   */
  readonly fields: DeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    histories<T extends Device$historiesArgs<ExtArgs> = {}>(args?: Subset<T, Device$historiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTrackHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Device model
   */
  interface DeviceFieldRefs {
    readonly id: FieldRef<"Device", 'Int'>
    readonly name: FieldRef<"Device", 'String'>
    readonly userId: FieldRef<"Device", 'Int'>
    readonly isOnline: FieldRef<"Device", 'Boolean'>
    readonly createdAt: FieldRef<"Device", 'DateTime'>
    readonly updatedAt: FieldRef<"Device", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Device findUnique
   */
  export type DeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findUniqueOrThrow
   */
  export type DeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findFirst
   */
  export type DeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findFirstOrThrow
   */
  export type DeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findMany
   */
  export type DeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Devices to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device create
   */
  export type DeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a Device.
     */
    data: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
  }

  /**
   * Device createMany
   */
  export type DeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
  }

  /**
   * Device createManyAndReturn
   */
  export type DeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Device update
   */
  export type DeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a Device.
     */
    data: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
    /**
     * Choose, which Device to update.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device updateMany
   */
  export type DeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to update.
     */
    limit?: number
  }

  /**
   * Device updateManyAndReturn
   */
  export type DeviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Device upsert
   */
  export type DeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the Device to update in case it exists.
     */
    where: DeviceWhereUniqueInput
    /**
     * In case the Device found by the `where` argument doesn't exist, create a new Device with this data.
     */
    create: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
    /**
     * In case the Device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
  }

  /**
   * Device delete
   */
  export type DeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter which Device to delete.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device deleteMany
   */
  export type DeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devices to delete
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to delete.
     */
    limit?: number
  }

  /**
   * Device.histories
   */
  export type Device$historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrackHistory
     */
    select?: UserTrackHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTrackHistory
     */
    omit?: UserTrackHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrackHistoryInclude<ExtArgs> | null
    where?: UserTrackHistoryWhereInput
    orderBy?: UserTrackHistoryOrderByWithRelationInput | UserTrackHistoryOrderByWithRelationInput[]
    cursor?: UserTrackHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTrackHistoryScalarFieldEnum | UserTrackHistoryScalarFieldEnum[]
  }

  /**
   * Device without action
   */
  export type DeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
  }


  /**
   * Model Playlist
   */

  export type AggregatePlaylist = {
    _count: PlaylistCountAggregateOutputType | null
    _avg: PlaylistAvgAggregateOutputType | null
    _sum: PlaylistSumAggregateOutputType | null
    _min: PlaylistMinAggregateOutputType | null
    _max: PlaylistMaxAggregateOutputType | null
  }

  export type PlaylistAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PlaylistSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PlaylistMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: $Enums.TrackType | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
  }

  export type PlaylistMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: $Enums.TrackType | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
  }

  export type PlaylistCountAggregateOutputType = {
    id: number
    name: number
    type: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type PlaylistAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PlaylistSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PlaylistMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type PlaylistMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type PlaylistCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type PlaylistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Playlist to aggregate.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Playlists
    **/
    _count?: true | PlaylistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaylistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaylistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaylistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaylistMaxAggregateInputType
  }

  export type GetPlaylistAggregateType<T extends PlaylistAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaylist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaylist[P]>
      : GetScalarType<T[P], AggregatePlaylist[P]>
  }




  export type PlaylistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistWhereInput
    orderBy?: PlaylistOrderByWithAggregationInput | PlaylistOrderByWithAggregationInput[]
    by: PlaylistScalarFieldEnum[] | PlaylistScalarFieldEnum
    having?: PlaylistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaylistCountAggregateInputType | true
    _avg?: PlaylistAvgAggregateInputType
    _sum?: PlaylistSumAggregateInputType
    _min?: PlaylistMinAggregateInputType
    _max?: PlaylistMaxAggregateInputType
  }

  export type PlaylistGroupByOutputType = {
    id: number
    name: string
    type: $Enums.TrackType
    createdAt: Date
    updatedAt: Date
    userId: number
    _count: PlaylistCountAggregateOutputType | null
    _avg: PlaylistAvgAggregateOutputType | null
    _sum: PlaylistSumAggregateOutputType | null
    _min: PlaylistMinAggregateOutputType | null
    _max: PlaylistMaxAggregateOutputType | null
  }

  type GetPlaylistGroupByPayload<T extends PlaylistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaylistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaylistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaylistGroupByOutputType[P]>
            : GetScalarType<T[P], PlaylistGroupByOutputType[P]>
        }
      >
    >


  export type PlaylistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tracks?: boolean | Playlist$tracksArgs<ExtArgs>
    _count?: boolean | PlaylistCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playlist"]>

  export type PlaylistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playlist"]>

  export type PlaylistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playlist"]>

  export type PlaylistSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type PlaylistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["playlist"]>
  export type PlaylistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tracks?: boolean | Playlist$tracksArgs<ExtArgs>
    _count?: boolean | PlaylistCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlaylistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PlaylistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PlaylistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Playlist"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tracks: Prisma.$TrackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: $Enums.TrackType
      createdAt: Date
      updatedAt: Date
      userId: number
    }, ExtArgs["result"]["playlist"]>
    composites: {}
  }

  type PlaylistGetPayload<S extends boolean | null | undefined | PlaylistDefaultArgs> = $Result.GetResult<Prisma.$PlaylistPayload, S>

  type PlaylistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaylistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaylistCountAggregateInputType | true
    }

  export interface PlaylistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Playlist'], meta: { name: 'Playlist' } }
    /**
     * Find zero or one Playlist that matches the filter.
     * @param {PlaylistFindUniqueArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaylistFindUniqueArgs>(args: SelectSubset<T, PlaylistFindUniqueArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Playlist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaylistFindUniqueOrThrowArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaylistFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaylistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Playlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistFindFirstArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaylistFindFirstArgs>(args?: SelectSubset<T, PlaylistFindFirstArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Playlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistFindFirstOrThrowArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaylistFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaylistFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Playlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Playlists
     * const playlists = await prisma.playlist.findMany()
     * 
     * // Get first 10 Playlists
     * const playlists = await prisma.playlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playlistWithIdOnly = await prisma.playlist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaylistFindManyArgs>(args?: SelectSubset<T, PlaylistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Playlist.
     * @param {PlaylistCreateArgs} args - Arguments to create a Playlist.
     * @example
     * // Create one Playlist
     * const Playlist = await prisma.playlist.create({
     *   data: {
     *     // ... data to create a Playlist
     *   }
     * })
     * 
     */
    create<T extends PlaylistCreateArgs>(args: SelectSubset<T, PlaylistCreateArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Playlists.
     * @param {PlaylistCreateManyArgs} args - Arguments to create many Playlists.
     * @example
     * // Create many Playlists
     * const playlist = await prisma.playlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaylistCreateManyArgs>(args?: SelectSubset<T, PlaylistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Playlists and returns the data saved in the database.
     * @param {PlaylistCreateManyAndReturnArgs} args - Arguments to create many Playlists.
     * @example
     * // Create many Playlists
     * const playlist = await prisma.playlist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Playlists and only return the `id`
     * const playlistWithIdOnly = await prisma.playlist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaylistCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaylistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Playlist.
     * @param {PlaylistDeleteArgs} args - Arguments to delete one Playlist.
     * @example
     * // Delete one Playlist
     * const Playlist = await prisma.playlist.delete({
     *   where: {
     *     // ... filter to delete one Playlist
     *   }
     * })
     * 
     */
    delete<T extends PlaylistDeleteArgs>(args: SelectSubset<T, PlaylistDeleteArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Playlist.
     * @param {PlaylistUpdateArgs} args - Arguments to update one Playlist.
     * @example
     * // Update one Playlist
     * const playlist = await prisma.playlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaylistUpdateArgs>(args: SelectSubset<T, PlaylistUpdateArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Playlists.
     * @param {PlaylistDeleteManyArgs} args - Arguments to filter Playlists to delete.
     * @example
     * // Delete a few Playlists
     * const { count } = await prisma.playlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaylistDeleteManyArgs>(args?: SelectSubset<T, PlaylistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Playlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Playlists
     * const playlist = await prisma.playlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaylistUpdateManyArgs>(args: SelectSubset<T, PlaylistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Playlists and returns the data updated in the database.
     * @param {PlaylistUpdateManyAndReturnArgs} args - Arguments to update many Playlists.
     * @example
     * // Update many Playlists
     * const playlist = await prisma.playlist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Playlists and only return the `id`
     * const playlistWithIdOnly = await prisma.playlist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaylistUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaylistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Playlist.
     * @param {PlaylistUpsertArgs} args - Arguments to update or create a Playlist.
     * @example
     * // Update or create a Playlist
     * const playlist = await prisma.playlist.upsert({
     *   create: {
     *     // ... data to create a Playlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Playlist we want to update
     *   }
     * })
     */
    upsert<T extends PlaylistUpsertArgs>(args: SelectSubset<T, PlaylistUpsertArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Playlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistCountArgs} args - Arguments to filter Playlists to count.
     * @example
     * // Count the number of Playlists
     * const count = await prisma.playlist.count({
     *   where: {
     *     // ... the filter for the Playlists we want to count
     *   }
     * })
    **/
    count<T extends PlaylistCountArgs>(
      args?: Subset<T, PlaylistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaylistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Playlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaylistAggregateArgs>(args: Subset<T, PlaylistAggregateArgs>): Prisma.PrismaPromise<GetPlaylistAggregateType<T>>

    /**
     * Group by Playlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaylistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaylistGroupByArgs['orderBy'] }
        : { orderBy?: PlaylistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaylistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaylistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Playlist model
   */
  readonly fields: PlaylistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Playlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaylistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tracks<T extends Playlist$tracksArgs<ExtArgs> = {}>(args?: Subset<T, Playlist$tracksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Playlist model
   */
  interface PlaylistFieldRefs {
    readonly id: FieldRef<"Playlist", 'Int'>
    readonly name: FieldRef<"Playlist", 'String'>
    readonly type: FieldRef<"Playlist", 'TrackType'>
    readonly createdAt: FieldRef<"Playlist", 'DateTime'>
    readonly updatedAt: FieldRef<"Playlist", 'DateTime'>
    readonly userId: FieldRef<"Playlist", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Playlist findUnique
   */
  export type PlaylistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist findUniqueOrThrow
   */
  export type PlaylistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist findFirst
   */
  export type PlaylistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Playlists.
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Playlists.
     */
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * Playlist findFirstOrThrow
   */
  export type PlaylistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Playlists.
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Playlists.
     */
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * Playlist findMany
   */
  export type PlaylistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlists to fetch.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Playlists.
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * Playlist create
   */
  export type PlaylistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * The data needed to create a Playlist.
     */
    data: XOR<PlaylistCreateInput, PlaylistUncheckedCreateInput>
  }

  /**
   * Playlist createMany
   */
  export type PlaylistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Playlists.
     */
    data: PlaylistCreateManyInput | PlaylistCreateManyInput[]
  }

  /**
   * Playlist createManyAndReturn
   */
  export type PlaylistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * The data used to create many Playlists.
     */
    data: PlaylistCreateManyInput | PlaylistCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Playlist update
   */
  export type PlaylistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * The data needed to update a Playlist.
     */
    data: XOR<PlaylistUpdateInput, PlaylistUncheckedUpdateInput>
    /**
     * Choose, which Playlist to update.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist updateMany
   */
  export type PlaylistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Playlists.
     */
    data: XOR<PlaylistUpdateManyMutationInput, PlaylistUncheckedUpdateManyInput>
    /**
     * Filter which Playlists to update
     */
    where?: PlaylistWhereInput
    /**
     * Limit how many Playlists to update.
     */
    limit?: number
  }

  /**
   * Playlist updateManyAndReturn
   */
  export type PlaylistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * The data used to update Playlists.
     */
    data: XOR<PlaylistUpdateManyMutationInput, PlaylistUncheckedUpdateManyInput>
    /**
     * Filter which Playlists to update
     */
    where?: PlaylistWhereInput
    /**
     * Limit how many Playlists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Playlist upsert
   */
  export type PlaylistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * The filter to search for the Playlist to update in case it exists.
     */
    where: PlaylistWhereUniqueInput
    /**
     * In case the Playlist found by the `where` argument doesn't exist, create a new Playlist with this data.
     */
    create: XOR<PlaylistCreateInput, PlaylistUncheckedCreateInput>
    /**
     * In case the Playlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaylistUpdateInput, PlaylistUncheckedUpdateInput>
  }

  /**
   * Playlist delete
   */
  export type PlaylistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter which Playlist to delete.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist deleteMany
   */
  export type PlaylistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Playlists to delete
     */
    where?: PlaylistWhereInput
    /**
     * Limit how many Playlists to delete.
     */
    limit?: number
  }

  /**
   * Playlist.tracks
   */
  export type Playlist$tracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Track
     */
    omit?: TrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null
    where?: TrackWhereInput
    orderBy?: TrackOrderByWithRelationInput | TrackOrderByWithRelationInput[]
    cursor?: TrackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrackScalarFieldEnum | TrackScalarFieldEnum[]
  }

  /**
   * Playlist without action
   */
  export type PlaylistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
  }


  /**
   * Model Folder
   */

  export type AggregateFolder = {
    _count: FolderCountAggregateOutputType | null
    _avg: FolderAvgAggregateOutputType | null
    _sum: FolderSumAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  export type FolderAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
  }

  export type FolderSumAggregateOutputType = {
    id: number | null
    parentId: number | null
  }

  export type FolderMinAggregateOutputType = {
    id: number | null
    path: string | null
    name: string | null
    parentId: number | null
    type: $Enums.TrackType | null
  }

  export type FolderMaxAggregateOutputType = {
    id: number | null
    path: string | null
    name: string | null
    parentId: number | null
    type: $Enums.TrackType | null
  }

  export type FolderCountAggregateOutputType = {
    id: number
    path: number
    name: number
    parentId: number
    type: number
    _all: number
  }


  export type FolderAvgAggregateInputType = {
    id?: true
    parentId?: true
  }

  export type FolderSumAggregateInputType = {
    id?: true
    parentId?: true
  }

  export type FolderMinAggregateInputType = {
    id?: true
    path?: true
    name?: true
    parentId?: true
    type?: true
  }

  export type FolderMaxAggregateInputType = {
    id?: true
    path?: true
    name?: true
    parentId?: true
    type?: true
  }

  export type FolderCountAggregateInputType = {
    id?: true
    path?: true
    name?: true
    parentId?: true
    type?: true
    _all?: true
  }

  export type FolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folder to aggregate.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Folders
    **/
    _count?: true | FolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FolderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FolderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FolderMaxAggregateInputType
  }

  export type GetFolderAggregateType<T extends FolderAggregateArgs> = {
        [P in keyof T & keyof AggregateFolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFolder[P]>
      : GetScalarType<T[P], AggregateFolder[P]>
  }




  export type FolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithAggregationInput | FolderOrderByWithAggregationInput[]
    by: FolderScalarFieldEnum[] | FolderScalarFieldEnum
    having?: FolderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FolderCountAggregateInputType | true
    _avg?: FolderAvgAggregateInputType
    _sum?: FolderSumAggregateInputType
    _min?: FolderMinAggregateInputType
    _max?: FolderMaxAggregateInputType
  }

  export type FolderGroupByOutputType = {
    id: number
    path: string
    name: string
    parentId: number | null
    type: $Enums.TrackType
    _count: FolderCountAggregateOutputType | null
    _avg: FolderAvgAggregateOutputType | null
    _sum: FolderSumAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  type GetFolderGroupByPayload<T extends FolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FolderGroupByOutputType[P]>
            : GetScalarType<T[P], FolderGroupByOutputType[P]>
        }
      >
    >


  export type FolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    path?: boolean
    name?: boolean
    parentId?: boolean
    type?: boolean
    parent?: boolean | Folder$parentArgs<ExtArgs>
    children?: boolean | Folder$childrenArgs<ExtArgs>
    tracks?: boolean | Folder$tracksArgs<ExtArgs>
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    path?: boolean
    name?: boolean
    parentId?: boolean
    type?: boolean
    parent?: boolean | Folder$parentArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    path?: boolean
    name?: boolean
    parentId?: boolean
    type?: boolean
    parent?: boolean | Folder$parentArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectScalar = {
    id?: boolean
    path?: boolean
    name?: boolean
    parentId?: boolean
    type?: boolean
  }

  export type FolderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "path" | "name" | "parentId" | "type", ExtArgs["result"]["folder"]>
  export type FolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Folder$parentArgs<ExtArgs>
    children?: boolean | Folder$childrenArgs<ExtArgs>
    tracks?: boolean | Folder$tracksArgs<ExtArgs>
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FolderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Folder$parentArgs<ExtArgs>
  }
  export type FolderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Folder$parentArgs<ExtArgs>
  }

  export type $FolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Folder"
    objects: {
      parent: Prisma.$FolderPayload<ExtArgs> | null
      children: Prisma.$FolderPayload<ExtArgs>[]
      tracks: Prisma.$TrackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      path: string
      name: string
      parentId: number | null
      type: $Enums.TrackType
    }, ExtArgs["result"]["folder"]>
    composites: {}
  }

  type FolderGetPayload<S extends boolean | null | undefined | FolderDefaultArgs> = $Result.GetResult<Prisma.$FolderPayload, S>

  type FolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FolderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FolderCountAggregateInputType | true
    }

  export interface FolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Folder'], meta: { name: 'Folder' } }
    /**
     * Find zero or one Folder that matches the filter.
     * @param {FolderFindUniqueArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FolderFindUniqueArgs>(args: SelectSubset<T, FolderFindUniqueArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Folder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FolderFindUniqueOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FolderFindUniqueOrThrowArgs>(args: SelectSubset<T, FolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Folder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FolderFindFirstArgs>(args?: SelectSubset<T, FolderFindFirstArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Folder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FolderFindFirstOrThrowArgs>(args?: SelectSubset<T, FolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Folders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Folders
     * const folders = await prisma.folder.findMany()
     * 
     * // Get first 10 Folders
     * const folders = await prisma.folder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const folderWithIdOnly = await prisma.folder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FolderFindManyArgs>(args?: SelectSubset<T, FolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Folder.
     * @param {FolderCreateArgs} args - Arguments to create a Folder.
     * @example
     * // Create one Folder
     * const Folder = await prisma.folder.create({
     *   data: {
     *     // ... data to create a Folder
     *   }
     * })
     * 
     */
    create<T extends FolderCreateArgs>(args: SelectSubset<T, FolderCreateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Folders.
     * @param {FolderCreateManyArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FolderCreateManyArgs>(args?: SelectSubset<T, FolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Folders and returns the data saved in the database.
     * @param {FolderCreateManyAndReturnArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FolderCreateManyAndReturnArgs>(args?: SelectSubset<T, FolderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Folder.
     * @param {FolderDeleteArgs} args - Arguments to delete one Folder.
     * @example
     * // Delete one Folder
     * const Folder = await prisma.folder.delete({
     *   where: {
     *     // ... filter to delete one Folder
     *   }
     * })
     * 
     */
    delete<T extends FolderDeleteArgs>(args: SelectSubset<T, FolderDeleteArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Folder.
     * @param {FolderUpdateArgs} args - Arguments to update one Folder.
     * @example
     * // Update one Folder
     * const folder = await prisma.folder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FolderUpdateArgs>(args: SelectSubset<T, FolderUpdateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Folders.
     * @param {FolderDeleteManyArgs} args - Arguments to filter Folders to delete.
     * @example
     * // Delete a few Folders
     * const { count } = await prisma.folder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FolderDeleteManyArgs>(args?: SelectSubset<T, FolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FolderUpdateManyArgs>(args: SelectSubset<T, FolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders and returns the data updated in the database.
     * @param {FolderUpdateManyAndReturnArgs} args - Arguments to update many Folders.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FolderUpdateManyAndReturnArgs>(args: SelectSubset<T, FolderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Folder.
     * @param {FolderUpsertArgs} args - Arguments to update or create a Folder.
     * @example
     * // Update or create a Folder
     * const folder = await prisma.folder.upsert({
     *   create: {
     *     // ... data to create a Folder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Folder we want to update
     *   }
     * })
     */
    upsert<T extends FolderUpsertArgs>(args: SelectSubset<T, FolderUpsertArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderCountArgs} args - Arguments to filter Folders to count.
     * @example
     * // Count the number of Folders
     * const count = await prisma.folder.count({
     *   where: {
     *     // ... the filter for the Folders we want to count
     *   }
     * })
    **/
    count<T extends FolderCountArgs>(
      args?: Subset<T, FolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FolderAggregateArgs>(args: Subset<T, FolderAggregateArgs>): Prisma.PrismaPromise<GetFolderAggregateType<T>>

    /**
     * Group by Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FolderGroupByArgs['orderBy'] }
        : { orderBy?: FolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Folder model
   */
  readonly fields: FolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Folder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Folder$parentArgs<ExtArgs> = {}>(args?: Subset<T, Folder$parentArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Folder$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Folder$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tracks<T extends Folder$tracksArgs<ExtArgs> = {}>(args?: Subset<T, Folder$tracksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Folder model
   */
  interface FolderFieldRefs {
    readonly id: FieldRef<"Folder", 'Int'>
    readonly path: FieldRef<"Folder", 'String'>
    readonly name: FieldRef<"Folder", 'String'>
    readonly parentId: FieldRef<"Folder", 'Int'>
    readonly type: FieldRef<"Folder", 'TrackType'>
  }
    

  // Custom InputTypes
  /**
   * Folder findUnique
   */
  export type FolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder findUniqueOrThrow
   */
  export type FolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder findFirst
   */
  export type FolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder findFirstOrThrow
   */
  export type FolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder findMany
   */
  export type FolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folders to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder create
   */
  export type FolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to create a Folder.
     */
    data: XOR<FolderCreateInput, FolderUncheckedCreateInput>
  }

  /**
   * Folder createMany
   */
  export type FolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
  }

  /**
   * Folder createManyAndReturn
   */
  export type FolderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Folder update
   */
  export type FolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to update a Folder.
     */
    data: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
    /**
     * Choose, which Folder to update.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder updateMany
   */
  export type FolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to update.
     */
    limit?: number
  }

  /**
   * Folder updateManyAndReturn
   */
  export type FolderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Folder upsert
   */
  export type FolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The filter to search for the Folder to update in case it exists.
     */
    where: FolderWhereUniqueInput
    /**
     * In case the Folder found by the `where` argument doesn't exist, create a new Folder with this data.
     */
    create: XOR<FolderCreateInput, FolderUncheckedCreateInput>
    /**
     * In case the Folder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
  }

  /**
   * Folder delete
   */
  export type FolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter which Folder to delete.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder deleteMany
   */
  export type FolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folders to delete
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to delete.
     */
    limit?: number
  }

  /**
   * Folder.parent
   */
  export type Folder$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
  }

  /**
   * Folder.children
   */
  export type Folder$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    cursor?: FolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder.tracks
   */
  export type Folder$tracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Track
     */
    omit?: TrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null
    where?: TrackWhereInput
    orderBy?: TrackOrderByWithRelationInput | TrackOrderByWithRelationInput[]
    cursor?: TrackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrackScalarFieldEnum | TrackScalarFieldEnum[]
  }

  /**
   * Folder without action
   */
  export type FolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TrackScalarFieldEnum: {
    id: 'id',
    name: 'name',
    path: 'path',
    artist: 'artist',
    album: 'album',
    cover: 'cover',
    duration: 'duration',
    lyrics: 'lyrics',
    index: 'index',
    type: 'type',
    createdAt: 'createdAt',
    fileModifiedAt: 'fileModifiedAt',
    episodeNumber: 'episodeNumber',
    artistId: 'artistId',
    albumId: 'albumId',
    folderId: 'folderId'
  };

  export type TrackScalarFieldEnum = (typeof TrackScalarFieldEnum)[keyof typeof TrackScalarFieldEnum]


  export const AlbumScalarFieldEnum: {
    id: 'id',
    name: 'name',
    artist: 'artist',
    cover: 'cover',
    year: 'year',
    type: 'type'
  };

  export type AlbumScalarFieldEnum = (typeof AlbumScalarFieldEnum)[keyof typeof AlbumScalarFieldEnum]


  export const ArtistScalarFieldEnum: {
    id: 'id',
    name: 'name',
    avatar: 'avatar',
    type: 'type'
  };

  export type ArtistScalarFieldEnum = (typeof ArtistScalarFieldEnum)[keyof typeof ArtistScalarFieldEnum]


  export const UserTrackLikeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    trackId: 'trackId',
    createdAt: 'createdAt'
  };

  export type UserTrackLikeScalarFieldEnum = (typeof UserTrackLikeScalarFieldEnum)[keyof typeof UserTrackLikeScalarFieldEnum]


  export const UserTrackHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    trackId: 'trackId',
    listenedAt: 'listenedAt',
    progress: 'progress',
    deviceName: 'deviceName',
    deviceId: 'deviceId',
    isSyncMode: 'isSyncMode'
  };

  export type UserTrackHistoryScalarFieldEnum = (typeof UserTrackHistoryScalarFieldEnum)[keyof typeof UserTrackHistoryScalarFieldEnum]


  export const UserAlbumLikeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    albumId: 'albumId',
    createdAt: 'createdAt'
  };

  export type UserAlbumLikeScalarFieldEnum = (typeof UserAlbumLikeScalarFieldEnum)[keyof typeof UserAlbumLikeScalarFieldEnum]


  export const UserAlbumHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    albumId: 'albumId',
    listenedAt: 'listenedAt'
  };

  export type UserAlbumHistoryScalarFieldEnum = (typeof UserAlbumHistoryScalarFieldEnum)[keyof typeof UserAlbumHistoryScalarFieldEnum]


  export const UserAudiobookLikeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    trackId: 'trackId',
    createdAt: 'createdAt'
  };

  export type UserAudiobookLikeScalarFieldEnum = (typeof UserAudiobookLikeScalarFieldEnum)[keyof typeof UserAudiobookLikeScalarFieldEnum]


  export const UserAudiobookHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    trackId: 'trackId',
    listenedAt: 'listenedAt',
    progress: 'progress'
  };

  export type UserAudiobookHistoryScalarFieldEnum = (typeof UserAudiobookHistoryScalarFieldEnum)[keyof typeof UserAudiobookHistoryScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    is_admin: 'is_admin'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SearchRecordScalarFieldEnum: {
    id: 'id',
    keyword: 'keyword',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type SearchRecordScalarFieldEnum = (typeof SearchRecordScalarFieldEnum)[keyof typeof SearchRecordScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    userId: 'userId',
    isOnline: 'isOnline',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const PlaylistScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type PlaylistScalarFieldEnum = (typeof PlaylistScalarFieldEnum)[keyof typeof PlaylistScalarFieldEnum]


  export const FolderScalarFieldEnum: {
    id: 'id',
    path: 'path',
    name: 'name',
    parentId: 'parentId',
    type: 'type'
  };

  export type FolderScalarFieldEnum = (typeof FolderScalarFieldEnum)[keyof typeof FolderScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'TrackType'
   */
  export type EnumTrackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrackType'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type TrackWhereInput = {
    AND?: TrackWhereInput | TrackWhereInput[]
    OR?: TrackWhereInput[]
    NOT?: TrackWhereInput | TrackWhereInput[]
    id?: IntFilter<"Track"> | number
    name?: StringFilter<"Track"> | string
    path?: StringFilter<"Track"> | string
    artist?: StringFilter<"Track"> | string
    album?: StringFilter<"Track"> | string
    cover?: StringNullableFilter<"Track"> | string | null
    duration?: IntNullableFilter<"Track"> | number | null
    lyrics?: StringNullableFilter<"Track"> | string | null
    index?: IntNullableFilter<"Track"> | number | null
    type?: EnumTrackTypeFilter<"Track"> | $Enums.TrackType
    createdAt?: DateTimeFilter<"Track"> | Date | string
    fileModifiedAt?: DateTimeNullableFilter<"Track"> | Date | string | null
    episodeNumber?: IntNullableFilter<"Track"> | number | null
    artistId?: IntNullableFilter<"Track"> | number | null
    albumId?: IntNullableFilter<"Track"> | number | null
    folderId?: IntNullableFilter<"Track"> | number | null
    artistEntity?: XOR<ArtistNullableScalarRelationFilter, ArtistWhereInput> | null
    albumEntity?: XOR<AlbumNullableScalarRelationFilter, AlbumWhereInput> | null
    likedByUsers?: UserTrackLikeListRelationFilter
    listenedByUsers?: UserTrackHistoryListRelationFilter
    likedAsAudiobookByUsers?: UserAudiobookLikeListRelationFilter
    listenedAsAudiobookByUsers?: UserAudiobookHistoryListRelationFilter
    playlists?: PlaylistListRelationFilter
    folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
  }

  export type TrackOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    artist?: SortOrder
    album?: SortOrder
    cover?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    lyrics?: SortOrderInput | SortOrder
    index?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    fileModifiedAt?: SortOrderInput | SortOrder
    episodeNumber?: SortOrderInput | SortOrder
    artistId?: SortOrderInput | SortOrder
    albumId?: SortOrderInput | SortOrder
    folderId?: SortOrderInput | SortOrder
    artistEntity?: ArtistOrderByWithRelationInput
    albumEntity?: AlbumOrderByWithRelationInput
    likedByUsers?: UserTrackLikeOrderByRelationAggregateInput
    listenedByUsers?: UserTrackHistoryOrderByRelationAggregateInput
    likedAsAudiobookByUsers?: UserAudiobookLikeOrderByRelationAggregateInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryOrderByRelationAggregateInput
    playlists?: PlaylistOrderByRelationAggregateInput
    folder?: FolderOrderByWithRelationInput
  }

  export type TrackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TrackWhereInput | TrackWhereInput[]
    OR?: TrackWhereInput[]
    NOT?: TrackWhereInput | TrackWhereInput[]
    name?: StringFilter<"Track"> | string
    path?: StringFilter<"Track"> | string
    artist?: StringFilter<"Track"> | string
    album?: StringFilter<"Track"> | string
    cover?: StringNullableFilter<"Track"> | string | null
    duration?: IntNullableFilter<"Track"> | number | null
    lyrics?: StringNullableFilter<"Track"> | string | null
    index?: IntNullableFilter<"Track"> | number | null
    type?: EnumTrackTypeFilter<"Track"> | $Enums.TrackType
    createdAt?: DateTimeFilter<"Track"> | Date | string
    fileModifiedAt?: DateTimeNullableFilter<"Track"> | Date | string | null
    episodeNumber?: IntNullableFilter<"Track"> | number | null
    artistId?: IntNullableFilter<"Track"> | number | null
    albumId?: IntNullableFilter<"Track"> | number | null
    folderId?: IntNullableFilter<"Track"> | number | null
    artistEntity?: XOR<ArtistNullableScalarRelationFilter, ArtistWhereInput> | null
    albumEntity?: XOR<AlbumNullableScalarRelationFilter, AlbumWhereInput> | null
    likedByUsers?: UserTrackLikeListRelationFilter
    listenedByUsers?: UserTrackHistoryListRelationFilter
    likedAsAudiobookByUsers?: UserAudiobookLikeListRelationFilter
    listenedAsAudiobookByUsers?: UserAudiobookHistoryListRelationFilter
    playlists?: PlaylistListRelationFilter
    folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
  }, "id">

  export type TrackOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    artist?: SortOrder
    album?: SortOrder
    cover?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    lyrics?: SortOrderInput | SortOrder
    index?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    fileModifiedAt?: SortOrderInput | SortOrder
    episodeNumber?: SortOrderInput | SortOrder
    artistId?: SortOrderInput | SortOrder
    albumId?: SortOrderInput | SortOrder
    folderId?: SortOrderInput | SortOrder
    _count?: TrackCountOrderByAggregateInput
    _avg?: TrackAvgOrderByAggregateInput
    _max?: TrackMaxOrderByAggregateInput
    _min?: TrackMinOrderByAggregateInput
    _sum?: TrackSumOrderByAggregateInput
  }

  export type TrackScalarWhereWithAggregatesInput = {
    AND?: TrackScalarWhereWithAggregatesInput | TrackScalarWhereWithAggregatesInput[]
    OR?: TrackScalarWhereWithAggregatesInput[]
    NOT?: TrackScalarWhereWithAggregatesInput | TrackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Track"> | number
    name?: StringWithAggregatesFilter<"Track"> | string
    path?: StringWithAggregatesFilter<"Track"> | string
    artist?: StringWithAggregatesFilter<"Track"> | string
    album?: StringWithAggregatesFilter<"Track"> | string
    cover?: StringNullableWithAggregatesFilter<"Track"> | string | null
    duration?: IntNullableWithAggregatesFilter<"Track"> | number | null
    lyrics?: StringNullableWithAggregatesFilter<"Track"> | string | null
    index?: IntNullableWithAggregatesFilter<"Track"> | number | null
    type?: EnumTrackTypeWithAggregatesFilter<"Track"> | $Enums.TrackType
    createdAt?: DateTimeWithAggregatesFilter<"Track"> | Date | string
    fileModifiedAt?: DateTimeNullableWithAggregatesFilter<"Track"> | Date | string | null
    episodeNumber?: IntNullableWithAggregatesFilter<"Track"> | number | null
    artistId?: IntNullableWithAggregatesFilter<"Track"> | number | null
    albumId?: IntNullableWithAggregatesFilter<"Track"> | number | null
    folderId?: IntNullableWithAggregatesFilter<"Track"> | number | null
  }

  export type AlbumWhereInput = {
    AND?: AlbumWhereInput | AlbumWhereInput[]
    OR?: AlbumWhereInput[]
    NOT?: AlbumWhereInput | AlbumWhereInput[]
    id?: IntFilter<"Album"> | number
    name?: StringFilter<"Album"> | string
    artist?: StringFilter<"Album"> | string
    cover?: StringNullableFilter<"Album"> | string | null
    year?: StringNullableFilter<"Album"> | string | null
    type?: EnumTrackTypeFilter<"Album"> | $Enums.TrackType
    tracks?: TrackListRelationFilter
    likedByUsers?: UserAlbumLikeListRelationFilter
    listenedByUsers?: UserAlbumHistoryListRelationFilter
  }

  export type AlbumOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    artist?: SortOrder
    cover?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    type?: SortOrder
    tracks?: TrackOrderByRelationAggregateInput
    likedByUsers?: UserAlbumLikeOrderByRelationAggregateInput
    listenedByUsers?: UserAlbumHistoryOrderByRelationAggregateInput
  }

  export type AlbumWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AlbumWhereInput | AlbumWhereInput[]
    OR?: AlbumWhereInput[]
    NOT?: AlbumWhereInput | AlbumWhereInput[]
    name?: StringFilter<"Album"> | string
    artist?: StringFilter<"Album"> | string
    cover?: StringNullableFilter<"Album"> | string | null
    year?: StringNullableFilter<"Album"> | string | null
    type?: EnumTrackTypeFilter<"Album"> | $Enums.TrackType
    tracks?: TrackListRelationFilter
    likedByUsers?: UserAlbumLikeListRelationFilter
    listenedByUsers?: UserAlbumHistoryListRelationFilter
  }, "id">

  export type AlbumOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    artist?: SortOrder
    cover?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    type?: SortOrder
    _count?: AlbumCountOrderByAggregateInput
    _avg?: AlbumAvgOrderByAggregateInput
    _max?: AlbumMaxOrderByAggregateInput
    _min?: AlbumMinOrderByAggregateInput
    _sum?: AlbumSumOrderByAggregateInput
  }

  export type AlbumScalarWhereWithAggregatesInput = {
    AND?: AlbumScalarWhereWithAggregatesInput | AlbumScalarWhereWithAggregatesInput[]
    OR?: AlbumScalarWhereWithAggregatesInput[]
    NOT?: AlbumScalarWhereWithAggregatesInput | AlbumScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Album"> | number
    name?: StringWithAggregatesFilter<"Album"> | string
    artist?: StringWithAggregatesFilter<"Album"> | string
    cover?: StringNullableWithAggregatesFilter<"Album"> | string | null
    year?: StringNullableWithAggregatesFilter<"Album"> | string | null
    type?: EnumTrackTypeWithAggregatesFilter<"Album"> | $Enums.TrackType
  }

  export type ArtistWhereInput = {
    AND?: ArtistWhereInput | ArtistWhereInput[]
    OR?: ArtistWhereInput[]
    NOT?: ArtistWhereInput | ArtistWhereInput[]
    id?: IntFilter<"Artist"> | number
    name?: StringFilter<"Artist"> | string
    avatar?: StringNullableFilter<"Artist"> | string | null
    type?: EnumTrackTypeFilter<"Artist"> | $Enums.TrackType
    tracks?: TrackListRelationFilter
  }

  export type ArtistOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    avatar?: SortOrderInput | SortOrder
    type?: SortOrder
    tracks?: TrackOrderByRelationAggregateInput
  }

  export type ArtistWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ArtistWhereInput | ArtistWhereInput[]
    OR?: ArtistWhereInput[]
    NOT?: ArtistWhereInput | ArtistWhereInput[]
    name?: StringFilter<"Artist"> | string
    avatar?: StringNullableFilter<"Artist"> | string | null
    type?: EnumTrackTypeFilter<"Artist"> | $Enums.TrackType
    tracks?: TrackListRelationFilter
  }, "id">

  export type ArtistOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    avatar?: SortOrderInput | SortOrder
    type?: SortOrder
    _count?: ArtistCountOrderByAggregateInput
    _avg?: ArtistAvgOrderByAggregateInput
    _max?: ArtistMaxOrderByAggregateInput
    _min?: ArtistMinOrderByAggregateInput
    _sum?: ArtistSumOrderByAggregateInput
  }

  export type ArtistScalarWhereWithAggregatesInput = {
    AND?: ArtistScalarWhereWithAggregatesInput | ArtistScalarWhereWithAggregatesInput[]
    OR?: ArtistScalarWhereWithAggregatesInput[]
    NOT?: ArtistScalarWhereWithAggregatesInput | ArtistScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Artist"> | number
    name?: StringWithAggregatesFilter<"Artist"> | string
    avatar?: StringNullableWithAggregatesFilter<"Artist"> | string | null
    type?: EnumTrackTypeWithAggregatesFilter<"Artist"> | $Enums.TrackType
  }

  export type UserTrackLikeWhereInput = {
    AND?: UserTrackLikeWhereInput | UserTrackLikeWhereInput[]
    OR?: UserTrackLikeWhereInput[]
    NOT?: UserTrackLikeWhereInput | UserTrackLikeWhereInput[]
    id?: IntFilter<"UserTrackLike"> | number
    userId?: IntFilter<"UserTrackLike"> | number
    trackId?: IntFilter<"UserTrackLike"> | number
    createdAt?: DateTimeFilter<"UserTrackLike"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    track?: XOR<TrackScalarRelationFilter, TrackWhereInput>
  }

  export type UserTrackLikeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    track?: TrackOrderByWithRelationInput
  }

  export type UserTrackLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserTrackLikeWhereInput | UserTrackLikeWhereInput[]
    OR?: UserTrackLikeWhereInput[]
    NOT?: UserTrackLikeWhereInput | UserTrackLikeWhereInput[]
    userId?: IntFilter<"UserTrackLike"> | number
    trackId?: IntFilter<"UserTrackLike"> | number
    createdAt?: DateTimeFilter<"UserTrackLike"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    track?: XOR<TrackScalarRelationFilter, TrackWhereInput>
  }, "id">

  export type UserTrackLikeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    createdAt?: SortOrder
    _count?: UserTrackLikeCountOrderByAggregateInput
    _avg?: UserTrackLikeAvgOrderByAggregateInput
    _max?: UserTrackLikeMaxOrderByAggregateInput
    _min?: UserTrackLikeMinOrderByAggregateInput
    _sum?: UserTrackLikeSumOrderByAggregateInput
  }

  export type UserTrackLikeScalarWhereWithAggregatesInput = {
    AND?: UserTrackLikeScalarWhereWithAggregatesInput | UserTrackLikeScalarWhereWithAggregatesInput[]
    OR?: UserTrackLikeScalarWhereWithAggregatesInput[]
    NOT?: UserTrackLikeScalarWhereWithAggregatesInput | UserTrackLikeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserTrackLike"> | number
    userId?: IntWithAggregatesFilter<"UserTrackLike"> | number
    trackId?: IntWithAggregatesFilter<"UserTrackLike"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserTrackLike"> | Date | string
  }

  export type UserTrackHistoryWhereInput = {
    AND?: UserTrackHistoryWhereInput | UserTrackHistoryWhereInput[]
    OR?: UserTrackHistoryWhereInput[]
    NOT?: UserTrackHistoryWhereInput | UserTrackHistoryWhereInput[]
    id?: IntFilter<"UserTrackHistory"> | number
    userId?: IntFilter<"UserTrackHistory"> | number
    trackId?: IntFilter<"UserTrackHistory"> | number
    listenedAt?: DateTimeFilter<"UserTrackHistory"> | Date | string
    progress?: IntFilter<"UserTrackHistory"> | number
    deviceName?: StringFilter<"UserTrackHistory"> | string
    deviceId?: IntFilter<"UserTrackHistory"> | number
    isSyncMode?: BoolFilter<"UserTrackHistory"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    track?: XOR<TrackScalarRelationFilter, TrackWhereInput>
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
  }

  export type UserTrackHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    listenedAt?: SortOrder
    progress?: SortOrder
    deviceName?: SortOrder
    deviceId?: SortOrder
    isSyncMode?: SortOrder
    user?: UserOrderByWithRelationInput
    track?: TrackOrderByWithRelationInput
    device?: DeviceOrderByWithRelationInput
  }

  export type UserTrackHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserTrackHistoryWhereInput | UserTrackHistoryWhereInput[]
    OR?: UserTrackHistoryWhereInput[]
    NOT?: UserTrackHistoryWhereInput | UserTrackHistoryWhereInput[]
    userId?: IntFilter<"UserTrackHistory"> | number
    trackId?: IntFilter<"UserTrackHistory"> | number
    listenedAt?: DateTimeFilter<"UserTrackHistory"> | Date | string
    progress?: IntFilter<"UserTrackHistory"> | number
    deviceName?: StringFilter<"UserTrackHistory"> | string
    deviceId?: IntFilter<"UserTrackHistory"> | number
    isSyncMode?: BoolFilter<"UserTrackHistory"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    track?: XOR<TrackScalarRelationFilter, TrackWhereInput>
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
  }, "id">

  export type UserTrackHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    listenedAt?: SortOrder
    progress?: SortOrder
    deviceName?: SortOrder
    deviceId?: SortOrder
    isSyncMode?: SortOrder
    _count?: UserTrackHistoryCountOrderByAggregateInput
    _avg?: UserTrackHistoryAvgOrderByAggregateInput
    _max?: UserTrackHistoryMaxOrderByAggregateInput
    _min?: UserTrackHistoryMinOrderByAggregateInput
    _sum?: UserTrackHistorySumOrderByAggregateInput
  }

  export type UserTrackHistoryScalarWhereWithAggregatesInput = {
    AND?: UserTrackHistoryScalarWhereWithAggregatesInput | UserTrackHistoryScalarWhereWithAggregatesInput[]
    OR?: UserTrackHistoryScalarWhereWithAggregatesInput[]
    NOT?: UserTrackHistoryScalarWhereWithAggregatesInput | UserTrackHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserTrackHistory"> | number
    userId?: IntWithAggregatesFilter<"UserTrackHistory"> | number
    trackId?: IntWithAggregatesFilter<"UserTrackHistory"> | number
    listenedAt?: DateTimeWithAggregatesFilter<"UserTrackHistory"> | Date | string
    progress?: IntWithAggregatesFilter<"UserTrackHistory"> | number
    deviceName?: StringWithAggregatesFilter<"UserTrackHistory"> | string
    deviceId?: IntWithAggregatesFilter<"UserTrackHistory"> | number
    isSyncMode?: BoolWithAggregatesFilter<"UserTrackHistory"> | boolean
  }

  export type UserAlbumLikeWhereInput = {
    AND?: UserAlbumLikeWhereInput | UserAlbumLikeWhereInput[]
    OR?: UserAlbumLikeWhereInput[]
    NOT?: UserAlbumLikeWhereInput | UserAlbumLikeWhereInput[]
    id?: IntFilter<"UserAlbumLike"> | number
    userId?: IntFilter<"UserAlbumLike"> | number
    albumId?: IntFilter<"UserAlbumLike"> | number
    createdAt?: DateTimeFilter<"UserAlbumLike"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    album?: XOR<AlbumScalarRelationFilter, AlbumWhereInput>
  }

  export type UserAlbumLikeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    albumId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    album?: AlbumOrderByWithRelationInput
  }

  export type UserAlbumLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserAlbumLikeWhereInput | UserAlbumLikeWhereInput[]
    OR?: UserAlbumLikeWhereInput[]
    NOT?: UserAlbumLikeWhereInput | UserAlbumLikeWhereInput[]
    userId?: IntFilter<"UserAlbumLike"> | number
    albumId?: IntFilter<"UserAlbumLike"> | number
    createdAt?: DateTimeFilter<"UserAlbumLike"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    album?: XOR<AlbumScalarRelationFilter, AlbumWhereInput>
  }, "id">

  export type UserAlbumLikeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    albumId?: SortOrder
    createdAt?: SortOrder
    _count?: UserAlbumLikeCountOrderByAggregateInput
    _avg?: UserAlbumLikeAvgOrderByAggregateInput
    _max?: UserAlbumLikeMaxOrderByAggregateInput
    _min?: UserAlbumLikeMinOrderByAggregateInput
    _sum?: UserAlbumLikeSumOrderByAggregateInput
  }

  export type UserAlbumLikeScalarWhereWithAggregatesInput = {
    AND?: UserAlbumLikeScalarWhereWithAggregatesInput | UserAlbumLikeScalarWhereWithAggregatesInput[]
    OR?: UserAlbumLikeScalarWhereWithAggregatesInput[]
    NOT?: UserAlbumLikeScalarWhereWithAggregatesInput | UserAlbumLikeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserAlbumLike"> | number
    userId?: IntWithAggregatesFilter<"UserAlbumLike"> | number
    albumId?: IntWithAggregatesFilter<"UserAlbumLike"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserAlbumLike"> | Date | string
  }

  export type UserAlbumHistoryWhereInput = {
    AND?: UserAlbumHistoryWhereInput | UserAlbumHistoryWhereInput[]
    OR?: UserAlbumHistoryWhereInput[]
    NOT?: UserAlbumHistoryWhereInput | UserAlbumHistoryWhereInput[]
    id?: IntFilter<"UserAlbumHistory"> | number
    userId?: IntFilter<"UserAlbumHistory"> | number
    albumId?: IntFilter<"UserAlbumHistory"> | number
    listenedAt?: DateTimeFilter<"UserAlbumHistory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    album?: XOR<AlbumScalarRelationFilter, AlbumWhereInput>
  }

  export type UserAlbumHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    albumId?: SortOrder
    listenedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    album?: AlbumOrderByWithRelationInput
  }

  export type UserAlbumHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserAlbumHistoryWhereInput | UserAlbumHistoryWhereInput[]
    OR?: UserAlbumHistoryWhereInput[]
    NOT?: UserAlbumHistoryWhereInput | UserAlbumHistoryWhereInput[]
    userId?: IntFilter<"UserAlbumHistory"> | number
    albumId?: IntFilter<"UserAlbumHistory"> | number
    listenedAt?: DateTimeFilter<"UserAlbumHistory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    album?: XOR<AlbumScalarRelationFilter, AlbumWhereInput>
  }, "id">

  export type UserAlbumHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    albumId?: SortOrder
    listenedAt?: SortOrder
    _count?: UserAlbumHistoryCountOrderByAggregateInput
    _avg?: UserAlbumHistoryAvgOrderByAggregateInput
    _max?: UserAlbumHistoryMaxOrderByAggregateInput
    _min?: UserAlbumHistoryMinOrderByAggregateInput
    _sum?: UserAlbumHistorySumOrderByAggregateInput
  }

  export type UserAlbumHistoryScalarWhereWithAggregatesInput = {
    AND?: UserAlbumHistoryScalarWhereWithAggregatesInput | UserAlbumHistoryScalarWhereWithAggregatesInput[]
    OR?: UserAlbumHistoryScalarWhereWithAggregatesInput[]
    NOT?: UserAlbumHistoryScalarWhereWithAggregatesInput | UserAlbumHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserAlbumHistory"> | number
    userId?: IntWithAggregatesFilter<"UserAlbumHistory"> | number
    albumId?: IntWithAggregatesFilter<"UserAlbumHistory"> | number
    listenedAt?: DateTimeWithAggregatesFilter<"UserAlbumHistory"> | Date | string
  }

  export type UserAudiobookLikeWhereInput = {
    AND?: UserAudiobookLikeWhereInput | UserAudiobookLikeWhereInput[]
    OR?: UserAudiobookLikeWhereInput[]
    NOT?: UserAudiobookLikeWhereInput | UserAudiobookLikeWhereInput[]
    id?: IntFilter<"UserAudiobookLike"> | number
    userId?: IntFilter<"UserAudiobookLike"> | number
    trackId?: IntFilter<"UserAudiobookLike"> | number
    createdAt?: DateTimeFilter<"UserAudiobookLike"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    track?: XOR<TrackScalarRelationFilter, TrackWhereInput>
  }

  export type UserAudiobookLikeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    track?: TrackOrderByWithRelationInput
  }

  export type UserAudiobookLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserAudiobookLikeWhereInput | UserAudiobookLikeWhereInput[]
    OR?: UserAudiobookLikeWhereInput[]
    NOT?: UserAudiobookLikeWhereInput | UserAudiobookLikeWhereInput[]
    userId?: IntFilter<"UserAudiobookLike"> | number
    trackId?: IntFilter<"UserAudiobookLike"> | number
    createdAt?: DateTimeFilter<"UserAudiobookLike"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    track?: XOR<TrackScalarRelationFilter, TrackWhereInput>
  }, "id">

  export type UserAudiobookLikeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    createdAt?: SortOrder
    _count?: UserAudiobookLikeCountOrderByAggregateInput
    _avg?: UserAudiobookLikeAvgOrderByAggregateInput
    _max?: UserAudiobookLikeMaxOrderByAggregateInput
    _min?: UserAudiobookLikeMinOrderByAggregateInput
    _sum?: UserAudiobookLikeSumOrderByAggregateInput
  }

  export type UserAudiobookLikeScalarWhereWithAggregatesInput = {
    AND?: UserAudiobookLikeScalarWhereWithAggregatesInput | UserAudiobookLikeScalarWhereWithAggregatesInput[]
    OR?: UserAudiobookLikeScalarWhereWithAggregatesInput[]
    NOT?: UserAudiobookLikeScalarWhereWithAggregatesInput | UserAudiobookLikeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserAudiobookLike"> | number
    userId?: IntWithAggregatesFilter<"UserAudiobookLike"> | number
    trackId?: IntWithAggregatesFilter<"UserAudiobookLike"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserAudiobookLike"> | Date | string
  }

  export type UserAudiobookHistoryWhereInput = {
    AND?: UserAudiobookHistoryWhereInput | UserAudiobookHistoryWhereInput[]
    OR?: UserAudiobookHistoryWhereInput[]
    NOT?: UserAudiobookHistoryWhereInput | UserAudiobookHistoryWhereInput[]
    id?: IntFilter<"UserAudiobookHistory"> | number
    userId?: IntFilter<"UserAudiobookHistory"> | number
    trackId?: IntFilter<"UserAudiobookHistory"> | number
    listenedAt?: DateTimeFilter<"UserAudiobookHistory"> | Date | string
    progress?: IntFilter<"UserAudiobookHistory"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    track?: XOR<TrackScalarRelationFilter, TrackWhereInput>
  }

  export type UserAudiobookHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    listenedAt?: SortOrder
    progress?: SortOrder
    user?: UserOrderByWithRelationInput
    track?: TrackOrderByWithRelationInput
  }

  export type UserAudiobookHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_trackId?: UserAudiobookHistoryUserIdTrackIdCompoundUniqueInput
    AND?: UserAudiobookHistoryWhereInput | UserAudiobookHistoryWhereInput[]
    OR?: UserAudiobookHistoryWhereInput[]
    NOT?: UserAudiobookHistoryWhereInput | UserAudiobookHistoryWhereInput[]
    userId?: IntFilter<"UserAudiobookHistory"> | number
    trackId?: IntFilter<"UserAudiobookHistory"> | number
    listenedAt?: DateTimeFilter<"UserAudiobookHistory"> | Date | string
    progress?: IntFilter<"UserAudiobookHistory"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    track?: XOR<TrackScalarRelationFilter, TrackWhereInput>
  }, "id" | "userId_trackId">

  export type UserAudiobookHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    listenedAt?: SortOrder
    progress?: SortOrder
    _count?: UserAudiobookHistoryCountOrderByAggregateInput
    _avg?: UserAudiobookHistoryAvgOrderByAggregateInput
    _max?: UserAudiobookHistoryMaxOrderByAggregateInput
    _min?: UserAudiobookHistoryMinOrderByAggregateInput
    _sum?: UserAudiobookHistorySumOrderByAggregateInput
  }

  export type UserAudiobookHistoryScalarWhereWithAggregatesInput = {
    AND?: UserAudiobookHistoryScalarWhereWithAggregatesInput | UserAudiobookHistoryScalarWhereWithAggregatesInput[]
    OR?: UserAudiobookHistoryScalarWhereWithAggregatesInput[]
    NOT?: UserAudiobookHistoryScalarWhereWithAggregatesInput | UserAudiobookHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserAudiobookHistory"> | number
    userId?: IntWithAggregatesFilter<"UserAudiobookHistory"> | number
    trackId?: IntWithAggregatesFilter<"UserAudiobookHistory"> | number
    listenedAt?: DateTimeWithAggregatesFilter<"UserAudiobookHistory"> | Date | string
    progress?: IntWithAggregatesFilter<"UserAudiobookHistory"> | number
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    is_admin?: BoolFilter<"User"> | boolean
    likedTracks?: UserTrackLikeListRelationFilter
    listenedTracks?: UserTrackHistoryListRelationFilter
    likedAlbums?: UserAlbumLikeListRelationFilter
    listenedAlbums?: UserAlbumHistoryListRelationFilter
    likedAudiobooks?: UserAudiobookLikeListRelationFilter
    listenedAudiobooks?: UserAudiobookHistoryListRelationFilter
    playlists?: PlaylistListRelationFilter
    devices?: DeviceListRelationFilter
    searchRecords?: SearchRecordListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    is_admin?: SortOrder
    likedTracks?: UserTrackLikeOrderByRelationAggregateInput
    listenedTracks?: UserTrackHistoryOrderByRelationAggregateInput
    likedAlbums?: UserAlbumLikeOrderByRelationAggregateInput
    listenedAlbums?: UserAlbumHistoryOrderByRelationAggregateInput
    likedAudiobooks?: UserAudiobookLikeOrderByRelationAggregateInput
    listenedAudiobooks?: UserAudiobookHistoryOrderByRelationAggregateInput
    playlists?: PlaylistOrderByRelationAggregateInput
    devices?: DeviceOrderByRelationAggregateInput
    searchRecords?: SearchRecordOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    is_admin?: BoolFilter<"User"> | boolean
    likedTracks?: UserTrackLikeListRelationFilter
    listenedTracks?: UserTrackHistoryListRelationFilter
    likedAlbums?: UserAlbumLikeListRelationFilter
    listenedAlbums?: UserAlbumHistoryListRelationFilter
    likedAudiobooks?: UserAudiobookLikeListRelationFilter
    listenedAudiobooks?: UserAudiobookHistoryListRelationFilter
    playlists?: PlaylistListRelationFilter
    devices?: DeviceListRelationFilter
    searchRecords?: SearchRecordListRelationFilter
  }, "id" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    is_admin?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    is_admin?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type SearchRecordWhereInput = {
    AND?: SearchRecordWhereInput | SearchRecordWhereInput[]
    OR?: SearchRecordWhereInput[]
    NOT?: SearchRecordWhereInput | SearchRecordWhereInput[]
    id?: IntFilter<"SearchRecord"> | number
    keyword?: StringFilter<"SearchRecord"> | string
    createdAt?: DateTimeFilter<"SearchRecord"> | Date | string
    userId?: IntFilter<"SearchRecord"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SearchRecordOrderByWithRelationInput = {
    id?: SortOrder
    keyword?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SearchRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SearchRecordWhereInput | SearchRecordWhereInput[]
    OR?: SearchRecordWhereInput[]
    NOT?: SearchRecordWhereInput | SearchRecordWhereInput[]
    keyword?: StringFilter<"SearchRecord"> | string
    createdAt?: DateTimeFilter<"SearchRecord"> | Date | string
    userId?: IntFilter<"SearchRecord"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SearchRecordOrderByWithAggregationInput = {
    id?: SortOrder
    keyword?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: SearchRecordCountOrderByAggregateInput
    _avg?: SearchRecordAvgOrderByAggregateInput
    _max?: SearchRecordMaxOrderByAggregateInput
    _min?: SearchRecordMinOrderByAggregateInput
    _sum?: SearchRecordSumOrderByAggregateInput
  }

  export type SearchRecordScalarWhereWithAggregatesInput = {
    AND?: SearchRecordScalarWhereWithAggregatesInput | SearchRecordScalarWhereWithAggregatesInput[]
    OR?: SearchRecordScalarWhereWithAggregatesInput[]
    NOT?: SearchRecordScalarWhereWithAggregatesInput | SearchRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SearchRecord"> | number
    keyword?: StringWithAggregatesFilter<"SearchRecord"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SearchRecord"> | Date | string
    userId?: IntWithAggregatesFilter<"SearchRecord"> | number
  }

  export type DeviceWhereInput = {
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    id?: IntFilter<"Device"> | number
    name?: StringFilter<"Device"> | string
    userId?: IntFilter<"Device"> | number
    isOnline?: BoolFilter<"Device"> | boolean
    createdAt?: DateTimeFilter<"Device"> | Date | string
    updatedAt?: DateTimeFilter<"Device"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    histories?: UserTrackHistoryListRelationFilter
  }

  export type DeviceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    isOnline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    histories?: UserTrackHistoryOrderByRelationAggregateInput
  }

  export type DeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    name?: StringFilter<"Device"> | string
    userId?: IntFilter<"Device"> | number
    isOnline?: BoolFilter<"Device"> | boolean
    createdAt?: DateTimeFilter<"Device"> | Date | string
    updatedAt?: DateTimeFilter<"Device"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    histories?: UserTrackHistoryListRelationFilter
  }, "id">

  export type DeviceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    isOnline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeviceCountOrderByAggregateInput
    _avg?: DeviceAvgOrderByAggregateInput
    _max?: DeviceMaxOrderByAggregateInput
    _min?: DeviceMinOrderByAggregateInput
    _sum?: DeviceSumOrderByAggregateInput
  }

  export type DeviceScalarWhereWithAggregatesInput = {
    AND?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    OR?: DeviceScalarWhereWithAggregatesInput[]
    NOT?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Device"> | number
    name?: StringWithAggregatesFilter<"Device"> | string
    userId?: IntWithAggregatesFilter<"Device"> | number
    isOnline?: BoolWithAggregatesFilter<"Device"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Device"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Device"> | Date | string
  }

  export type PlaylistWhereInput = {
    AND?: PlaylistWhereInput | PlaylistWhereInput[]
    OR?: PlaylistWhereInput[]
    NOT?: PlaylistWhereInput | PlaylistWhereInput[]
    id?: IntFilter<"Playlist"> | number
    name?: StringFilter<"Playlist"> | string
    type?: EnumTrackTypeFilter<"Playlist"> | $Enums.TrackType
    createdAt?: DateTimeFilter<"Playlist"> | Date | string
    updatedAt?: DateTimeFilter<"Playlist"> | Date | string
    userId?: IntFilter<"Playlist"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tracks?: TrackListRelationFilter
  }

  export type PlaylistOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    tracks?: TrackOrderByRelationAggregateInput
  }

  export type PlaylistWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlaylistWhereInput | PlaylistWhereInput[]
    OR?: PlaylistWhereInput[]
    NOT?: PlaylistWhereInput | PlaylistWhereInput[]
    name?: StringFilter<"Playlist"> | string
    type?: EnumTrackTypeFilter<"Playlist"> | $Enums.TrackType
    createdAt?: DateTimeFilter<"Playlist"> | Date | string
    updatedAt?: DateTimeFilter<"Playlist"> | Date | string
    userId?: IntFilter<"Playlist"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tracks?: TrackListRelationFilter
  }, "id">

  export type PlaylistOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: PlaylistCountOrderByAggregateInput
    _avg?: PlaylistAvgOrderByAggregateInput
    _max?: PlaylistMaxOrderByAggregateInput
    _min?: PlaylistMinOrderByAggregateInput
    _sum?: PlaylistSumOrderByAggregateInput
  }

  export type PlaylistScalarWhereWithAggregatesInput = {
    AND?: PlaylistScalarWhereWithAggregatesInput | PlaylistScalarWhereWithAggregatesInput[]
    OR?: PlaylistScalarWhereWithAggregatesInput[]
    NOT?: PlaylistScalarWhereWithAggregatesInput | PlaylistScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Playlist"> | number
    name?: StringWithAggregatesFilter<"Playlist"> | string
    type?: EnumTrackTypeWithAggregatesFilter<"Playlist"> | $Enums.TrackType
    createdAt?: DateTimeWithAggregatesFilter<"Playlist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Playlist"> | Date | string
    userId?: IntWithAggregatesFilter<"Playlist"> | number
  }

  export type FolderWhereInput = {
    AND?: FolderWhereInput | FolderWhereInput[]
    OR?: FolderWhereInput[]
    NOT?: FolderWhereInput | FolderWhereInput[]
    id?: IntFilter<"Folder"> | number
    path?: StringFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    parentId?: IntNullableFilter<"Folder"> | number | null
    type?: EnumTrackTypeFilter<"Folder"> | $Enums.TrackType
    parent?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    children?: FolderListRelationFilter
    tracks?: TrackListRelationFilter
  }

  export type FolderOrderByWithRelationInput = {
    id?: SortOrder
    path?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    type?: SortOrder
    parent?: FolderOrderByWithRelationInput
    children?: FolderOrderByRelationAggregateInput
    tracks?: TrackOrderByRelationAggregateInput
  }

  export type FolderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    path?: string
    AND?: FolderWhereInput | FolderWhereInput[]
    OR?: FolderWhereInput[]
    NOT?: FolderWhereInput | FolderWhereInput[]
    name?: StringFilter<"Folder"> | string
    parentId?: IntNullableFilter<"Folder"> | number | null
    type?: EnumTrackTypeFilter<"Folder"> | $Enums.TrackType
    parent?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    children?: FolderListRelationFilter
    tracks?: TrackListRelationFilter
  }, "id" | "path">

  export type FolderOrderByWithAggregationInput = {
    id?: SortOrder
    path?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    type?: SortOrder
    _count?: FolderCountOrderByAggregateInput
    _avg?: FolderAvgOrderByAggregateInput
    _max?: FolderMaxOrderByAggregateInput
    _min?: FolderMinOrderByAggregateInput
    _sum?: FolderSumOrderByAggregateInput
  }

  export type FolderScalarWhereWithAggregatesInput = {
    AND?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[]
    OR?: FolderScalarWhereWithAggregatesInput[]
    NOT?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Folder"> | number
    path?: StringWithAggregatesFilter<"Folder"> | string
    name?: StringWithAggregatesFilter<"Folder"> | string
    parentId?: IntNullableWithAggregatesFilter<"Folder"> | number | null
    type?: EnumTrackTypeWithAggregatesFilter<"Folder"> | $Enums.TrackType
  }

  export type TrackCreateInput = {
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistEntity?: ArtistCreateNestedOneWithoutTracksInput
    albumEntity?: AlbumCreateNestedOneWithoutTracksInput
    likedByUsers?: UserTrackLikeCreateNestedManyWithoutTrackInput
    listenedByUsers?: UserTrackHistoryCreateNestedManyWithoutTrackInput
    likedAsAudiobookByUsers?: UserAudiobookLikeCreateNestedManyWithoutTrackInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryCreateNestedManyWithoutTrackInput
    playlists?: PlaylistCreateNestedManyWithoutTracksInput
    folder?: FolderCreateNestedOneWithoutTracksInput
  }

  export type TrackUncheckedCreateInput = {
    id?: number
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistId?: number | null
    albumId?: number | null
    folderId?: number | null
    likedByUsers?: UserTrackLikeUncheckedCreateNestedManyWithoutTrackInput
    listenedByUsers?: UserTrackHistoryUncheckedCreateNestedManyWithoutTrackInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUncheckedCreateNestedManyWithoutTrackInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUncheckedCreateNestedManyWithoutTrackInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutTracksInput
  }

  export type TrackUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistEntity?: ArtistUpdateOneWithoutTracksNestedInput
    albumEntity?: AlbumUpdateOneWithoutTracksNestedInput
    likedByUsers?: UserTrackLikeUpdateManyWithoutTrackNestedInput
    listenedByUsers?: UserTrackHistoryUpdateManyWithoutTrackNestedInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUpdateManyWithoutTrackNestedInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUpdateManyWithoutTrackNestedInput
    playlists?: PlaylistUpdateManyWithoutTracksNestedInput
    folder?: FolderUpdateOneWithoutTracksNestedInput
  }

  export type TrackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistId?: NullableIntFieldUpdateOperationsInput | number | null
    albumId?: NullableIntFieldUpdateOperationsInput | number | null
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    likedByUsers?: UserTrackLikeUncheckedUpdateManyWithoutTrackNestedInput
    listenedByUsers?: UserTrackHistoryUncheckedUpdateManyWithoutTrackNestedInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUncheckedUpdateManyWithoutTrackNestedInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUncheckedUpdateManyWithoutTrackNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutTracksNestedInput
  }

  export type TrackCreateManyInput = {
    id?: number
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistId?: number | null
    albumId?: number | null
    folderId?: number | null
  }

  export type TrackUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TrackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistId?: NullableIntFieldUpdateOperationsInput | number | null
    albumId?: NullableIntFieldUpdateOperationsInput | number | null
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AlbumCreateInput = {
    name: string
    artist: string
    cover?: string | null
    year?: string | null
    type?: $Enums.TrackType
    tracks?: TrackCreateNestedManyWithoutAlbumEntityInput
    likedByUsers?: UserAlbumLikeCreateNestedManyWithoutAlbumInput
    listenedByUsers?: UserAlbumHistoryCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUncheckedCreateInput = {
    id?: number
    name: string
    artist: string
    cover?: string | null
    year?: string | null
    type?: $Enums.TrackType
    tracks?: TrackUncheckedCreateNestedManyWithoutAlbumEntityInput
    likedByUsers?: UserAlbumLikeUncheckedCreateNestedManyWithoutAlbumInput
    listenedByUsers?: UserAlbumHistoryUncheckedCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    tracks?: TrackUpdateManyWithoutAlbumEntityNestedInput
    likedByUsers?: UserAlbumLikeUpdateManyWithoutAlbumNestedInput
    listenedByUsers?: UserAlbumHistoryUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    tracks?: TrackUncheckedUpdateManyWithoutAlbumEntityNestedInput
    likedByUsers?: UserAlbumLikeUncheckedUpdateManyWithoutAlbumNestedInput
    listenedByUsers?: UserAlbumHistoryUncheckedUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumCreateManyInput = {
    id?: number
    name: string
    artist: string
    cover?: string | null
    year?: string | null
    type?: $Enums.TrackType
  }

  export type AlbumUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
  }

  export type AlbumUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
  }

  export type ArtistCreateInput = {
    name: string
    avatar?: string | null
    type?: $Enums.TrackType
    tracks?: TrackCreateNestedManyWithoutArtistEntityInput
  }

  export type ArtistUncheckedCreateInput = {
    id?: number
    name: string
    avatar?: string | null
    type?: $Enums.TrackType
    tracks?: TrackUncheckedCreateNestedManyWithoutArtistEntityInput
  }

  export type ArtistUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    tracks?: TrackUpdateManyWithoutArtistEntityNestedInput
  }

  export type ArtistUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    tracks?: TrackUncheckedUpdateManyWithoutArtistEntityNestedInput
  }

  export type ArtistCreateManyInput = {
    id?: number
    name: string
    avatar?: string | null
    type?: $Enums.TrackType
  }

  export type ArtistUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
  }

  export type ArtistUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
  }

  export type UserTrackLikeCreateInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLikedTracksInput
    track: TrackCreateNestedOneWithoutLikedByUsersInput
  }

  export type UserTrackLikeUncheckedCreateInput = {
    id?: number
    userId: number
    trackId: number
    createdAt?: Date | string
  }

  export type UserTrackLikeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedTracksNestedInput
    track?: TrackUpdateOneRequiredWithoutLikedByUsersNestedInput
  }

  export type UserTrackLikeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    trackId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTrackLikeCreateManyInput = {
    id?: number
    userId: number
    trackId: number
    createdAt?: Date | string
  }

  export type UserTrackLikeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTrackLikeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    trackId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTrackHistoryCreateInput = {
    listenedAt?: Date | string
    progress?: number
    deviceName: string
    isSyncMode?: boolean
    user: UserCreateNestedOneWithoutListenedTracksInput
    track: TrackCreateNestedOneWithoutListenedByUsersInput
    device: DeviceCreateNestedOneWithoutHistoriesInput
  }

  export type UserTrackHistoryUncheckedCreateInput = {
    id?: number
    userId: number
    trackId: number
    listenedAt?: Date | string
    progress?: number
    deviceName: string
    deviceId: number
    isSyncMode?: boolean
  }

  export type UserTrackHistoryUpdateInput = {
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    deviceName?: StringFieldUpdateOperationsInput | string
    isSyncMode?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutListenedTracksNestedInput
    track?: TrackUpdateOneRequiredWithoutListenedByUsersNestedInput
    device?: DeviceUpdateOneRequiredWithoutHistoriesNestedInput
  }

  export type UserTrackHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    trackId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    deviceName?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    isSyncMode?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserTrackHistoryCreateManyInput = {
    id?: number
    userId: number
    trackId: number
    listenedAt?: Date | string
    progress?: number
    deviceName: string
    deviceId: number
    isSyncMode?: boolean
  }

  export type UserTrackHistoryUpdateManyMutationInput = {
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    deviceName?: StringFieldUpdateOperationsInput | string
    isSyncMode?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserTrackHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    trackId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    deviceName?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    isSyncMode?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAlbumLikeCreateInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLikedAlbumsInput
    album: AlbumCreateNestedOneWithoutLikedByUsersInput
  }

  export type UserAlbumLikeUncheckedCreateInput = {
    id?: number
    userId: number
    albumId: number
    createdAt?: Date | string
  }

  export type UserAlbumLikeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedAlbumsNestedInput
    album?: AlbumUpdateOneRequiredWithoutLikedByUsersNestedInput
  }

  export type UserAlbumLikeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    albumId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlbumLikeCreateManyInput = {
    id?: number
    userId: number
    albumId: number
    createdAt?: Date | string
  }

  export type UserAlbumLikeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlbumLikeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    albumId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlbumHistoryCreateInput = {
    listenedAt?: Date | string
    user: UserCreateNestedOneWithoutListenedAlbumsInput
    album: AlbumCreateNestedOneWithoutListenedByUsersInput
  }

  export type UserAlbumHistoryUncheckedCreateInput = {
    id?: number
    userId: number
    albumId: number
    listenedAt?: Date | string
  }

  export type UserAlbumHistoryUpdateInput = {
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutListenedAlbumsNestedInput
    album?: AlbumUpdateOneRequiredWithoutListenedByUsersNestedInput
  }

  export type UserAlbumHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    albumId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlbumHistoryCreateManyInput = {
    id?: number
    userId: number
    albumId: number
    listenedAt?: Date | string
  }

  export type UserAlbumHistoryUpdateManyMutationInput = {
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlbumHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    albumId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAudiobookLikeCreateInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLikedAudiobooksInput
    track: TrackCreateNestedOneWithoutLikedAsAudiobookByUsersInput
  }

  export type UserAudiobookLikeUncheckedCreateInput = {
    id?: number
    userId: number
    trackId: number
    createdAt?: Date | string
  }

  export type UserAudiobookLikeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedAudiobooksNestedInput
    track?: TrackUpdateOneRequiredWithoutLikedAsAudiobookByUsersNestedInput
  }

  export type UserAudiobookLikeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    trackId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAudiobookLikeCreateManyInput = {
    id?: number
    userId: number
    trackId: number
    createdAt?: Date | string
  }

  export type UserAudiobookLikeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAudiobookLikeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    trackId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAudiobookHistoryCreateInput = {
    listenedAt?: Date | string
    progress?: number
    user: UserCreateNestedOneWithoutListenedAudiobooksInput
    track: TrackCreateNestedOneWithoutListenedAsAudiobookByUsersInput
  }

  export type UserAudiobookHistoryUncheckedCreateInput = {
    id?: number
    userId: number
    trackId: number
    listenedAt?: Date | string
    progress?: number
  }

  export type UserAudiobookHistoryUpdateInput = {
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutListenedAudiobooksNestedInput
    track?: TrackUpdateOneRequiredWithoutListenedAsAudiobookByUsersNestedInput
  }

  export type UserAudiobookHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    trackId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserAudiobookHistoryCreateManyInput = {
    id?: number
    userId: number
    trackId: number
    listenedAt?: Date | string
    progress?: number
  }

  export type UserAudiobookHistoryUpdateManyMutationInput = {
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserAudiobookHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    trackId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    username: string
    password: string
    is_admin?: boolean
    likedTracks?: UserTrackLikeCreateNestedManyWithoutUserInput
    listenedTracks?: UserTrackHistoryCreateNestedManyWithoutUserInput
    likedAlbums?: UserAlbumLikeCreateNestedManyWithoutUserInput
    listenedAlbums?: UserAlbumHistoryCreateNestedManyWithoutUserInput
    likedAudiobooks?: UserAudiobookLikeCreateNestedManyWithoutUserInput
    listenedAudiobooks?: UserAudiobookHistoryCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    searchRecords?: SearchRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    is_admin?: boolean
    likedTracks?: UserTrackLikeUncheckedCreateNestedManyWithoutUserInput
    listenedTracks?: UserTrackHistoryUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserAlbumLikeUncheckedCreateNestedManyWithoutUserInput
    listenedAlbums?: UserAlbumHistoryUncheckedCreateNestedManyWithoutUserInput
    likedAudiobooks?: UserAudiobookLikeUncheckedCreateNestedManyWithoutUserInput
    listenedAudiobooks?: UserAudiobookHistoryUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    searchRecords?: SearchRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    likedTracks?: UserTrackLikeUpdateManyWithoutUserNestedInput
    listenedTracks?: UserTrackHistoryUpdateManyWithoutUserNestedInput
    likedAlbums?: UserAlbumLikeUpdateManyWithoutUserNestedInput
    listenedAlbums?: UserAlbumHistoryUpdateManyWithoutUserNestedInput
    likedAudiobooks?: UserAudiobookLikeUpdateManyWithoutUserNestedInput
    listenedAudiobooks?: UserAudiobookHistoryUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    searchRecords?: SearchRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    likedTracks?: UserTrackLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedTracks?: UserTrackHistoryUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserAlbumLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedAlbums?: UserAlbumHistoryUncheckedUpdateManyWithoutUserNestedInput
    likedAudiobooks?: UserAudiobookLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedAudiobooks?: UserAudiobookHistoryUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    searchRecords?: SearchRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password: string
    is_admin?: boolean
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SearchRecordCreateInput = {
    keyword: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSearchRecordsInput
  }

  export type SearchRecordUncheckedCreateInput = {
    id?: number
    keyword: string
    createdAt?: Date | string
    userId: number
  }

  export type SearchRecordUpdateInput = {
    keyword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSearchRecordsNestedInput
  }

  export type SearchRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type SearchRecordCreateManyInput = {
    id?: number
    keyword: string
    createdAt?: Date | string
    userId: number
  }

  export type SearchRecordUpdateManyMutationInput = {
    keyword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceCreateInput = {
    name: string
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDevicesInput
    histories?: UserTrackHistoryCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateInput = {
    id?: number
    name: string
    userId: number
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    histories?: UserTrackHistoryUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDevicesNestedInput
    histories?: UserTrackHistoryUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    histories?: UserTrackHistoryUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceCreateManyInput = {
    id?: number
    name: string
    userId: number
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaylistCreateInput = {
    name: string
    type?: $Enums.TrackType
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlaylistsInput
    tracks?: TrackCreateNestedManyWithoutPlaylistsInput
  }

  export type PlaylistUncheckedCreateInput = {
    id?: number
    name: string
    type?: $Enums.TrackType
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    tracks?: TrackUncheckedCreateNestedManyWithoutPlaylistsInput
  }

  export type PlaylistUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlaylistsNestedInput
    tracks?: TrackUpdateManyWithoutPlaylistsNestedInput
  }

  export type PlaylistUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    tracks?: TrackUncheckedUpdateManyWithoutPlaylistsNestedInput
  }

  export type PlaylistCreateManyInput = {
    id?: number
    name: string
    type?: $Enums.TrackType
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
  }

  export type PlaylistUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaylistUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type FolderCreateInput = {
    path: string
    name: string
    type?: $Enums.TrackType
    parent?: FolderCreateNestedOneWithoutChildrenInput
    children?: FolderCreateNestedManyWithoutParentInput
    tracks?: TrackCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateInput = {
    id?: number
    path: string
    name: string
    parentId?: number | null
    type?: $Enums.TrackType
    children?: FolderUncheckedCreateNestedManyWithoutParentInput
    tracks?: TrackUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderUpdateInput = {
    path?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    parent?: FolderUpdateOneWithoutChildrenNestedInput
    children?: FolderUpdateManyWithoutParentNestedInput
    tracks?: TrackUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    children?: FolderUncheckedUpdateManyWithoutParentNestedInput
    tracks?: TrackUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderCreateManyInput = {
    id?: number
    path: string
    name: string
    parentId?: number | null
    type?: $Enums.TrackType
  }

  export type FolderUpdateManyMutationInput = {
    path?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
  }

  export type FolderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumTrackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrackType[]
    notIn?: $Enums.TrackType[]
    not?: NestedEnumTrackTypeFilter<$PrismaModel> | $Enums.TrackType
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ArtistNullableScalarRelationFilter = {
    is?: ArtistWhereInput | null
    isNot?: ArtistWhereInput | null
  }

  export type AlbumNullableScalarRelationFilter = {
    is?: AlbumWhereInput | null
    isNot?: AlbumWhereInput | null
  }

  export type UserTrackLikeListRelationFilter = {
    every?: UserTrackLikeWhereInput
    some?: UserTrackLikeWhereInput
    none?: UserTrackLikeWhereInput
  }

  export type UserTrackHistoryListRelationFilter = {
    every?: UserTrackHistoryWhereInput
    some?: UserTrackHistoryWhereInput
    none?: UserTrackHistoryWhereInput
  }

  export type UserAudiobookLikeListRelationFilter = {
    every?: UserAudiobookLikeWhereInput
    some?: UserAudiobookLikeWhereInput
    none?: UserAudiobookLikeWhereInput
  }

  export type UserAudiobookHistoryListRelationFilter = {
    every?: UserAudiobookHistoryWhereInput
    some?: UserAudiobookHistoryWhereInput
    none?: UserAudiobookHistoryWhereInput
  }

  export type PlaylistListRelationFilter = {
    every?: PlaylistWhereInput
    some?: PlaylistWhereInput
    none?: PlaylistWhereInput
  }

  export type FolderNullableScalarRelationFilter = {
    is?: FolderWhereInput | null
    isNot?: FolderWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserTrackLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTrackHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAudiobookLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAudiobookHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaylistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrackCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    artist?: SortOrder
    album?: SortOrder
    cover?: SortOrder
    duration?: SortOrder
    lyrics?: SortOrder
    index?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    fileModifiedAt?: SortOrder
    episodeNumber?: SortOrder
    artistId?: SortOrder
    albumId?: SortOrder
    folderId?: SortOrder
  }

  export type TrackAvgOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    index?: SortOrder
    episodeNumber?: SortOrder
    artistId?: SortOrder
    albumId?: SortOrder
    folderId?: SortOrder
  }

  export type TrackMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    artist?: SortOrder
    album?: SortOrder
    cover?: SortOrder
    duration?: SortOrder
    lyrics?: SortOrder
    index?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    fileModifiedAt?: SortOrder
    episodeNumber?: SortOrder
    artistId?: SortOrder
    albumId?: SortOrder
    folderId?: SortOrder
  }

  export type TrackMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    artist?: SortOrder
    album?: SortOrder
    cover?: SortOrder
    duration?: SortOrder
    lyrics?: SortOrder
    index?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    fileModifiedAt?: SortOrder
    episodeNumber?: SortOrder
    artistId?: SortOrder
    albumId?: SortOrder
    folderId?: SortOrder
  }

  export type TrackSumOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    index?: SortOrder
    episodeNumber?: SortOrder
    artistId?: SortOrder
    albumId?: SortOrder
    folderId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumTrackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrackType[]
    notIn?: $Enums.TrackType[]
    not?: NestedEnumTrackTypeWithAggregatesFilter<$PrismaModel> | $Enums.TrackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrackTypeFilter<$PrismaModel>
    _max?: NestedEnumTrackTypeFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type TrackListRelationFilter = {
    every?: TrackWhereInput
    some?: TrackWhereInput
    none?: TrackWhereInput
  }

  export type UserAlbumLikeListRelationFilter = {
    every?: UserAlbumLikeWhereInput
    some?: UserAlbumLikeWhereInput
    none?: UserAlbumLikeWhereInput
  }

  export type UserAlbumHistoryListRelationFilter = {
    every?: UserAlbumHistoryWhereInput
    some?: UserAlbumHistoryWhereInput
    none?: UserAlbumHistoryWhereInput
  }

  export type TrackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAlbumLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAlbumHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlbumCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    artist?: SortOrder
    cover?: SortOrder
    year?: SortOrder
    type?: SortOrder
  }

  export type AlbumAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AlbumMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    artist?: SortOrder
    cover?: SortOrder
    year?: SortOrder
    type?: SortOrder
  }

  export type AlbumMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    artist?: SortOrder
    cover?: SortOrder
    year?: SortOrder
    type?: SortOrder
  }

  export type AlbumSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ArtistCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    type?: SortOrder
  }

  export type ArtistAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ArtistMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    type?: SortOrder
  }

  export type ArtistMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    type?: SortOrder
  }

  export type ArtistSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TrackScalarRelationFilter = {
    is?: TrackWhereInput
    isNot?: TrackWhereInput
  }

  export type UserTrackLikeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserTrackLikeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
  }

  export type UserTrackLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserTrackLikeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserTrackLikeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DeviceScalarRelationFilter = {
    is?: DeviceWhereInput
    isNot?: DeviceWhereInput
  }

  export type UserTrackHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    listenedAt?: SortOrder
    progress?: SortOrder
    deviceName?: SortOrder
    deviceId?: SortOrder
    isSyncMode?: SortOrder
  }

  export type UserTrackHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    progress?: SortOrder
    deviceId?: SortOrder
  }

  export type UserTrackHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    listenedAt?: SortOrder
    progress?: SortOrder
    deviceName?: SortOrder
    deviceId?: SortOrder
    isSyncMode?: SortOrder
  }

  export type UserTrackHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    listenedAt?: SortOrder
    progress?: SortOrder
    deviceName?: SortOrder
    deviceId?: SortOrder
    isSyncMode?: SortOrder
  }

  export type UserTrackHistorySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    progress?: SortOrder
    deviceId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AlbumScalarRelationFilter = {
    is?: AlbumWhereInput
    isNot?: AlbumWhereInput
  }

  export type UserAlbumLikeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    albumId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAlbumLikeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    albumId?: SortOrder
  }

  export type UserAlbumLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    albumId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAlbumLikeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    albumId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAlbumLikeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    albumId?: SortOrder
  }

  export type UserAlbumHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    albumId?: SortOrder
    listenedAt?: SortOrder
  }

  export type UserAlbumHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    albumId?: SortOrder
  }

  export type UserAlbumHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    albumId?: SortOrder
    listenedAt?: SortOrder
  }

  export type UserAlbumHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    albumId?: SortOrder
    listenedAt?: SortOrder
  }

  export type UserAlbumHistorySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    albumId?: SortOrder
  }

  export type UserAudiobookLikeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAudiobookLikeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
  }

  export type UserAudiobookLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAudiobookLikeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAudiobookLikeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
  }

  export type UserAudiobookHistoryUserIdTrackIdCompoundUniqueInput = {
    userId: number
    trackId: number
  }

  export type UserAudiobookHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    listenedAt?: SortOrder
    progress?: SortOrder
  }

  export type UserAudiobookHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    progress?: SortOrder
  }

  export type UserAudiobookHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    listenedAt?: SortOrder
    progress?: SortOrder
  }

  export type UserAudiobookHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    listenedAt?: SortOrder
    progress?: SortOrder
  }

  export type UserAudiobookHistorySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    trackId?: SortOrder
    progress?: SortOrder
  }

  export type DeviceListRelationFilter = {
    every?: DeviceWhereInput
    some?: DeviceWhereInput
    none?: DeviceWhereInput
  }

  export type SearchRecordListRelationFilter = {
    every?: SearchRecordWhereInput
    some?: SearchRecordWhereInput
    none?: SearchRecordWhereInput
  }

  export type DeviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SearchRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    is_admin?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    is_admin?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    is_admin?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SearchRecordCountOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type SearchRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SearchRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type SearchRecordMinOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type SearchRecordSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DeviceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    isOnline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    isOnline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    isOnline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PlaylistCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type PlaylistAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PlaylistMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type PlaylistMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type PlaylistSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FolderListRelationFilter = {
    every?: FolderWhereInput
    some?: FolderWhereInput
    none?: FolderWhereInput
  }

  export type FolderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FolderCountOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    type?: SortOrder
  }

  export type FolderAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
  }

  export type FolderMaxOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    type?: SortOrder
  }

  export type FolderMinOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    type?: SortOrder
  }

  export type FolderSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
  }

  export type ArtistCreateNestedOneWithoutTracksInput = {
    create?: XOR<ArtistCreateWithoutTracksInput, ArtistUncheckedCreateWithoutTracksInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutTracksInput
    connect?: ArtistWhereUniqueInput
  }

  export type AlbumCreateNestedOneWithoutTracksInput = {
    create?: XOR<AlbumCreateWithoutTracksInput, AlbumUncheckedCreateWithoutTracksInput>
    connectOrCreate?: AlbumCreateOrConnectWithoutTracksInput
    connect?: AlbumWhereUniqueInput
  }

  export type UserTrackLikeCreateNestedManyWithoutTrackInput = {
    create?: XOR<UserTrackLikeCreateWithoutTrackInput, UserTrackLikeUncheckedCreateWithoutTrackInput> | UserTrackLikeCreateWithoutTrackInput[] | UserTrackLikeUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: UserTrackLikeCreateOrConnectWithoutTrackInput | UserTrackLikeCreateOrConnectWithoutTrackInput[]
    createMany?: UserTrackLikeCreateManyTrackInputEnvelope
    connect?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
  }

  export type UserTrackHistoryCreateNestedManyWithoutTrackInput = {
    create?: XOR<UserTrackHistoryCreateWithoutTrackInput, UserTrackHistoryUncheckedCreateWithoutTrackInput> | UserTrackHistoryCreateWithoutTrackInput[] | UserTrackHistoryUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: UserTrackHistoryCreateOrConnectWithoutTrackInput | UserTrackHistoryCreateOrConnectWithoutTrackInput[]
    createMany?: UserTrackHistoryCreateManyTrackInputEnvelope
    connect?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
  }

  export type UserAudiobookLikeCreateNestedManyWithoutTrackInput = {
    create?: XOR<UserAudiobookLikeCreateWithoutTrackInput, UserAudiobookLikeUncheckedCreateWithoutTrackInput> | UserAudiobookLikeCreateWithoutTrackInput[] | UserAudiobookLikeUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: UserAudiobookLikeCreateOrConnectWithoutTrackInput | UserAudiobookLikeCreateOrConnectWithoutTrackInput[]
    createMany?: UserAudiobookLikeCreateManyTrackInputEnvelope
    connect?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
  }

  export type UserAudiobookHistoryCreateNestedManyWithoutTrackInput = {
    create?: XOR<UserAudiobookHistoryCreateWithoutTrackInput, UserAudiobookHistoryUncheckedCreateWithoutTrackInput> | UserAudiobookHistoryCreateWithoutTrackInput[] | UserAudiobookHistoryUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: UserAudiobookHistoryCreateOrConnectWithoutTrackInput | UserAudiobookHistoryCreateOrConnectWithoutTrackInput[]
    createMany?: UserAudiobookHistoryCreateManyTrackInputEnvelope
    connect?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
  }

  export type PlaylistCreateNestedManyWithoutTracksInput = {
    create?: XOR<PlaylistCreateWithoutTracksInput, PlaylistUncheckedCreateWithoutTracksInput> | PlaylistCreateWithoutTracksInput[] | PlaylistUncheckedCreateWithoutTracksInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutTracksInput | PlaylistCreateOrConnectWithoutTracksInput[]
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
  }

  export type FolderCreateNestedOneWithoutTracksInput = {
    create?: XOR<FolderCreateWithoutTracksInput, FolderUncheckedCreateWithoutTracksInput>
    connectOrCreate?: FolderCreateOrConnectWithoutTracksInput
    connect?: FolderWhereUniqueInput
  }

  export type UserTrackLikeUncheckedCreateNestedManyWithoutTrackInput = {
    create?: XOR<UserTrackLikeCreateWithoutTrackInput, UserTrackLikeUncheckedCreateWithoutTrackInput> | UserTrackLikeCreateWithoutTrackInput[] | UserTrackLikeUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: UserTrackLikeCreateOrConnectWithoutTrackInput | UserTrackLikeCreateOrConnectWithoutTrackInput[]
    createMany?: UserTrackLikeCreateManyTrackInputEnvelope
    connect?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
  }

  export type UserTrackHistoryUncheckedCreateNestedManyWithoutTrackInput = {
    create?: XOR<UserTrackHistoryCreateWithoutTrackInput, UserTrackHistoryUncheckedCreateWithoutTrackInput> | UserTrackHistoryCreateWithoutTrackInput[] | UserTrackHistoryUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: UserTrackHistoryCreateOrConnectWithoutTrackInput | UserTrackHistoryCreateOrConnectWithoutTrackInput[]
    createMany?: UserTrackHistoryCreateManyTrackInputEnvelope
    connect?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
  }

  export type UserAudiobookLikeUncheckedCreateNestedManyWithoutTrackInput = {
    create?: XOR<UserAudiobookLikeCreateWithoutTrackInput, UserAudiobookLikeUncheckedCreateWithoutTrackInput> | UserAudiobookLikeCreateWithoutTrackInput[] | UserAudiobookLikeUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: UserAudiobookLikeCreateOrConnectWithoutTrackInput | UserAudiobookLikeCreateOrConnectWithoutTrackInput[]
    createMany?: UserAudiobookLikeCreateManyTrackInputEnvelope
    connect?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
  }

  export type UserAudiobookHistoryUncheckedCreateNestedManyWithoutTrackInput = {
    create?: XOR<UserAudiobookHistoryCreateWithoutTrackInput, UserAudiobookHistoryUncheckedCreateWithoutTrackInput> | UserAudiobookHistoryCreateWithoutTrackInput[] | UserAudiobookHistoryUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: UserAudiobookHistoryCreateOrConnectWithoutTrackInput | UserAudiobookHistoryCreateOrConnectWithoutTrackInput[]
    createMany?: UserAudiobookHistoryCreateManyTrackInputEnvelope
    connect?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
  }

  export type PlaylistUncheckedCreateNestedManyWithoutTracksInput = {
    create?: XOR<PlaylistCreateWithoutTracksInput, PlaylistUncheckedCreateWithoutTracksInput> | PlaylistCreateWithoutTracksInput[] | PlaylistUncheckedCreateWithoutTracksInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutTracksInput | PlaylistCreateOrConnectWithoutTracksInput[]
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumTrackTypeFieldUpdateOperationsInput = {
    set?: $Enums.TrackType
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ArtistUpdateOneWithoutTracksNestedInput = {
    create?: XOR<ArtistCreateWithoutTracksInput, ArtistUncheckedCreateWithoutTracksInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutTracksInput
    upsert?: ArtistUpsertWithoutTracksInput
    disconnect?: ArtistWhereInput | boolean
    delete?: ArtistWhereInput | boolean
    connect?: ArtistWhereUniqueInput
    update?: XOR<XOR<ArtistUpdateToOneWithWhereWithoutTracksInput, ArtistUpdateWithoutTracksInput>, ArtistUncheckedUpdateWithoutTracksInput>
  }

  export type AlbumUpdateOneWithoutTracksNestedInput = {
    create?: XOR<AlbumCreateWithoutTracksInput, AlbumUncheckedCreateWithoutTracksInput>
    connectOrCreate?: AlbumCreateOrConnectWithoutTracksInput
    upsert?: AlbumUpsertWithoutTracksInput
    disconnect?: AlbumWhereInput | boolean
    delete?: AlbumWhereInput | boolean
    connect?: AlbumWhereUniqueInput
    update?: XOR<XOR<AlbumUpdateToOneWithWhereWithoutTracksInput, AlbumUpdateWithoutTracksInput>, AlbumUncheckedUpdateWithoutTracksInput>
  }

  export type UserTrackLikeUpdateManyWithoutTrackNestedInput = {
    create?: XOR<UserTrackLikeCreateWithoutTrackInput, UserTrackLikeUncheckedCreateWithoutTrackInput> | UserTrackLikeCreateWithoutTrackInput[] | UserTrackLikeUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: UserTrackLikeCreateOrConnectWithoutTrackInput | UserTrackLikeCreateOrConnectWithoutTrackInput[]
    upsert?: UserTrackLikeUpsertWithWhereUniqueWithoutTrackInput | UserTrackLikeUpsertWithWhereUniqueWithoutTrackInput[]
    createMany?: UserTrackLikeCreateManyTrackInputEnvelope
    set?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
    disconnect?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
    delete?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
    connect?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
    update?: UserTrackLikeUpdateWithWhereUniqueWithoutTrackInput | UserTrackLikeUpdateWithWhereUniqueWithoutTrackInput[]
    updateMany?: UserTrackLikeUpdateManyWithWhereWithoutTrackInput | UserTrackLikeUpdateManyWithWhereWithoutTrackInput[]
    deleteMany?: UserTrackLikeScalarWhereInput | UserTrackLikeScalarWhereInput[]
  }

  export type UserTrackHistoryUpdateManyWithoutTrackNestedInput = {
    create?: XOR<UserTrackHistoryCreateWithoutTrackInput, UserTrackHistoryUncheckedCreateWithoutTrackInput> | UserTrackHistoryCreateWithoutTrackInput[] | UserTrackHistoryUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: UserTrackHistoryCreateOrConnectWithoutTrackInput | UserTrackHistoryCreateOrConnectWithoutTrackInput[]
    upsert?: UserTrackHistoryUpsertWithWhereUniqueWithoutTrackInput | UserTrackHistoryUpsertWithWhereUniqueWithoutTrackInput[]
    createMany?: UserTrackHistoryCreateManyTrackInputEnvelope
    set?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    disconnect?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    delete?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    connect?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    update?: UserTrackHistoryUpdateWithWhereUniqueWithoutTrackInput | UserTrackHistoryUpdateWithWhereUniqueWithoutTrackInput[]
    updateMany?: UserTrackHistoryUpdateManyWithWhereWithoutTrackInput | UserTrackHistoryUpdateManyWithWhereWithoutTrackInput[]
    deleteMany?: UserTrackHistoryScalarWhereInput | UserTrackHistoryScalarWhereInput[]
  }

  export type UserAudiobookLikeUpdateManyWithoutTrackNestedInput = {
    create?: XOR<UserAudiobookLikeCreateWithoutTrackInput, UserAudiobookLikeUncheckedCreateWithoutTrackInput> | UserAudiobookLikeCreateWithoutTrackInput[] | UserAudiobookLikeUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: UserAudiobookLikeCreateOrConnectWithoutTrackInput | UserAudiobookLikeCreateOrConnectWithoutTrackInput[]
    upsert?: UserAudiobookLikeUpsertWithWhereUniqueWithoutTrackInput | UserAudiobookLikeUpsertWithWhereUniqueWithoutTrackInput[]
    createMany?: UserAudiobookLikeCreateManyTrackInputEnvelope
    set?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
    disconnect?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
    delete?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
    connect?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
    update?: UserAudiobookLikeUpdateWithWhereUniqueWithoutTrackInput | UserAudiobookLikeUpdateWithWhereUniqueWithoutTrackInput[]
    updateMany?: UserAudiobookLikeUpdateManyWithWhereWithoutTrackInput | UserAudiobookLikeUpdateManyWithWhereWithoutTrackInput[]
    deleteMany?: UserAudiobookLikeScalarWhereInput | UserAudiobookLikeScalarWhereInput[]
  }

  export type UserAudiobookHistoryUpdateManyWithoutTrackNestedInput = {
    create?: XOR<UserAudiobookHistoryCreateWithoutTrackInput, UserAudiobookHistoryUncheckedCreateWithoutTrackInput> | UserAudiobookHistoryCreateWithoutTrackInput[] | UserAudiobookHistoryUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: UserAudiobookHistoryCreateOrConnectWithoutTrackInput | UserAudiobookHistoryCreateOrConnectWithoutTrackInput[]
    upsert?: UserAudiobookHistoryUpsertWithWhereUniqueWithoutTrackInput | UserAudiobookHistoryUpsertWithWhereUniqueWithoutTrackInput[]
    createMany?: UserAudiobookHistoryCreateManyTrackInputEnvelope
    set?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
    disconnect?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
    delete?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
    connect?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
    update?: UserAudiobookHistoryUpdateWithWhereUniqueWithoutTrackInput | UserAudiobookHistoryUpdateWithWhereUniqueWithoutTrackInput[]
    updateMany?: UserAudiobookHistoryUpdateManyWithWhereWithoutTrackInput | UserAudiobookHistoryUpdateManyWithWhereWithoutTrackInput[]
    deleteMany?: UserAudiobookHistoryScalarWhereInput | UserAudiobookHistoryScalarWhereInput[]
  }

  export type PlaylistUpdateManyWithoutTracksNestedInput = {
    create?: XOR<PlaylistCreateWithoutTracksInput, PlaylistUncheckedCreateWithoutTracksInput> | PlaylistCreateWithoutTracksInput[] | PlaylistUncheckedCreateWithoutTracksInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutTracksInput | PlaylistCreateOrConnectWithoutTracksInput[]
    upsert?: PlaylistUpsertWithWhereUniqueWithoutTracksInput | PlaylistUpsertWithWhereUniqueWithoutTracksInput[]
    set?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    disconnect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    delete?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    update?: PlaylistUpdateWithWhereUniqueWithoutTracksInput | PlaylistUpdateWithWhereUniqueWithoutTracksInput[]
    updateMany?: PlaylistUpdateManyWithWhereWithoutTracksInput | PlaylistUpdateManyWithWhereWithoutTracksInput[]
    deleteMany?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[]
  }

  export type FolderUpdateOneWithoutTracksNestedInput = {
    create?: XOR<FolderCreateWithoutTracksInput, FolderUncheckedCreateWithoutTracksInput>
    connectOrCreate?: FolderCreateOrConnectWithoutTracksInput
    upsert?: FolderUpsertWithoutTracksInput
    disconnect?: FolderWhereInput | boolean
    delete?: FolderWhereInput | boolean
    connect?: FolderWhereUniqueInput
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutTracksInput, FolderUpdateWithoutTracksInput>, FolderUncheckedUpdateWithoutTracksInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserTrackLikeUncheckedUpdateManyWithoutTrackNestedInput = {
    create?: XOR<UserTrackLikeCreateWithoutTrackInput, UserTrackLikeUncheckedCreateWithoutTrackInput> | UserTrackLikeCreateWithoutTrackInput[] | UserTrackLikeUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: UserTrackLikeCreateOrConnectWithoutTrackInput | UserTrackLikeCreateOrConnectWithoutTrackInput[]
    upsert?: UserTrackLikeUpsertWithWhereUniqueWithoutTrackInput | UserTrackLikeUpsertWithWhereUniqueWithoutTrackInput[]
    createMany?: UserTrackLikeCreateManyTrackInputEnvelope
    set?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
    disconnect?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
    delete?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
    connect?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
    update?: UserTrackLikeUpdateWithWhereUniqueWithoutTrackInput | UserTrackLikeUpdateWithWhereUniqueWithoutTrackInput[]
    updateMany?: UserTrackLikeUpdateManyWithWhereWithoutTrackInput | UserTrackLikeUpdateManyWithWhereWithoutTrackInput[]
    deleteMany?: UserTrackLikeScalarWhereInput | UserTrackLikeScalarWhereInput[]
  }

  export type UserTrackHistoryUncheckedUpdateManyWithoutTrackNestedInput = {
    create?: XOR<UserTrackHistoryCreateWithoutTrackInput, UserTrackHistoryUncheckedCreateWithoutTrackInput> | UserTrackHistoryCreateWithoutTrackInput[] | UserTrackHistoryUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: UserTrackHistoryCreateOrConnectWithoutTrackInput | UserTrackHistoryCreateOrConnectWithoutTrackInput[]
    upsert?: UserTrackHistoryUpsertWithWhereUniqueWithoutTrackInput | UserTrackHistoryUpsertWithWhereUniqueWithoutTrackInput[]
    createMany?: UserTrackHistoryCreateManyTrackInputEnvelope
    set?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    disconnect?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    delete?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    connect?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    update?: UserTrackHistoryUpdateWithWhereUniqueWithoutTrackInput | UserTrackHistoryUpdateWithWhereUniqueWithoutTrackInput[]
    updateMany?: UserTrackHistoryUpdateManyWithWhereWithoutTrackInput | UserTrackHistoryUpdateManyWithWhereWithoutTrackInput[]
    deleteMany?: UserTrackHistoryScalarWhereInput | UserTrackHistoryScalarWhereInput[]
  }

  export type UserAudiobookLikeUncheckedUpdateManyWithoutTrackNestedInput = {
    create?: XOR<UserAudiobookLikeCreateWithoutTrackInput, UserAudiobookLikeUncheckedCreateWithoutTrackInput> | UserAudiobookLikeCreateWithoutTrackInput[] | UserAudiobookLikeUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: UserAudiobookLikeCreateOrConnectWithoutTrackInput | UserAudiobookLikeCreateOrConnectWithoutTrackInput[]
    upsert?: UserAudiobookLikeUpsertWithWhereUniqueWithoutTrackInput | UserAudiobookLikeUpsertWithWhereUniqueWithoutTrackInput[]
    createMany?: UserAudiobookLikeCreateManyTrackInputEnvelope
    set?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
    disconnect?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
    delete?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
    connect?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
    update?: UserAudiobookLikeUpdateWithWhereUniqueWithoutTrackInput | UserAudiobookLikeUpdateWithWhereUniqueWithoutTrackInput[]
    updateMany?: UserAudiobookLikeUpdateManyWithWhereWithoutTrackInput | UserAudiobookLikeUpdateManyWithWhereWithoutTrackInput[]
    deleteMany?: UserAudiobookLikeScalarWhereInput | UserAudiobookLikeScalarWhereInput[]
  }

  export type UserAudiobookHistoryUncheckedUpdateManyWithoutTrackNestedInput = {
    create?: XOR<UserAudiobookHistoryCreateWithoutTrackInput, UserAudiobookHistoryUncheckedCreateWithoutTrackInput> | UserAudiobookHistoryCreateWithoutTrackInput[] | UserAudiobookHistoryUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: UserAudiobookHistoryCreateOrConnectWithoutTrackInput | UserAudiobookHistoryCreateOrConnectWithoutTrackInput[]
    upsert?: UserAudiobookHistoryUpsertWithWhereUniqueWithoutTrackInput | UserAudiobookHistoryUpsertWithWhereUniqueWithoutTrackInput[]
    createMany?: UserAudiobookHistoryCreateManyTrackInputEnvelope
    set?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
    disconnect?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
    delete?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
    connect?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
    update?: UserAudiobookHistoryUpdateWithWhereUniqueWithoutTrackInput | UserAudiobookHistoryUpdateWithWhereUniqueWithoutTrackInput[]
    updateMany?: UserAudiobookHistoryUpdateManyWithWhereWithoutTrackInput | UserAudiobookHistoryUpdateManyWithWhereWithoutTrackInput[]
    deleteMany?: UserAudiobookHistoryScalarWhereInput | UserAudiobookHistoryScalarWhereInput[]
  }

  export type PlaylistUncheckedUpdateManyWithoutTracksNestedInput = {
    create?: XOR<PlaylistCreateWithoutTracksInput, PlaylistUncheckedCreateWithoutTracksInput> | PlaylistCreateWithoutTracksInput[] | PlaylistUncheckedCreateWithoutTracksInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutTracksInput | PlaylistCreateOrConnectWithoutTracksInput[]
    upsert?: PlaylistUpsertWithWhereUniqueWithoutTracksInput | PlaylistUpsertWithWhereUniqueWithoutTracksInput[]
    set?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    disconnect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    delete?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    update?: PlaylistUpdateWithWhereUniqueWithoutTracksInput | PlaylistUpdateWithWhereUniqueWithoutTracksInput[]
    updateMany?: PlaylistUpdateManyWithWhereWithoutTracksInput | PlaylistUpdateManyWithWhereWithoutTracksInput[]
    deleteMany?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[]
  }

  export type TrackCreateNestedManyWithoutAlbumEntityInput = {
    create?: XOR<TrackCreateWithoutAlbumEntityInput, TrackUncheckedCreateWithoutAlbumEntityInput> | TrackCreateWithoutAlbumEntityInput[] | TrackUncheckedCreateWithoutAlbumEntityInput[]
    connectOrCreate?: TrackCreateOrConnectWithoutAlbumEntityInput | TrackCreateOrConnectWithoutAlbumEntityInput[]
    createMany?: TrackCreateManyAlbumEntityInputEnvelope
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
  }

  export type UserAlbumLikeCreateNestedManyWithoutAlbumInput = {
    create?: XOR<UserAlbumLikeCreateWithoutAlbumInput, UserAlbumLikeUncheckedCreateWithoutAlbumInput> | UserAlbumLikeCreateWithoutAlbumInput[] | UserAlbumLikeUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: UserAlbumLikeCreateOrConnectWithoutAlbumInput | UserAlbumLikeCreateOrConnectWithoutAlbumInput[]
    createMany?: UserAlbumLikeCreateManyAlbumInputEnvelope
    connect?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
  }

  export type UserAlbumHistoryCreateNestedManyWithoutAlbumInput = {
    create?: XOR<UserAlbumHistoryCreateWithoutAlbumInput, UserAlbumHistoryUncheckedCreateWithoutAlbumInput> | UserAlbumHistoryCreateWithoutAlbumInput[] | UserAlbumHistoryUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: UserAlbumHistoryCreateOrConnectWithoutAlbumInput | UserAlbumHistoryCreateOrConnectWithoutAlbumInput[]
    createMany?: UserAlbumHistoryCreateManyAlbumInputEnvelope
    connect?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
  }

  export type TrackUncheckedCreateNestedManyWithoutAlbumEntityInput = {
    create?: XOR<TrackCreateWithoutAlbumEntityInput, TrackUncheckedCreateWithoutAlbumEntityInput> | TrackCreateWithoutAlbumEntityInput[] | TrackUncheckedCreateWithoutAlbumEntityInput[]
    connectOrCreate?: TrackCreateOrConnectWithoutAlbumEntityInput | TrackCreateOrConnectWithoutAlbumEntityInput[]
    createMany?: TrackCreateManyAlbumEntityInputEnvelope
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
  }

  export type UserAlbumLikeUncheckedCreateNestedManyWithoutAlbumInput = {
    create?: XOR<UserAlbumLikeCreateWithoutAlbumInput, UserAlbumLikeUncheckedCreateWithoutAlbumInput> | UserAlbumLikeCreateWithoutAlbumInput[] | UserAlbumLikeUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: UserAlbumLikeCreateOrConnectWithoutAlbumInput | UserAlbumLikeCreateOrConnectWithoutAlbumInput[]
    createMany?: UserAlbumLikeCreateManyAlbumInputEnvelope
    connect?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
  }

  export type UserAlbumHistoryUncheckedCreateNestedManyWithoutAlbumInput = {
    create?: XOR<UserAlbumHistoryCreateWithoutAlbumInput, UserAlbumHistoryUncheckedCreateWithoutAlbumInput> | UserAlbumHistoryCreateWithoutAlbumInput[] | UserAlbumHistoryUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: UserAlbumHistoryCreateOrConnectWithoutAlbumInput | UserAlbumHistoryCreateOrConnectWithoutAlbumInput[]
    createMany?: UserAlbumHistoryCreateManyAlbumInputEnvelope
    connect?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
  }

  export type TrackUpdateManyWithoutAlbumEntityNestedInput = {
    create?: XOR<TrackCreateWithoutAlbumEntityInput, TrackUncheckedCreateWithoutAlbumEntityInput> | TrackCreateWithoutAlbumEntityInput[] | TrackUncheckedCreateWithoutAlbumEntityInput[]
    connectOrCreate?: TrackCreateOrConnectWithoutAlbumEntityInput | TrackCreateOrConnectWithoutAlbumEntityInput[]
    upsert?: TrackUpsertWithWhereUniqueWithoutAlbumEntityInput | TrackUpsertWithWhereUniqueWithoutAlbumEntityInput[]
    createMany?: TrackCreateManyAlbumEntityInputEnvelope
    set?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    disconnect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    delete?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    update?: TrackUpdateWithWhereUniqueWithoutAlbumEntityInput | TrackUpdateWithWhereUniqueWithoutAlbumEntityInput[]
    updateMany?: TrackUpdateManyWithWhereWithoutAlbumEntityInput | TrackUpdateManyWithWhereWithoutAlbumEntityInput[]
    deleteMany?: TrackScalarWhereInput | TrackScalarWhereInput[]
  }

  export type UserAlbumLikeUpdateManyWithoutAlbumNestedInput = {
    create?: XOR<UserAlbumLikeCreateWithoutAlbumInput, UserAlbumLikeUncheckedCreateWithoutAlbumInput> | UserAlbumLikeCreateWithoutAlbumInput[] | UserAlbumLikeUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: UserAlbumLikeCreateOrConnectWithoutAlbumInput | UserAlbumLikeCreateOrConnectWithoutAlbumInput[]
    upsert?: UserAlbumLikeUpsertWithWhereUniqueWithoutAlbumInput | UserAlbumLikeUpsertWithWhereUniqueWithoutAlbumInput[]
    createMany?: UserAlbumLikeCreateManyAlbumInputEnvelope
    set?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
    disconnect?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
    delete?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
    connect?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
    update?: UserAlbumLikeUpdateWithWhereUniqueWithoutAlbumInput | UserAlbumLikeUpdateWithWhereUniqueWithoutAlbumInput[]
    updateMany?: UserAlbumLikeUpdateManyWithWhereWithoutAlbumInput | UserAlbumLikeUpdateManyWithWhereWithoutAlbumInput[]
    deleteMany?: UserAlbumLikeScalarWhereInput | UserAlbumLikeScalarWhereInput[]
  }

  export type UserAlbumHistoryUpdateManyWithoutAlbumNestedInput = {
    create?: XOR<UserAlbumHistoryCreateWithoutAlbumInput, UserAlbumHistoryUncheckedCreateWithoutAlbumInput> | UserAlbumHistoryCreateWithoutAlbumInput[] | UserAlbumHistoryUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: UserAlbumHistoryCreateOrConnectWithoutAlbumInput | UserAlbumHistoryCreateOrConnectWithoutAlbumInput[]
    upsert?: UserAlbumHistoryUpsertWithWhereUniqueWithoutAlbumInput | UserAlbumHistoryUpsertWithWhereUniqueWithoutAlbumInput[]
    createMany?: UserAlbumHistoryCreateManyAlbumInputEnvelope
    set?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
    disconnect?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
    delete?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
    connect?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
    update?: UserAlbumHistoryUpdateWithWhereUniqueWithoutAlbumInput | UserAlbumHistoryUpdateWithWhereUniqueWithoutAlbumInput[]
    updateMany?: UserAlbumHistoryUpdateManyWithWhereWithoutAlbumInput | UserAlbumHistoryUpdateManyWithWhereWithoutAlbumInput[]
    deleteMany?: UserAlbumHistoryScalarWhereInput | UserAlbumHistoryScalarWhereInput[]
  }

  export type TrackUncheckedUpdateManyWithoutAlbumEntityNestedInput = {
    create?: XOR<TrackCreateWithoutAlbumEntityInput, TrackUncheckedCreateWithoutAlbumEntityInput> | TrackCreateWithoutAlbumEntityInput[] | TrackUncheckedCreateWithoutAlbumEntityInput[]
    connectOrCreate?: TrackCreateOrConnectWithoutAlbumEntityInput | TrackCreateOrConnectWithoutAlbumEntityInput[]
    upsert?: TrackUpsertWithWhereUniqueWithoutAlbumEntityInput | TrackUpsertWithWhereUniqueWithoutAlbumEntityInput[]
    createMany?: TrackCreateManyAlbumEntityInputEnvelope
    set?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    disconnect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    delete?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    update?: TrackUpdateWithWhereUniqueWithoutAlbumEntityInput | TrackUpdateWithWhereUniqueWithoutAlbumEntityInput[]
    updateMany?: TrackUpdateManyWithWhereWithoutAlbumEntityInput | TrackUpdateManyWithWhereWithoutAlbumEntityInput[]
    deleteMany?: TrackScalarWhereInput | TrackScalarWhereInput[]
  }

  export type UserAlbumLikeUncheckedUpdateManyWithoutAlbumNestedInput = {
    create?: XOR<UserAlbumLikeCreateWithoutAlbumInput, UserAlbumLikeUncheckedCreateWithoutAlbumInput> | UserAlbumLikeCreateWithoutAlbumInput[] | UserAlbumLikeUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: UserAlbumLikeCreateOrConnectWithoutAlbumInput | UserAlbumLikeCreateOrConnectWithoutAlbumInput[]
    upsert?: UserAlbumLikeUpsertWithWhereUniqueWithoutAlbumInput | UserAlbumLikeUpsertWithWhereUniqueWithoutAlbumInput[]
    createMany?: UserAlbumLikeCreateManyAlbumInputEnvelope
    set?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
    disconnect?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
    delete?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
    connect?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
    update?: UserAlbumLikeUpdateWithWhereUniqueWithoutAlbumInput | UserAlbumLikeUpdateWithWhereUniqueWithoutAlbumInput[]
    updateMany?: UserAlbumLikeUpdateManyWithWhereWithoutAlbumInput | UserAlbumLikeUpdateManyWithWhereWithoutAlbumInput[]
    deleteMany?: UserAlbumLikeScalarWhereInput | UserAlbumLikeScalarWhereInput[]
  }

  export type UserAlbumHistoryUncheckedUpdateManyWithoutAlbumNestedInput = {
    create?: XOR<UserAlbumHistoryCreateWithoutAlbumInput, UserAlbumHistoryUncheckedCreateWithoutAlbumInput> | UserAlbumHistoryCreateWithoutAlbumInput[] | UserAlbumHistoryUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: UserAlbumHistoryCreateOrConnectWithoutAlbumInput | UserAlbumHistoryCreateOrConnectWithoutAlbumInput[]
    upsert?: UserAlbumHistoryUpsertWithWhereUniqueWithoutAlbumInput | UserAlbumHistoryUpsertWithWhereUniqueWithoutAlbumInput[]
    createMany?: UserAlbumHistoryCreateManyAlbumInputEnvelope
    set?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
    disconnect?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
    delete?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
    connect?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
    update?: UserAlbumHistoryUpdateWithWhereUniqueWithoutAlbumInput | UserAlbumHistoryUpdateWithWhereUniqueWithoutAlbumInput[]
    updateMany?: UserAlbumHistoryUpdateManyWithWhereWithoutAlbumInput | UserAlbumHistoryUpdateManyWithWhereWithoutAlbumInput[]
    deleteMany?: UserAlbumHistoryScalarWhereInput | UserAlbumHistoryScalarWhereInput[]
  }

  export type TrackCreateNestedManyWithoutArtistEntityInput = {
    create?: XOR<TrackCreateWithoutArtistEntityInput, TrackUncheckedCreateWithoutArtistEntityInput> | TrackCreateWithoutArtistEntityInput[] | TrackUncheckedCreateWithoutArtistEntityInput[]
    connectOrCreate?: TrackCreateOrConnectWithoutArtistEntityInput | TrackCreateOrConnectWithoutArtistEntityInput[]
    createMany?: TrackCreateManyArtistEntityInputEnvelope
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
  }

  export type TrackUncheckedCreateNestedManyWithoutArtistEntityInput = {
    create?: XOR<TrackCreateWithoutArtistEntityInput, TrackUncheckedCreateWithoutArtistEntityInput> | TrackCreateWithoutArtistEntityInput[] | TrackUncheckedCreateWithoutArtistEntityInput[]
    connectOrCreate?: TrackCreateOrConnectWithoutArtistEntityInput | TrackCreateOrConnectWithoutArtistEntityInput[]
    createMany?: TrackCreateManyArtistEntityInputEnvelope
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
  }

  export type TrackUpdateManyWithoutArtistEntityNestedInput = {
    create?: XOR<TrackCreateWithoutArtistEntityInput, TrackUncheckedCreateWithoutArtistEntityInput> | TrackCreateWithoutArtistEntityInput[] | TrackUncheckedCreateWithoutArtistEntityInput[]
    connectOrCreate?: TrackCreateOrConnectWithoutArtistEntityInput | TrackCreateOrConnectWithoutArtistEntityInput[]
    upsert?: TrackUpsertWithWhereUniqueWithoutArtistEntityInput | TrackUpsertWithWhereUniqueWithoutArtistEntityInput[]
    createMany?: TrackCreateManyArtistEntityInputEnvelope
    set?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    disconnect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    delete?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    update?: TrackUpdateWithWhereUniqueWithoutArtistEntityInput | TrackUpdateWithWhereUniqueWithoutArtistEntityInput[]
    updateMany?: TrackUpdateManyWithWhereWithoutArtistEntityInput | TrackUpdateManyWithWhereWithoutArtistEntityInput[]
    deleteMany?: TrackScalarWhereInput | TrackScalarWhereInput[]
  }

  export type TrackUncheckedUpdateManyWithoutArtistEntityNestedInput = {
    create?: XOR<TrackCreateWithoutArtistEntityInput, TrackUncheckedCreateWithoutArtistEntityInput> | TrackCreateWithoutArtistEntityInput[] | TrackUncheckedCreateWithoutArtistEntityInput[]
    connectOrCreate?: TrackCreateOrConnectWithoutArtistEntityInput | TrackCreateOrConnectWithoutArtistEntityInput[]
    upsert?: TrackUpsertWithWhereUniqueWithoutArtistEntityInput | TrackUpsertWithWhereUniqueWithoutArtistEntityInput[]
    createMany?: TrackCreateManyArtistEntityInputEnvelope
    set?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    disconnect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    delete?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    update?: TrackUpdateWithWhereUniqueWithoutArtistEntityInput | TrackUpdateWithWhereUniqueWithoutArtistEntityInput[]
    updateMany?: TrackUpdateManyWithWhereWithoutArtistEntityInput | TrackUpdateManyWithWhereWithoutArtistEntityInput[]
    deleteMany?: TrackScalarWhereInput | TrackScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLikedTracksInput = {
    create?: XOR<UserCreateWithoutLikedTracksInput, UserUncheckedCreateWithoutLikedTracksInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedTracksInput
    connect?: UserWhereUniqueInput
  }

  export type TrackCreateNestedOneWithoutLikedByUsersInput = {
    create?: XOR<TrackCreateWithoutLikedByUsersInput, TrackUncheckedCreateWithoutLikedByUsersInput>
    connectOrCreate?: TrackCreateOrConnectWithoutLikedByUsersInput
    connect?: TrackWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLikedTracksNestedInput = {
    create?: XOR<UserCreateWithoutLikedTracksInput, UserUncheckedCreateWithoutLikedTracksInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedTracksInput
    upsert?: UserUpsertWithoutLikedTracksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikedTracksInput, UserUpdateWithoutLikedTracksInput>, UserUncheckedUpdateWithoutLikedTracksInput>
  }

  export type TrackUpdateOneRequiredWithoutLikedByUsersNestedInput = {
    create?: XOR<TrackCreateWithoutLikedByUsersInput, TrackUncheckedCreateWithoutLikedByUsersInput>
    connectOrCreate?: TrackCreateOrConnectWithoutLikedByUsersInput
    upsert?: TrackUpsertWithoutLikedByUsersInput
    connect?: TrackWhereUniqueInput
    update?: XOR<XOR<TrackUpdateToOneWithWhereWithoutLikedByUsersInput, TrackUpdateWithoutLikedByUsersInput>, TrackUncheckedUpdateWithoutLikedByUsersInput>
  }

  export type UserCreateNestedOneWithoutListenedTracksInput = {
    create?: XOR<UserCreateWithoutListenedTracksInput, UserUncheckedCreateWithoutListenedTracksInput>
    connectOrCreate?: UserCreateOrConnectWithoutListenedTracksInput
    connect?: UserWhereUniqueInput
  }

  export type TrackCreateNestedOneWithoutListenedByUsersInput = {
    create?: XOR<TrackCreateWithoutListenedByUsersInput, TrackUncheckedCreateWithoutListenedByUsersInput>
    connectOrCreate?: TrackCreateOrConnectWithoutListenedByUsersInput
    connect?: TrackWhereUniqueInput
  }

  export type DeviceCreateNestedOneWithoutHistoriesInput = {
    create?: XOR<DeviceCreateWithoutHistoriesInput, DeviceUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutHistoriesInput
    connect?: DeviceWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutListenedTracksNestedInput = {
    create?: XOR<UserCreateWithoutListenedTracksInput, UserUncheckedCreateWithoutListenedTracksInput>
    connectOrCreate?: UserCreateOrConnectWithoutListenedTracksInput
    upsert?: UserUpsertWithoutListenedTracksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutListenedTracksInput, UserUpdateWithoutListenedTracksInput>, UserUncheckedUpdateWithoutListenedTracksInput>
  }

  export type TrackUpdateOneRequiredWithoutListenedByUsersNestedInput = {
    create?: XOR<TrackCreateWithoutListenedByUsersInput, TrackUncheckedCreateWithoutListenedByUsersInput>
    connectOrCreate?: TrackCreateOrConnectWithoutListenedByUsersInput
    upsert?: TrackUpsertWithoutListenedByUsersInput
    connect?: TrackWhereUniqueInput
    update?: XOR<XOR<TrackUpdateToOneWithWhereWithoutListenedByUsersInput, TrackUpdateWithoutListenedByUsersInput>, TrackUncheckedUpdateWithoutListenedByUsersInput>
  }

  export type DeviceUpdateOneRequiredWithoutHistoriesNestedInput = {
    create?: XOR<DeviceCreateWithoutHistoriesInput, DeviceUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutHistoriesInput
    upsert?: DeviceUpsertWithoutHistoriesInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutHistoriesInput, DeviceUpdateWithoutHistoriesInput>, DeviceUncheckedUpdateWithoutHistoriesInput>
  }

  export type UserCreateNestedOneWithoutLikedAlbumsInput = {
    create?: XOR<UserCreateWithoutLikedAlbumsInput, UserUncheckedCreateWithoutLikedAlbumsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedAlbumsInput
    connect?: UserWhereUniqueInput
  }

  export type AlbumCreateNestedOneWithoutLikedByUsersInput = {
    create?: XOR<AlbumCreateWithoutLikedByUsersInput, AlbumUncheckedCreateWithoutLikedByUsersInput>
    connectOrCreate?: AlbumCreateOrConnectWithoutLikedByUsersInput
    connect?: AlbumWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLikedAlbumsNestedInput = {
    create?: XOR<UserCreateWithoutLikedAlbumsInput, UserUncheckedCreateWithoutLikedAlbumsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedAlbumsInput
    upsert?: UserUpsertWithoutLikedAlbumsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikedAlbumsInput, UserUpdateWithoutLikedAlbumsInput>, UserUncheckedUpdateWithoutLikedAlbumsInput>
  }

  export type AlbumUpdateOneRequiredWithoutLikedByUsersNestedInput = {
    create?: XOR<AlbumCreateWithoutLikedByUsersInput, AlbumUncheckedCreateWithoutLikedByUsersInput>
    connectOrCreate?: AlbumCreateOrConnectWithoutLikedByUsersInput
    upsert?: AlbumUpsertWithoutLikedByUsersInput
    connect?: AlbumWhereUniqueInput
    update?: XOR<XOR<AlbumUpdateToOneWithWhereWithoutLikedByUsersInput, AlbumUpdateWithoutLikedByUsersInput>, AlbumUncheckedUpdateWithoutLikedByUsersInput>
  }

  export type UserCreateNestedOneWithoutListenedAlbumsInput = {
    create?: XOR<UserCreateWithoutListenedAlbumsInput, UserUncheckedCreateWithoutListenedAlbumsInput>
    connectOrCreate?: UserCreateOrConnectWithoutListenedAlbumsInput
    connect?: UserWhereUniqueInput
  }

  export type AlbumCreateNestedOneWithoutListenedByUsersInput = {
    create?: XOR<AlbumCreateWithoutListenedByUsersInput, AlbumUncheckedCreateWithoutListenedByUsersInput>
    connectOrCreate?: AlbumCreateOrConnectWithoutListenedByUsersInput
    connect?: AlbumWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutListenedAlbumsNestedInput = {
    create?: XOR<UserCreateWithoutListenedAlbumsInput, UserUncheckedCreateWithoutListenedAlbumsInput>
    connectOrCreate?: UserCreateOrConnectWithoutListenedAlbumsInput
    upsert?: UserUpsertWithoutListenedAlbumsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutListenedAlbumsInput, UserUpdateWithoutListenedAlbumsInput>, UserUncheckedUpdateWithoutListenedAlbumsInput>
  }

  export type AlbumUpdateOneRequiredWithoutListenedByUsersNestedInput = {
    create?: XOR<AlbumCreateWithoutListenedByUsersInput, AlbumUncheckedCreateWithoutListenedByUsersInput>
    connectOrCreate?: AlbumCreateOrConnectWithoutListenedByUsersInput
    upsert?: AlbumUpsertWithoutListenedByUsersInput
    connect?: AlbumWhereUniqueInput
    update?: XOR<XOR<AlbumUpdateToOneWithWhereWithoutListenedByUsersInput, AlbumUpdateWithoutListenedByUsersInput>, AlbumUncheckedUpdateWithoutListenedByUsersInput>
  }

  export type UserCreateNestedOneWithoutLikedAudiobooksInput = {
    create?: XOR<UserCreateWithoutLikedAudiobooksInput, UserUncheckedCreateWithoutLikedAudiobooksInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedAudiobooksInput
    connect?: UserWhereUniqueInput
  }

  export type TrackCreateNestedOneWithoutLikedAsAudiobookByUsersInput = {
    create?: XOR<TrackCreateWithoutLikedAsAudiobookByUsersInput, TrackUncheckedCreateWithoutLikedAsAudiobookByUsersInput>
    connectOrCreate?: TrackCreateOrConnectWithoutLikedAsAudiobookByUsersInput
    connect?: TrackWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLikedAudiobooksNestedInput = {
    create?: XOR<UserCreateWithoutLikedAudiobooksInput, UserUncheckedCreateWithoutLikedAudiobooksInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedAudiobooksInput
    upsert?: UserUpsertWithoutLikedAudiobooksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikedAudiobooksInput, UserUpdateWithoutLikedAudiobooksInput>, UserUncheckedUpdateWithoutLikedAudiobooksInput>
  }

  export type TrackUpdateOneRequiredWithoutLikedAsAudiobookByUsersNestedInput = {
    create?: XOR<TrackCreateWithoutLikedAsAudiobookByUsersInput, TrackUncheckedCreateWithoutLikedAsAudiobookByUsersInput>
    connectOrCreate?: TrackCreateOrConnectWithoutLikedAsAudiobookByUsersInput
    upsert?: TrackUpsertWithoutLikedAsAudiobookByUsersInput
    connect?: TrackWhereUniqueInput
    update?: XOR<XOR<TrackUpdateToOneWithWhereWithoutLikedAsAudiobookByUsersInput, TrackUpdateWithoutLikedAsAudiobookByUsersInput>, TrackUncheckedUpdateWithoutLikedAsAudiobookByUsersInput>
  }

  export type UserCreateNestedOneWithoutListenedAudiobooksInput = {
    create?: XOR<UserCreateWithoutListenedAudiobooksInput, UserUncheckedCreateWithoutListenedAudiobooksInput>
    connectOrCreate?: UserCreateOrConnectWithoutListenedAudiobooksInput
    connect?: UserWhereUniqueInput
  }

  export type TrackCreateNestedOneWithoutListenedAsAudiobookByUsersInput = {
    create?: XOR<TrackCreateWithoutListenedAsAudiobookByUsersInput, TrackUncheckedCreateWithoutListenedAsAudiobookByUsersInput>
    connectOrCreate?: TrackCreateOrConnectWithoutListenedAsAudiobookByUsersInput
    connect?: TrackWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutListenedAudiobooksNestedInput = {
    create?: XOR<UserCreateWithoutListenedAudiobooksInput, UserUncheckedCreateWithoutListenedAudiobooksInput>
    connectOrCreate?: UserCreateOrConnectWithoutListenedAudiobooksInput
    upsert?: UserUpsertWithoutListenedAudiobooksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutListenedAudiobooksInput, UserUpdateWithoutListenedAudiobooksInput>, UserUncheckedUpdateWithoutListenedAudiobooksInput>
  }

  export type TrackUpdateOneRequiredWithoutListenedAsAudiobookByUsersNestedInput = {
    create?: XOR<TrackCreateWithoutListenedAsAudiobookByUsersInput, TrackUncheckedCreateWithoutListenedAsAudiobookByUsersInput>
    connectOrCreate?: TrackCreateOrConnectWithoutListenedAsAudiobookByUsersInput
    upsert?: TrackUpsertWithoutListenedAsAudiobookByUsersInput
    connect?: TrackWhereUniqueInput
    update?: XOR<XOR<TrackUpdateToOneWithWhereWithoutListenedAsAudiobookByUsersInput, TrackUpdateWithoutListenedAsAudiobookByUsersInput>, TrackUncheckedUpdateWithoutListenedAsAudiobookByUsersInput>
  }

  export type UserTrackLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTrackLikeCreateWithoutUserInput, UserTrackLikeUncheckedCreateWithoutUserInput> | UserTrackLikeCreateWithoutUserInput[] | UserTrackLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTrackLikeCreateOrConnectWithoutUserInput | UserTrackLikeCreateOrConnectWithoutUserInput[]
    createMany?: UserTrackLikeCreateManyUserInputEnvelope
    connect?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
  }

  export type UserTrackHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTrackHistoryCreateWithoutUserInput, UserTrackHistoryUncheckedCreateWithoutUserInput> | UserTrackHistoryCreateWithoutUserInput[] | UserTrackHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTrackHistoryCreateOrConnectWithoutUserInput | UserTrackHistoryCreateOrConnectWithoutUserInput[]
    createMany?: UserTrackHistoryCreateManyUserInputEnvelope
    connect?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
  }

  export type UserAlbumLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAlbumLikeCreateWithoutUserInput, UserAlbumLikeUncheckedCreateWithoutUserInput> | UserAlbumLikeCreateWithoutUserInput[] | UserAlbumLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAlbumLikeCreateOrConnectWithoutUserInput | UserAlbumLikeCreateOrConnectWithoutUserInput[]
    createMany?: UserAlbumLikeCreateManyUserInputEnvelope
    connect?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
  }

  export type UserAlbumHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAlbumHistoryCreateWithoutUserInput, UserAlbumHistoryUncheckedCreateWithoutUserInput> | UserAlbumHistoryCreateWithoutUserInput[] | UserAlbumHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAlbumHistoryCreateOrConnectWithoutUserInput | UserAlbumHistoryCreateOrConnectWithoutUserInput[]
    createMany?: UserAlbumHistoryCreateManyUserInputEnvelope
    connect?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
  }

  export type UserAudiobookLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAudiobookLikeCreateWithoutUserInput, UserAudiobookLikeUncheckedCreateWithoutUserInput> | UserAudiobookLikeCreateWithoutUserInput[] | UserAudiobookLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAudiobookLikeCreateOrConnectWithoutUserInput | UserAudiobookLikeCreateOrConnectWithoutUserInput[]
    createMany?: UserAudiobookLikeCreateManyUserInputEnvelope
    connect?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
  }

  export type UserAudiobookHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAudiobookHistoryCreateWithoutUserInput, UserAudiobookHistoryUncheckedCreateWithoutUserInput> | UserAudiobookHistoryCreateWithoutUserInput[] | UserAudiobookHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAudiobookHistoryCreateOrConnectWithoutUserInput | UserAudiobookHistoryCreateOrConnectWithoutUserInput[]
    createMany?: UserAudiobookHistoryCreateManyUserInputEnvelope
    connect?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
  }

  export type PlaylistCreateNestedManyWithoutUserInput = {
    create?: XOR<PlaylistCreateWithoutUserInput, PlaylistUncheckedCreateWithoutUserInput> | PlaylistCreateWithoutUserInput[] | PlaylistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutUserInput | PlaylistCreateOrConnectWithoutUserInput[]
    createMany?: PlaylistCreateManyUserInputEnvelope
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
  }

  export type DeviceCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput> | DeviceCreateWithoutUserInput[] | DeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput | DeviceCreateOrConnectWithoutUserInput[]
    createMany?: DeviceCreateManyUserInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type SearchRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchRecordCreateWithoutUserInput, SearchRecordUncheckedCreateWithoutUserInput> | SearchRecordCreateWithoutUserInput[] | SearchRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchRecordCreateOrConnectWithoutUserInput | SearchRecordCreateOrConnectWithoutUserInput[]
    createMany?: SearchRecordCreateManyUserInputEnvelope
    connect?: SearchRecordWhereUniqueInput | SearchRecordWhereUniqueInput[]
  }

  export type UserTrackLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTrackLikeCreateWithoutUserInput, UserTrackLikeUncheckedCreateWithoutUserInput> | UserTrackLikeCreateWithoutUserInput[] | UserTrackLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTrackLikeCreateOrConnectWithoutUserInput | UserTrackLikeCreateOrConnectWithoutUserInput[]
    createMany?: UserTrackLikeCreateManyUserInputEnvelope
    connect?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
  }

  export type UserTrackHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTrackHistoryCreateWithoutUserInput, UserTrackHistoryUncheckedCreateWithoutUserInput> | UserTrackHistoryCreateWithoutUserInput[] | UserTrackHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTrackHistoryCreateOrConnectWithoutUserInput | UserTrackHistoryCreateOrConnectWithoutUserInput[]
    createMany?: UserTrackHistoryCreateManyUserInputEnvelope
    connect?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
  }

  export type UserAlbumLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAlbumLikeCreateWithoutUserInput, UserAlbumLikeUncheckedCreateWithoutUserInput> | UserAlbumLikeCreateWithoutUserInput[] | UserAlbumLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAlbumLikeCreateOrConnectWithoutUserInput | UserAlbumLikeCreateOrConnectWithoutUserInput[]
    createMany?: UserAlbumLikeCreateManyUserInputEnvelope
    connect?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
  }

  export type UserAlbumHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAlbumHistoryCreateWithoutUserInput, UserAlbumHistoryUncheckedCreateWithoutUserInput> | UserAlbumHistoryCreateWithoutUserInput[] | UserAlbumHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAlbumHistoryCreateOrConnectWithoutUserInput | UserAlbumHistoryCreateOrConnectWithoutUserInput[]
    createMany?: UserAlbumHistoryCreateManyUserInputEnvelope
    connect?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
  }

  export type UserAudiobookLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAudiobookLikeCreateWithoutUserInput, UserAudiobookLikeUncheckedCreateWithoutUserInput> | UserAudiobookLikeCreateWithoutUserInput[] | UserAudiobookLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAudiobookLikeCreateOrConnectWithoutUserInput | UserAudiobookLikeCreateOrConnectWithoutUserInput[]
    createMany?: UserAudiobookLikeCreateManyUserInputEnvelope
    connect?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
  }

  export type UserAudiobookHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAudiobookHistoryCreateWithoutUserInput, UserAudiobookHistoryUncheckedCreateWithoutUserInput> | UserAudiobookHistoryCreateWithoutUserInput[] | UserAudiobookHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAudiobookHistoryCreateOrConnectWithoutUserInput | UserAudiobookHistoryCreateOrConnectWithoutUserInput[]
    createMany?: UserAudiobookHistoryCreateManyUserInputEnvelope
    connect?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
  }

  export type PlaylistUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlaylistCreateWithoutUserInput, PlaylistUncheckedCreateWithoutUserInput> | PlaylistCreateWithoutUserInput[] | PlaylistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutUserInput | PlaylistCreateOrConnectWithoutUserInput[]
    createMany?: PlaylistCreateManyUserInputEnvelope
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
  }

  export type DeviceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput> | DeviceCreateWithoutUserInput[] | DeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput | DeviceCreateOrConnectWithoutUserInput[]
    createMany?: DeviceCreateManyUserInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type SearchRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchRecordCreateWithoutUserInput, SearchRecordUncheckedCreateWithoutUserInput> | SearchRecordCreateWithoutUserInput[] | SearchRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchRecordCreateOrConnectWithoutUserInput | SearchRecordCreateOrConnectWithoutUserInput[]
    createMany?: SearchRecordCreateManyUserInputEnvelope
    connect?: SearchRecordWhereUniqueInput | SearchRecordWhereUniqueInput[]
  }

  export type UserTrackLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTrackLikeCreateWithoutUserInput, UserTrackLikeUncheckedCreateWithoutUserInput> | UserTrackLikeCreateWithoutUserInput[] | UserTrackLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTrackLikeCreateOrConnectWithoutUserInput | UserTrackLikeCreateOrConnectWithoutUserInput[]
    upsert?: UserTrackLikeUpsertWithWhereUniqueWithoutUserInput | UserTrackLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTrackLikeCreateManyUserInputEnvelope
    set?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
    disconnect?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
    delete?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
    connect?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
    update?: UserTrackLikeUpdateWithWhereUniqueWithoutUserInput | UserTrackLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTrackLikeUpdateManyWithWhereWithoutUserInput | UserTrackLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTrackLikeScalarWhereInput | UserTrackLikeScalarWhereInput[]
  }

  export type UserTrackHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTrackHistoryCreateWithoutUserInput, UserTrackHistoryUncheckedCreateWithoutUserInput> | UserTrackHistoryCreateWithoutUserInput[] | UserTrackHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTrackHistoryCreateOrConnectWithoutUserInput | UserTrackHistoryCreateOrConnectWithoutUserInput[]
    upsert?: UserTrackHistoryUpsertWithWhereUniqueWithoutUserInput | UserTrackHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTrackHistoryCreateManyUserInputEnvelope
    set?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    disconnect?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    delete?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    connect?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    update?: UserTrackHistoryUpdateWithWhereUniqueWithoutUserInput | UserTrackHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTrackHistoryUpdateManyWithWhereWithoutUserInput | UserTrackHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTrackHistoryScalarWhereInput | UserTrackHistoryScalarWhereInput[]
  }

  export type UserAlbumLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAlbumLikeCreateWithoutUserInput, UserAlbumLikeUncheckedCreateWithoutUserInput> | UserAlbumLikeCreateWithoutUserInput[] | UserAlbumLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAlbumLikeCreateOrConnectWithoutUserInput | UserAlbumLikeCreateOrConnectWithoutUserInput[]
    upsert?: UserAlbumLikeUpsertWithWhereUniqueWithoutUserInput | UserAlbumLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAlbumLikeCreateManyUserInputEnvelope
    set?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
    disconnect?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
    delete?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
    connect?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
    update?: UserAlbumLikeUpdateWithWhereUniqueWithoutUserInput | UserAlbumLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAlbumLikeUpdateManyWithWhereWithoutUserInput | UserAlbumLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAlbumLikeScalarWhereInput | UserAlbumLikeScalarWhereInput[]
  }

  export type UserAlbumHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAlbumHistoryCreateWithoutUserInput, UserAlbumHistoryUncheckedCreateWithoutUserInput> | UserAlbumHistoryCreateWithoutUserInput[] | UserAlbumHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAlbumHistoryCreateOrConnectWithoutUserInput | UserAlbumHistoryCreateOrConnectWithoutUserInput[]
    upsert?: UserAlbumHistoryUpsertWithWhereUniqueWithoutUserInput | UserAlbumHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAlbumHistoryCreateManyUserInputEnvelope
    set?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
    disconnect?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
    delete?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
    connect?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
    update?: UserAlbumHistoryUpdateWithWhereUniqueWithoutUserInput | UserAlbumHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAlbumHistoryUpdateManyWithWhereWithoutUserInput | UserAlbumHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAlbumHistoryScalarWhereInput | UserAlbumHistoryScalarWhereInput[]
  }

  export type UserAudiobookLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAudiobookLikeCreateWithoutUserInput, UserAudiobookLikeUncheckedCreateWithoutUserInput> | UserAudiobookLikeCreateWithoutUserInput[] | UserAudiobookLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAudiobookLikeCreateOrConnectWithoutUserInput | UserAudiobookLikeCreateOrConnectWithoutUserInput[]
    upsert?: UserAudiobookLikeUpsertWithWhereUniqueWithoutUserInput | UserAudiobookLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAudiobookLikeCreateManyUserInputEnvelope
    set?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
    disconnect?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
    delete?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
    connect?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
    update?: UserAudiobookLikeUpdateWithWhereUniqueWithoutUserInput | UserAudiobookLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAudiobookLikeUpdateManyWithWhereWithoutUserInput | UserAudiobookLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAudiobookLikeScalarWhereInput | UserAudiobookLikeScalarWhereInput[]
  }

  export type UserAudiobookHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAudiobookHistoryCreateWithoutUserInput, UserAudiobookHistoryUncheckedCreateWithoutUserInput> | UserAudiobookHistoryCreateWithoutUserInput[] | UserAudiobookHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAudiobookHistoryCreateOrConnectWithoutUserInput | UserAudiobookHistoryCreateOrConnectWithoutUserInput[]
    upsert?: UserAudiobookHistoryUpsertWithWhereUniqueWithoutUserInput | UserAudiobookHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAudiobookHistoryCreateManyUserInputEnvelope
    set?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
    disconnect?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
    delete?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
    connect?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
    update?: UserAudiobookHistoryUpdateWithWhereUniqueWithoutUserInput | UserAudiobookHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAudiobookHistoryUpdateManyWithWhereWithoutUserInput | UserAudiobookHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAudiobookHistoryScalarWhereInput | UserAudiobookHistoryScalarWhereInput[]
  }

  export type PlaylistUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlaylistCreateWithoutUserInput, PlaylistUncheckedCreateWithoutUserInput> | PlaylistCreateWithoutUserInput[] | PlaylistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutUserInput | PlaylistCreateOrConnectWithoutUserInput[]
    upsert?: PlaylistUpsertWithWhereUniqueWithoutUserInput | PlaylistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlaylistCreateManyUserInputEnvelope
    set?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    disconnect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    delete?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    update?: PlaylistUpdateWithWhereUniqueWithoutUserInput | PlaylistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlaylistUpdateManyWithWhereWithoutUserInput | PlaylistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[]
  }

  export type DeviceUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput> | DeviceCreateWithoutUserInput[] | DeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput | DeviceCreateOrConnectWithoutUserInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutUserInput | DeviceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceCreateManyUserInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutUserInput | DeviceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutUserInput | DeviceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type SearchRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchRecordCreateWithoutUserInput, SearchRecordUncheckedCreateWithoutUserInput> | SearchRecordCreateWithoutUserInput[] | SearchRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchRecordCreateOrConnectWithoutUserInput | SearchRecordCreateOrConnectWithoutUserInput[]
    upsert?: SearchRecordUpsertWithWhereUniqueWithoutUserInput | SearchRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchRecordCreateManyUserInputEnvelope
    set?: SearchRecordWhereUniqueInput | SearchRecordWhereUniqueInput[]
    disconnect?: SearchRecordWhereUniqueInput | SearchRecordWhereUniqueInput[]
    delete?: SearchRecordWhereUniqueInput | SearchRecordWhereUniqueInput[]
    connect?: SearchRecordWhereUniqueInput | SearchRecordWhereUniqueInput[]
    update?: SearchRecordUpdateWithWhereUniqueWithoutUserInput | SearchRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchRecordUpdateManyWithWhereWithoutUserInput | SearchRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchRecordScalarWhereInput | SearchRecordScalarWhereInput[]
  }

  export type UserTrackLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTrackLikeCreateWithoutUserInput, UserTrackLikeUncheckedCreateWithoutUserInput> | UserTrackLikeCreateWithoutUserInput[] | UserTrackLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTrackLikeCreateOrConnectWithoutUserInput | UserTrackLikeCreateOrConnectWithoutUserInput[]
    upsert?: UserTrackLikeUpsertWithWhereUniqueWithoutUserInput | UserTrackLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTrackLikeCreateManyUserInputEnvelope
    set?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
    disconnect?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
    delete?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
    connect?: UserTrackLikeWhereUniqueInput | UserTrackLikeWhereUniqueInput[]
    update?: UserTrackLikeUpdateWithWhereUniqueWithoutUserInput | UserTrackLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTrackLikeUpdateManyWithWhereWithoutUserInput | UserTrackLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTrackLikeScalarWhereInput | UserTrackLikeScalarWhereInput[]
  }

  export type UserTrackHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTrackHistoryCreateWithoutUserInput, UserTrackHistoryUncheckedCreateWithoutUserInput> | UserTrackHistoryCreateWithoutUserInput[] | UserTrackHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTrackHistoryCreateOrConnectWithoutUserInput | UserTrackHistoryCreateOrConnectWithoutUserInput[]
    upsert?: UserTrackHistoryUpsertWithWhereUniqueWithoutUserInput | UserTrackHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTrackHistoryCreateManyUserInputEnvelope
    set?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    disconnect?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    delete?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    connect?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    update?: UserTrackHistoryUpdateWithWhereUniqueWithoutUserInput | UserTrackHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTrackHistoryUpdateManyWithWhereWithoutUserInput | UserTrackHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTrackHistoryScalarWhereInput | UserTrackHistoryScalarWhereInput[]
  }

  export type UserAlbumLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAlbumLikeCreateWithoutUserInput, UserAlbumLikeUncheckedCreateWithoutUserInput> | UserAlbumLikeCreateWithoutUserInput[] | UserAlbumLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAlbumLikeCreateOrConnectWithoutUserInput | UserAlbumLikeCreateOrConnectWithoutUserInput[]
    upsert?: UserAlbumLikeUpsertWithWhereUniqueWithoutUserInput | UserAlbumLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAlbumLikeCreateManyUserInputEnvelope
    set?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
    disconnect?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
    delete?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
    connect?: UserAlbumLikeWhereUniqueInput | UserAlbumLikeWhereUniqueInput[]
    update?: UserAlbumLikeUpdateWithWhereUniqueWithoutUserInput | UserAlbumLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAlbumLikeUpdateManyWithWhereWithoutUserInput | UserAlbumLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAlbumLikeScalarWhereInput | UserAlbumLikeScalarWhereInput[]
  }

  export type UserAlbumHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAlbumHistoryCreateWithoutUserInput, UserAlbumHistoryUncheckedCreateWithoutUserInput> | UserAlbumHistoryCreateWithoutUserInput[] | UserAlbumHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAlbumHistoryCreateOrConnectWithoutUserInput | UserAlbumHistoryCreateOrConnectWithoutUserInput[]
    upsert?: UserAlbumHistoryUpsertWithWhereUniqueWithoutUserInput | UserAlbumHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAlbumHistoryCreateManyUserInputEnvelope
    set?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
    disconnect?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
    delete?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
    connect?: UserAlbumHistoryWhereUniqueInput | UserAlbumHistoryWhereUniqueInput[]
    update?: UserAlbumHistoryUpdateWithWhereUniqueWithoutUserInput | UserAlbumHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAlbumHistoryUpdateManyWithWhereWithoutUserInput | UserAlbumHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAlbumHistoryScalarWhereInput | UserAlbumHistoryScalarWhereInput[]
  }

  export type UserAudiobookLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAudiobookLikeCreateWithoutUserInput, UserAudiobookLikeUncheckedCreateWithoutUserInput> | UserAudiobookLikeCreateWithoutUserInput[] | UserAudiobookLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAudiobookLikeCreateOrConnectWithoutUserInput | UserAudiobookLikeCreateOrConnectWithoutUserInput[]
    upsert?: UserAudiobookLikeUpsertWithWhereUniqueWithoutUserInput | UserAudiobookLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAudiobookLikeCreateManyUserInputEnvelope
    set?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
    disconnect?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
    delete?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
    connect?: UserAudiobookLikeWhereUniqueInput | UserAudiobookLikeWhereUniqueInput[]
    update?: UserAudiobookLikeUpdateWithWhereUniqueWithoutUserInput | UserAudiobookLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAudiobookLikeUpdateManyWithWhereWithoutUserInput | UserAudiobookLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAudiobookLikeScalarWhereInput | UserAudiobookLikeScalarWhereInput[]
  }

  export type UserAudiobookHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAudiobookHistoryCreateWithoutUserInput, UserAudiobookHistoryUncheckedCreateWithoutUserInput> | UserAudiobookHistoryCreateWithoutUserInput[] | UserAudiobookHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAudiobookHistoryCreateOrConnectWithoutUserInput | UserAudiobookHistoryCreateOrConnectWithoutUserInput[]
    upsert?: UserAudiobookHistoryUpsertWithWhereUniqueWithoutUserInput | UserAudiobookHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAudiobookHistoryCreateManyUserInputEnvelope
    set?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
    disconnect?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
    delete?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
    connect?: UserAudiobookHistoryWhereUniqueInput | UserAudiobookHistoryWhereUniqueInput[]
    update?: UserAudiobookHistoryUpdateWithWhereUniqueWithoutUserInput | UserAudiobookHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAudiobookHistoryUpdateManyWithWhereWithoutUserInput | UserAudiobookHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAudiobookHistoryScalarWhereInput | UserAudiobookHistoryScalarWhereInput[]
  }

  export type PlaylistUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlaylistCreateWithoutUserInput, PlaylistUncheckedCreateWithoutUserInput> | PlaylistCreateWithoutUserInput[] | PlaylistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutUserInput | PlaylistCreateOrConnectWithoutUserInput[]
    upsert?: PlaylistUpsertWithWhereUniqueWithoutUserInput | PlaylistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlaylistCreateManyUserInputEnvelope
    set?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    disconnect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    delete?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    update?: PlaylistUpdateWithWhereUniqueWithoutUserInput | PlaylistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlaylistUpdateManyWithWhereWithoutUserInput | PlaylistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[]
  }

  export type DeviceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput> | DeviceCreateWithoutUserInput[] | DeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput | DeviceCreateOrConnectWithoutUserInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutUserInput | DeviceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceCreateManyUserInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutUserInput | DeviceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutUserInput | DeviceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type SearchRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchRecordCreateWithoutUserInput, SearchRecordUncheckedCreateWithoutUserInput> | SearchRecordCreateWithoutUserInput[] | SearchRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchRecordCreateOrConnectWithoutUserInput | SearchRecordCreateOrConnectWithoutUserInput[]
    upsert?: SearchRecordUpsertWithWhereUniqueWithoutUserInput | SearchRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchRecordCreateManyUserInputEnvelope
    set?: SearchRecordWhereUniqueInput | SearchRecordWhereUniqueInput[]
    disconnect?: SearchRecordWhereUniqueInput | SearchRecordWhereUniqueInput[]
    delete?: SearchRecordWhereUniqueInput | SearchRecordWhereUniqueInput[]
    connect?: SearchRecordWhereUniqueInput | SearchRecordWhereUniqueInput[]
    update?: SearchRecordUpdateWithWhereUniqueWithoutUserInput | SearchRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchRecordUpdateManyWithWhereWithoutUserInput | SearchRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchRecordScalarWhereInput | SearchRecordScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSearchRecordsInput = {
    create?: XOR<UserCreateWithoutSearchRecordsInput, UserUncheckedCreateWithoutSearchRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearchRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSearchRecordsNestedInput = {
    create?: XOR<UserCreateWithoutSearchRecordsInput, UserUncheckedCreateWithoutSearchRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearchRecordsInput
    upsert?: UserUpsertWithoutSearchRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSearchRecordsInput, UserUpdateWithoutSearchRecordsInput>, UserUncheckedUpdateWithoutSearchRecordsInput>
  }

  export type UserCreateNestedOneWithoutDevicesInput = {
    create?: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevicesInput
    connect?: UserWhereUniqueInput
  }

  export type UserTrackHistoryCreateNestedManyWithoutDeviceInput = {
    create?: XOR<UserTrackHistoryCreateWithoutDeviceInput, UserTrackHistoryUncheckedCreateWithoutDeviceInput> | UserTrackHistoryCreateWithoutDeviceInput[] | UserTrackHistoryUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: UserTrackHistoryCreateOrConnectWithoutDeviceInput | UserTrackHistoryCreateOrConnectWithoutDeviceInput[]
    createMany?: UserTrackHistoryCreateManyDeviceInputEnvelope
    connect?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
  }

  export type UserTrackHistoryUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<UserTrackHistoryCreateWithoutDeviceInput, UserTrackHistoryUncheckedCreateWithoutDeviceInput> | UserTrackHistoryCreateWithoutDeviceInput[] | UserTrackHistoryUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: UserTrackHistoryCreateOrConnectWithoutDeviceInput | UserTrackHistoryCreateOrConnectWithoutDeviceInput[]
    createMany?: UserTrackHistoryCreateManyDeviceInputEnvelope
    connect?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutDevicesNestedInput = {
    create?: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevicesInput
    upsert?: UserUpsertWithoutDevicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDevicesInput, UserUpdateWithoutDevicesInput>, UserUncheckedUpdateWithoutDevicesInput>
  }

  export type UserTrackHistoryUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<UserTrackHistoryCreateWithoutDeviceInput, UserTrackHistoryUncheckedCreateWithoutDeviceInput> | UserTrackHistoryCreateWithoutDeviceInput[] | UserTrackHistoryUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: UserTrackHistoryCreateOrConnectWithoutDeviceInput | UserTrackHistoryCreateOrConnectWithoutDeviceInput[]
    upsert?: UserTrackHistoryUpsertWithWhereUniqueWithoutDeviceInput | UserTrackHistoryUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: UserTrackHistoryCreateManyDeviceInputEnvelope
    set?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    disconnect?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    delete?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    connect?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    update?: UserTrackHistoryUpdateWithWhereUniqueWithoutDeviceInput | UserTrackHistoryUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: UserTrackHistoryUpdateManyWithWhereWithoutDeviceInput | UserTrackHistoryUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: UserTrackHistoryScalarWhereInput | UserTrackHistoryScalarWhereInput[]
  }

  export type UserTrackHistoryUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<UserTrackHistoryCreateWithoutDeviceInput, UserTrackHistoryUncheckedCreateWithoutDeviceInput> | UserTrackHistoryCreateWithoutDeviceInput[] | UserTrackHistoryUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: UserTrackHistoryCreateOrConnectWithoutDeviceInput | UserTrackHistoryCreateOrConnectWithoutDeviceInput[]
    upsert?: UserTrackHistoryUpsertWithWhereUniqueWithoutDeviceInput | UserTrackHistoryUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: UserTrackHistoryCreateManyDeviceInputEnvelope
    set?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    disconnect?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    delete?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    connect?: UserTrackHistoryWhereUniqueInput | UserTrackHistoryWhereUniqueInput[]
    update?: UserTrackHistoryUpdateWithWhereUniqueWithoutDeviceInput | UserTrackHistoryUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: UserTrackHistoryUpdateManyWithWhereWithoutDeviceInput | UserTrackHistoryUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: UserTrackHistoryScalarWhereInput | UserTrackHistoryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPlaylistsInput = {
    create?: XOR<UserCreateWithoutPlaylistsInput, UserUncheckedCreateWithoutPlaylistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlaylistsInput
    connect?: UserWhereUniqueInput
  }

  export type TrackCreateNestedManyWithoutPlaylistsInput = {
    create?: XOR<TrackCreateWithoutPlaylistsInput, TrackUncheckedCreateWithoutPlaylistsInput> | TrackCreateWithoutPlaylistsInput[] | TrackUncheckedCreateWithoutPlaylistsInput[]
    connectOrCreate?: TrackCreateOrConnectWithoutPlaylistsInput | TrackCreateOrConnectWithoutPlaylistsInput[]
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
  }

  export type TrackUncheckedCreateNestedManyWithoutPlaylistsInput = {
    create?: XOR<TrackCreateWithoutPlaylistsInput, TrackUncheckedCreateWithoutPlaylistsInput> | TrackCreateWithoutPlaylistsInput[] | TrackUncheckedCreateWithoutPlaylistsInput[]
    connectOrCreate?: TrackCreateOrConnectWithoutPlaylistsInput | TrackCreateOrConnectWithoutPlaylistsInput[]
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPlaylistsNestedInput = {
    create?: XOR<UserCreateWithoutPlaylistsInput, UserUncheckedCreateWithoutPlaylistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlaylistsInput
    upsert?: UserUpsertWithoutPlaylistsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlaylistsInput, UserUpdateWithoutPlaylistsInput>, UserUncheckedUpdateWithoutPlaylistsInput>
  }

  export type TrackUpdateManyWithoutPlaylistsNestedInput = {
    create?: XOR<TrackCreateWithoutPlaylistsInput, TrackUncheckedCreateWithoutPlaylistsInput> | TrackCreateWithoutPlaylistsInput[] | TrackUncheckedCreateWithoutPlaylistsInput[]
    connectOrCreate?: TrackCreateOrConnectWithoutPlaylistsInput | TrackCreateOrConnectWithoutPlaylistsInput[]
    upsert?: TrackUpsertWithWhereUniqueWithoutPlaylistsInput | TrackUpsertWithWhereUniqueWithoutPlaylistsInput[]
    set?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    disconnect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    delete?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    update?: TrackUpdateWithWhereUniqueWithoutPlaylistsInput | TrackUpdateWithWhereUniqueWithoutPlaylistsInput[]
    updateMany?: TrackUpdateManyWithWhereWithoutPlaylistsInput | TrackUpdateManyWithWhereWithoutPlaylistsInput[]
    deleteMany?: TrackScalarWhereInput | TrackScalarWhereInput[]
  }

  export type TrackUncheckedUpdateManyWithoutPlaylistsNestedInput = {
    create?: XOR<TrackCreateWithoutPlaylistsInput, TrackUncheckedCreateWithoutPlaylistsInput> | TrackCreateWithoutPlaylistsInput[] | TrackUncheckedCreateWithoutPlaylistsInput[]
    connectOrCreate?: TrackCreateOrConnectWithoutPlaylistsInput | TrackCreateOrConnectWithoutPlaylistsInput[]
    upsert?: TrackUpsertWithWhereUniqueWithoutPlaylistsInput | TrackUpsertWithWhereUniqueWithoutPlaylistsInput[]
    set?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    disconnect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    delete?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    update?: TrackUpdateWithWhereUniqueWithoutPlaylistsInput | TrackUpdateWithWhereUniqueWithoutPlaylistsInput[]
    updateMany?: TrackUpdateManyWithWhereWithoutPlaylistsInput | TrackUpdateManyWithWhereWithoutPlaylistsInput[]
    deleteMany?: TrackScalarWhereInput | TrackScalarWhereInput[]
  }

  export type FolderCreateNestedOneWithoutChildrenInput = {
    create?: XOR<FolderCreateWithoutChildrenInput, FolderUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: FolderCreateOrConnectWithoutChildrenInput
    connect?: FolderWhereUniqueInput
  }

  export type FolderCreateNestedManyWithoutParentInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[]
    createMany?: FolderCreateManyParentInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type TrackCreateNestedManyWithoutFolderInput = {
    create?: XOR<TrackCreateWithoutFolderInput, TrackUncheckedCreateWithoutFolderInput> | TrackCreateWithoutFolderInput[] | TrackUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: TrackCreateOrConnectWithoutFolderInput | TrackCreateOrConnectWithoutFolderInput[]
    createMany?: TrackCreateManyFolderInputEnvelope
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
  }

  export type FolderUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[]
    createMany?: FolderCreateManyParentInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type TrackUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<TrackCreateWithoutFolderInput, TrackUncheckedCreateWithoutFolderInput> | TrackCreateWithoutFolderInput[] | TrackUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: TrackCreateOrConnectWithoutFolderInput | TrackCreateOrConnectWithoutFolderInput[]
    createMany?: TrackCreateManyFolderInputEnvelope
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
  }

  export type FolderUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<FolderCreateWithoutChildrenInput, FolderUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: FolderCreateOrConnectWithoutChildrenInput
    upsert?: FolderUpsertWithoutChildrenInput
    disconnect?: FolderWhereInput | boolean
    delete?: FolderWhereInput | boolean
    connect?: FolderWhereUniqueInput
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutChildrenInput, FolderUpdateWithoutChildrenInput>, FolderUncheckedUpdateWithoutChildrenInput>
  }

  export type FolderUpdateManyWithoutParentNestedInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutParentInput | FolderUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: FolderCreateManyParentInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutParentInput | FolderUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutParentInput | FolderUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type TrackUpdateManyWithoutFolderNestedInput = {
    create?: XOR<TrackCreateWithoutFolderInput, TrackUncheckedCreateWithoutFolderInput> | TrackCreateWithoutFolderInput[] | TrackUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: TrackCreateOrConnectWithoutFolderInput | TrackCreateOrConnectWithoutFolderInput[]
    upsert?: TrackUpsertWithWhereUniqueWithoutFolderInput | TrackUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: TrackCreateManyFolderInputEnvelope
    set?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    disconnect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    delete?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    update?: TrackUpdateWithWhereUniqueWithoutFolderInput | TrackUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: TrackUpdateManyWithWhereWithoutFolderInput | TrackUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: TrackScalarWhereInput | TrackScalarWhereInput[]
  }

  export type FolderUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutParentInput | FolderUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: FolderCreateManyParentInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutParentInput | FolderUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutParentInput | FolderUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type TrackUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<TrackCreateWithoutFolderInput, TrackUncheckedCreateWithoutFolderInput> | TrackCreateWithoutFolderInput[] | TrackUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: TrackCreateOrConnectWithoutFolderInput | TrackCreateOrConnectWithoutFolderInput[]
    upsert?: TrackUpsertWithWhereUniqueWithoutFolderInput | TrackUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: TrackCreateManyFolderInputEnvelope
    set?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    disconnect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    delete?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[]
    update?: TrackUpdateWithWhereUniqueWithoutFolderInput | TrackUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: TrackUpdateManyWithWhereWithoutFolderInput | TrackUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: TrackScalarWhereInput | TrackScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTrackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrackType[]
    notIn?: $Enums.TrackType[]
    not?: NestedEnumTrackTypeFilter<$PrismaModel> | $Enums.TrackType
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTrackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackType | EnumTrackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrackType[]
    notIn?: $Enums.TrackType[]
    not?: NestedEnumTrackTypeWithAggregatesFilter<$PrismaModel> | $Enums.TrackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrackTypeFilter<$PrismaModel>
    _max?: NestedEnumTrackTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ArtistCreateWithoutTracksInput = {
    name: string
    avatar?: string | null
    type?: $Enums.TrackType
  }

  export type ArtistUncheckedCreateWithoutTracksInput = {
    id?: number
    name: string
    avatar?: string | null
    type?: $Enums.TrackType
  }

  export type ArtistCreateOrConnectWithoutTracksInput = {
    where: ArtistWhereUniqueInput
    create: XOR<ArtistCreateWithoutTracksInput, ArtistUncheckedCreateWithoutTracksInput>
  }

  export type AlbumCreateWithoutTracksInput = {
    name: string
    artist: string
    cover?: string | null
    year?: string | null
    type?: $Enums.TrackType
    likedByUsers?: UserAlbumLikeCreateNestedManyWithoutAlbumInput
    listenedByUsers?: UserAlbumHistoryCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUncheckedCreateWithoutTracksInput = {
    id?: number
    name: string
    artist: string
    cover?: string | null
    year?: string | null
    type?: $Enums.TrackType
    likedByUsers?: UserAlbumLikeUncheckedCreateNestedManyWithoutAlbumInput
    listenedByUsers?: UserAlbumHistoryUncheckedCreateNestedManyWithoutAlbumInput
  }

  export type AlbumCreateOrConnectWithoutTracksInput = {
    where: AlbumWhereUniqueInput
    create: XOR<AlbumCreateWithoutTracksInput, AlbumUncheckedCreateWithoutTracksInput>
  }

  export type UserTrackLikeCreateWithoutTrackInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLikedTracksInput
  }

  export type UserTrackLikeUncheckedCreateWithoutTrackInput = {
    id?: number
    userId: number
    createdAt?: Date | string
  }

  export type UserTrackLikeCreateOrConnectWithoutTrackInput = {
    where: UserTrackLikeWhereUniqueInput
    create: XOR<UserTrackLikeCreateWithoutTrackInput, UserTrackLikeUncheckedCreateWithoutTrackInput>
  }

  export type UserTrackLikeCreateManyTrackInputEnvelope = {
    data: UserTrackLikeCreateManyTrackInput | UserTrackLikeCreateManyTrackInput[]
  }

  export type UserTrackHistoryCreateWithoutTrackInput = {
    listenedAt?: Date | string
    progress?: number
    deviceName: string
    isSyncMode?: boolean
    user: UserCreateNestedOneWithoutListenedTracksInput
    device: DeviceCreateNestedOneWithoutHistoriesInput
  }

  export type UserTrackHistoryUncheckedCreateWithoutTrackInput = {
    id?: number
    userId: number
    listenedAt?: Date | string
    progress?: number
    deviceName: string
    deviceId: number
    isSyncMode?: boolean
  }

  export type UserTrackHistoryCreateOrConnectWithoutTrackInput = {
    where: UserTrackHistoryWhereUniqueInput
    create: XOR<UserTrackHistoryCreateWithoutTrackInput, UserTrackHistoryUncheckedCreateWithoutTrackInput>
  }

  export type UserTrackHistoryCreateManyTrackInputEnvelope = {
    data: UserTrackHistoryCreateManyTrackInput | UserTrackHistoryCreateManyTrackInput[]
  }

  export type UserAudiobookLikeCreateWithoutTrackInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLikedAudiobooksInput
  }

  export type UserAudiobookLikeUncheckedCreateWithoutTrackInput = {
    id?: number
    userId: number
    createdAt?: Date | string
  }

  export type UserAudiobookLikeCreateOrConnectWithoutTrackInput = {
    where: UserAudiobookLikeWhereUniqueInput
    create: XOR<UserAudiobookLikeCreateWithoutTrackInput, UserAudiobookLikeUncheckedCreateWithoutTrackInput>
  }

  export type UserAudiobookLikeCreateManyTrackInputEnvelope = {
    data: UserAudiobookLikeCreateManyTrackInput | UserAudiobookLikeCreateManyTrackInput[]
  }

  export type UserAudiobookHistoryCreateWithoutTrackInput = {
    listenedAt?: Date | string
    progress?: number
    user: UserCreateNestedOneWithoutListenedAudiobooksInput
  }

  export type UserAudiobookHistoryUncheckedCreateWithoutTrackInput = {
    id?: number
    userId: number
    listenedAt?: Date | string
    progress?: number
  }

  export type UserAudiobookHistoryCreateOrConnectWithoutTrackInput = {
    where: UserAudiobookHistoryWhereUniqueInput
    create: XOR<UserAudiobookHistoryCreateWithoutTrackInput, UserAudiobookHistoryUncheckedCreateWithoutTrackInput>
  }

  export type UserAudiobookHistoryCreateManyTrackInputEnvelope = {
    data: UserAudiobookHistoryCreateManyTrackInput | UserAudiobookHistoryCreateManyTrackInput[]
  }

  export type PlaylistCreateWithoutTracksInput = {
    name: string
    type?: $Enums.TrackType
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlaylistsInput
  }

  export type PlaylistUncheckedCreateWithoutTracksInput = {
    id?: number
    name: string
    type?: $Enums.TrackType
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
  }

  export type PlaylistCreateOrConnectWithoutTracksInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutTracksInput, PlaylistUncheckedCreateWithoutTracksInput>
  }

  export type FolderCreateWithoutTracksInput = {
    path: string
    name: string
    type?: $Enums.TrackType
    parent?: FolderCreateNestedOneWithoutChildrenInput
    children?: FolderCreateNestedManyWithoutParentInput
  }

  export type FolderUncheckedCreateWithoutTracksInput = {
    id?: number
    path: string
    name: string
    parentId?: number | null
    type?: $Enums.TrackType
    children?: FolderUncheckedCreateNestedManyWithoutParentInput
  }

  export type FolderCreateOrConnectWithoutTracksInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutTracksInput, FolderUncheckedCreateWithoutTracksInput>
  }

  export type ArtistUpsertWithoutTracksInput = {
    update: XOR<ArtistUpdateWithoutTracksInput, ArtistUncheckedUpdateWithoutTracksInput>
    create: XOR<ArtistCreateWithoutTracksInput, ArtistUncheckedCreateWithoutTracksInput>
    where?: ArtistWhereInput
  }

  export type ArtistUpdateToOneWithWhereWithoutTracksInput = {
    where?: ArtistWhereInput
    data: XOR<ArtistUpdateWithoutTracksInput, ArtistUncheckedUpdateWithoutTracksInput>
  }

  export type ArtistUpdateWithoutTracksInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
  }

  export type ArtistUncheckedUpdateWithoutTracksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
  }

  export type AlbumUpsertWithoutTracksInput = {
    update: XOR<AlbumUpdateWithoutTracksInput, AlbumUncheckedUpdateWithoutTracksInput>
    create: XOR<AlbumCreateWithoutTracksInput, AlbumUncheckedCreateWithoutTracksInput>
    where?: AlbumWhereInput
  }

  export type AlbumUpdateToOneWithWhereWithoutTracksInput = {
    where?: AlbumWhereInput
    data: XOR<AlbumUpdateWithoutTracksInput, AlbumUncheckedUpdateWithoutTracksInput>
  }

  export type AlbumUpdateWithoutTracksInput = {
    name?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    likedByUsers?: UserAlbumLikeUpdateManyWithoutAlbumNestedInput
    listenedByUsers?: UserAlbumHistoryUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumUncheckedUpdateWithoutTracksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    likedByUsers?: UserAlbumLikeUncheckedUpdateManyWithoutAlbumNestedInput
    listenedByUsers?: UserAlbumHistoryUncheckedUpdateManyWithoutAlbumNestedInput
  }

  export type UserTrackLikeUpsertWithWhereUniqueWithoutTrackInput = {
    where: UserTrackLikeWhereUniqueInput
    update: XOR<UserTrackLikeUpdateWithoutTrackInput, UserTrackLikeUncheckedUpdateWithoutTrackInput>
    create: XOR<UserTrackLikeCreateWithoutTrackInput, UserTrackLikeUncheckedCreateWithoutTrackInput>
  }

  export type UserTrackLikeUpdateWithWhereUniqueWithoutTrackInput = {
    where: UserTrackLikeWhereUniqueInput
    data: XOR<UserTrackLikeUpdateWithoutTrackInput, UserTrackLikeUncheckedUpdateWithoutTrackInput>
  }

  export type UserTrackLikeUpdateManyWithWhereWithoutTrackInput = {
    where: UserTrackLikeScalarWhereInput
    data: XOR<UserTrackLikeUpdateManyMutationInput, UserTrackLikeUncheckedUpdateManyWithoutTrackInput>
  }

  export type UserTrackLikeScalarWhereInput = {
    AND?: UserTrackLikeScalarWhereInput | UserTrackLikeScalarWhereInput[]
    OR?: UserTrackLikeScalarWhereInput[]
    NOT?: UserTrackLikeScalarWhereInput | UserTrackLikeScalarWhereInput[]
    id?: IntFilter<"UserTrackLike"> | number
    userId?: IntFilter<"UserTrackLike"> | number
    trackId?: IntFilter<"UserTrackLike"> | number
    createdAt?: DateTimeFilter<"UserTrackLike"> | Date | string
  }

  export type UserTrackHistoryUpsertWithWhereUniqueWithoutTrackInput = {
    where: UserTrackHistoryWhereUniqueInput
    update: XOR<UserTrackHistoryUpdateWithoutTrackInput, UserTrackHistoryUncheckedUpdateWithoutTrackInput>
    create: XOR<UserTrackHistoryCreateWithoutTrackInput, UserTrackHistoryUncheckedCreateWithoutTrackInput>
  }

  export type UserTrackHistoryUpdateWithWhereUniqueWithoutTrackInput = {
    where: UserTrackHistoryWhereUniqueInput
    data: XOR<UserTrackHistoryUpdateWithoutTrackInput, UserTrackHistoryUncheckedUpdateWithoutTrackInput>
  }

  export type UserTrackHistoryUpdateManyWithWhereWithoutTrackInput = {
    where: UserTrackHistoryScalarWhereInput
    data: XOR<UserTrackHistoryUpdateManyMutationInput, UserTrackHistoryUncheckedUpdateManyWithoutTrackInput>
  }

  export type UserTrackHistoryScalarWhereInput = {
    AND?: UserTrackHistoryScalarWhereInput | UserTrackHistoryScalarWhereInput[]
    OR?: UserTrackHistoryScalarWhereInput[]
    NOT?: UserTrackHistoryScalarWhereInput | UserTrackHistoryScalarWhereInput[]
    id?: IntFilter<"UserTrackHistory"> | number
    userId?: IntFilter<"UserTrackHistory"> | number
    trackId?: IntFilter<"UserTrackHistory"> | number
    listenedAt?: DateTimeFilter<"UserTrackHistory"> | Date | string
    progress?: IntFilter<"UserTrackHistory"> | number
    deviceName?: StringFilter<"UserTrackHistory"> | string
    deviceId?: IntFilter<"UserTrackHistory"> | number
    isSyncMode?: BoolFilter<"UserTrackHistory"> | boolean
  }

  export type UserAudiobookLikeUpsertWithWhereUniqueWithoutTrackInput = {
    where: UserAudiobookLikeWhereUniqueInput
    update: XOR<UserAudiobookLikeUpdateWithoutTrackInput, UserAudiobookLikeUncheckedUpdateWithoutTrackInput>
    create: XOR<UserAudiobookLikeCreateWithoutTrackInput, UserAudiobookLikeUncheckedCreateWithoutTrackInput>
  }

  export type UserAudiobookLikeUpdateWithWhereUniqueWithoutTrackInput = {
    where: UserAudiobookLikeWhereUniqueInput
    data: XOR<UserAudiobookLikeUpdateWithoutTrackInput, UserAudiobookLikeUncheckedUpdateWithoutTrackInput>
  }

  export type UserAudiobookLikeUpdateManyWithWhereWithoutTrackInput = {
    where: UserAudiobookLikeScalarWhereInput
    data: XOR<UserAudiobookLikeUpdateManyMutationInput, UserAudiobookLikeUncheckedUpdateManyWithoutTrackInput>
  }

  export type UserAudiobookLikeScalarWhereInput = {
    AND?: UserAudiobookLikeScalarWhereInput | UserAudiobookLikeScalarWhereInput[]
    OR?: UserAudiobookLikeScalarWhereInput[]
    NOT?: UserAudiobookLikeScalarWhereInput | UserAudiobookLikeScalarWhereInput[]
    id?: IntFilter<"UserAudiobookLike"> | number
    userId?: IntFilter<"UserAudiobookLike"> | number
    trackId?: IntFilter<"UserAudiobookLike"> | number
    createdAt?: DateTimeFilter<"UserAudiobookLike"> | Date | string
  }

  export type UserAudiobookHistoryUpsertWithWhereUniqueWithoutTrackInput = {
    where: UserAudiobookHistoryWhereUniqueInput
    update: XOR<UserAudiobookHistoryUpdateWithoutTrackInput, UserAudiobookHistoryUncheckedUpdateWithoutTrackInput>
    create: XOR<UserAudiobookHistoryCreateWithoutTrackInput, UserAudiobookHistoryUncheckedCreateWithoutTrackInput>
  }

  export type UserAudiobookHistoryUpdateWithWhereUniqueWithoutTrackInput = {
    where: UserAudiobookHistoryWhereUniqueInput
    data: XOR<UserAudiobookHistoryUpdateWithoutTrackInput, UserAudiobookHistoryUncheckedUpdateWithoutTrackInput>
  }

  export type UserAudiobookHistoryUpdateManyWithWhereWithoutTrackInput = {
    where: UserAudiobookHistoryScalarWhereInput
    data: XOR<UserAudiobookHistoryUpdateManyMutationInput, UserAudiobookHistoryUncheckedUpdateManyWithoutTrackInput>
  }

  export type UserAudiobookHistoryScalarWhereInput = {
    AND?: UserAudiobookHistoryScalarWhereInput | UserAudiobookHistoryScalarWhereInput[]
    OR?: UserAudiobookHistoryScalarWhereInput[]
    NOT?: UserAudiobookHistoryScalarWhereInput | UserAudiobookHistoryScalarWhereInput[]
    id?: IntFilter<"UserAudiobookHistory"> | number
    userId?: IntFilter<"UserAudiobookHistory"> | number
    trackId?: IntFilter<"UserAudiobookHistory"> | number
    listenedAt?: DateTimeFilter<"UserAudiobookHistory"> | Date | string
    progress?: IntFilter<"UserAudiobookHistory"> | number
  }

  export type PlaylistUpsertWithWhereUniqueWithoutTracksInput = {
    where: PlaylistWhereUniqueInput
    update: XOR<PlaylistUpdateWithoutTracksInput, PlaylistUncheckedUpdateWithoutTracksInput>
    create: XOR<PlaylistCreateWithoutTracksInput, PlaylistUncheckedCreateWithoutTracksInput>
  }

  export type PlaylistUpdateWithWhereUniqueWithoutTracksInput = {
    where: PlaylistWhereUniqueInput
    data: XOR<PlaylistUpdateWithoutTracksInput, PlaylistUncheckedUpdateWithoutTracksInput>
  }

  export type PlaylistUpdateManyWithWhereWithoutTracksInput = {
    where: PlaylistScalarWhereInput
    data: XOR<PlaylistUpdateManyMutationInput, PlaylistUncheckedUpdateManyWithoutTracksInput>
  }

  export type PlaylistScalarWhereInput = {
    AND?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[]
    OR?: PlaylistScalarWhereInput[]
    NOT?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[]
    id?: IntFilter<"Playlist"> | number
    name?: StringFilter<"Playlist"> | string
    type?: EnumTrackTypeFilter<"Playlist"> | $Enums.TrackType
    createdAt?: DateTimeFilter<"Playlist"> | Date | string
    updatedAt?: DateTimeFilter<"Playlist"> | Date | string
    userId?: IntFilter<"Playlist"> | number
  }

  export type FolderUpsertWithoutTracksInput = {
    update: XOR<FolderUpdateWithoutTracksInput, FolderUncheckedUpdateWithoutTracksInput>
    create: XOR<FolderCreateWithoutTracksInput, FolderUncheckedCreateWithoutTracksInput>
    where?: FolderWhereInput
  }

  export type FolderUpdateToOneWithWhereWithoutTracksInput = {
    where?: FolderWhereInput
    data: XOR<FolderUpdateWithoutTracksInput, FolderUncheckedUpdateWithoutTracksInput>
  }

  export type FolderUpdateWithoutTracksInput = {
    path?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    parent?: FolderUpdateOneWithoutChildrenNestedInput
    children?: FolderUpdateManyWithoutParentNestedInput
  }

  export type FolderUncheckedUpdateWithoutTracksInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    children?: FolderUncheckedUpdateManyWithoutParentNestedInput
  }

  export type TrackCreateWithoutAlbumEntityInput = {
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistEntity?: ArtistCreateNestedOneWithoutTracksInput
    likedByUsers?: UserTrackLikeCreateNestedManyWithoutTrackInput
    listenedByUsers?: UserTrackHistoryCreateNestedManyWithoutTrackInput
    likedAsAudiobookByUsers?: UserAudiobookLikeCreateNestedManyWithoutTrackInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryCreateNestedManyWithoutTrackInput
    playlists?: PlaylistCreateNestedManyWithoutTracksInput
    folder?: FolderCreateNestedOneWithoutTracksInput
  }

  export type TrackUncheckedCreateWithoutAlbumEntityInput = {
    id?: number
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistId?: number | null
    folderId?: number | null
    likedByUsers?: UserTrackLikeUncheckedCreateNestedManyWithoutTrackInput
    listenedByUsers?: UserTrackHistoryUncheckedCreateNestedManyWithoutTrackInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUncheckedCreateNestedManyWithoutTrackInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUncheckedCreateNestedManyWithoutTrackInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutTracksInput
  }

  export type TrackCreateOrConnectWithoutAlbumEntityInput = {
    where: TrackWhereUniqueInput
    create: XOR<TrackCreateWithoutAlbumEntityInput, TrackUncheckedCreateWithoutAlbumEntityInput>
  }

  export type TrackCreateManyAlbumEntityInputEnvelope = {
    data: TrackCreateManyAlbumEntityInput | TrackCreateManyAlbumEntityInput[]
  }

  export type UserAlbumLikeCreateWithoutAlbumInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLikedAlbumsInput
  }

  export type UserAlbumLikeUncheckedCreateWithoutAlbumInput = {
    id?: number
    userId: number
    createdAt?: Date | string
  }

  export type UserAlbumLikeCreateOrConnectWithoutAlbumInput = {
    where: UserAlbumLikeWhereUniqueInput
    create: XOR<UserAlbumLikeCreateWithoutAlbumInput, UserAlbumLikeUncheckedCreateWithoutAlbumInput>
  }

  export type UserAlbumLikeCreateManyAlbumInputEnvelope = {
    data: UserAlbumLikeCreateManyAlbumInput | UserAlbumLikeCreateManyAlbumInput[]
  }

  export type UserAlbumHistoryCreateWithoutAlbumInput = {
    listenedAt?: Date | string
    user: UserCreateNestedOneWithoutListenedAlbumsInput
  }

  export type UserAlbumHistoryUncheckedCreateWithoutAlbumInput = {
    id?: number
    userId: number
    listenedAt?: Date | string
  }

  export type UserAlbumHistoryCreateOrConnectWithoutAlbumInput = {
    where: UserAlbumHistoryWhereUniqueInput
    create: XOR<UserAlbumHistoryCreateWithoutAlbumInput, UserAlbumHistoryUncheckedCreateWithoutAlbumInput>
  }

  export type UserAlbumHistoryCreateManyAlbumInputEnvelope = {
    data: UserAlbumHistoryCreateManyAlbumInput | UserAlbumHistoryCreateManyAlbumInput[]
  }

  export type TrackUpsertWithWhereUniqueWithoutAlbumEntityInput = {
    where: TrackWhereUniqueInput
    update: XOR<TrackUpdateWithoutAlbumEntityInput, TrackUncheckedUpdateWithoutAlbumEntityInput>
    create: XOR<TrackCreateWithoutAlbumEntityInput, TrackUncheckedCreateWithoutAlbumEntityInput>
  }

  export type TrackUpdateWithWhereUniqueWithoutAlbumEntityInput = {
    where: TrackWhereUniqueInput
    data: XOR<TrackUpdateWithoutAlbumEntityInput, TrackUncheckedUpdateWithoutAlbumEntityInput>
  }

  export type TrackUpdateManyWithWhereWithoutAlbumEntityInput = {
    where: TrackScalarWhereInput
    data: XOR<TrackUpdateManyMutationInput, TrackUncheckedUpdateManyWithoutAlbumEntityInput>
  }

  export type TrackScalarWhereInput = {
    AND?: TrackScalarWhereInput | TrackScalarWhereInput[]
    OR?: TrackScalarWhereInput[]
    NOT?: TrackScalarWhereInput | TrackScalarWhereInput[]
    id?: IntFilter<"Track"> | number
    name?: StringFilter<"Track"> | string
    path?: StringFilter<"Track"> | string
    artist?: StringFilter<"Track"> | string
    album?: StringFilter<"Track"> | string
    cover?: StringNullableFilter<"Track"> | string | null
    duration?: IntNullableFilter<"Track"> | number | null
    lyrics?: StringNullableFilter<"Track"> | string | null
    index?: IntNullableFilter<"Track"> | number | null
    type?: EnumTrackTypeFilter<"Track"> | $Enums.TrackType
    createdAt?: DateTimeFilter<"Track"> | Date | string
    fileModifiedAt?: DateTimeNullableFilter<"Track"> | Date | string | null
    episodeNumber?: IntNullableFilter<"Track"> | number | null
    artistId?: IntNullableFilter<"Track"> | number | null
    albumId?: IntNullableFilter<"Track"> | number | null
    folderId?: IntNullableFilter<"Track"> | number | null
  }

  export type UserAlbumLikeUpsertWithWhereUniqueWithoutAlbumInput = {
    where: UserAlbumLikeWhereUniqueInput
    update: XOR<UserAlbumLikeUpdateWithoutAlbumInput, UserAlbumLikeUncheckedUpdateWithoutAlbumInput>
    create: XOR<UserAlbumLikeCreateWithoutAlbumInput, UserAlbumLikeUncheckedCreateWithoutAlbumInput>
  }

  export type UserAlbumLikeUpdateWithWhereUniqueWithoutAlbumInput = {
    where: UserAlbumLikeWhereUniqueInput
    data: XOR<UserAlbumLikeUpdateWithoutAlbumInput, UserAlbumLikeUncheckedUpdateWithoutAlbumInput>
  }

  export type UserAlbumLikeUpdateManyWithWhereWithoutAlbumInput = {
    where: UserAlbumLikeScalarWhereInput
    data: XOR<UserAlbumLikeUpdateManyMutationInput, UserAlbumLikeUncheckedUpdateManyWithoutAlbumInput>
  }

  export type UserAlbumLikeScalarWhereInput = {
    AND?: UserAlbumLikeScalarWhereInput | UserAlbumLikeScalarWhereInput[]
    OR?: UserAlbumLikeScalarWhereInput[]
    NOT?: UserAlbumLikeScalarWhereInput | UserAlbumLikeScalarWhereInput[]
    id?: IntFilter<"UserAlbumLike"> | number
    userId?: IntFilter<"UserAlbumLike"> | number
    albumId?: IntFilter<"UserAlbumLike"> | number
    createdAt?: DateTimeFilter<"UserAlbumLike"> | Date | string
  }

  export type UserAlbumHistoryUpsertWithWhereUniqueWithoutAlbumInput = {
    where: UserAlbumHistoryWhereUniqueInput
    update: XOR<UserAlbumHistoryUpdateWithoutAlbumInput, UserAlbumHistoryUncheckedUpdateWithoutAlbumInput>
    create: XOR<UserAlbumHistoryCreateWithoutAlbumInput, UserAlbumHistoryUncheckedCreateWithoutAlbumInput>
  }

  export type UserAlbumHistoryUpdateWithWhereUniqueWithoutAlbumInput = {
    where: UserAlbumHistoryWhereUniqueInput
    data: XOR<UserAlbumHistoryUpdateWithoutAlbumInput, UserAlbumHistoryUncheckedUpdateWithoutAlbumInput>
  }

  export type UserAlbumHistoryUpdateManyWithWhereWithoutAlbumInput = {
    where: UserAlbumHistoryScalarWhereInput
    data: XOR<UserAlbumHistoryUpdateManyMutationInput, UserAlbumHistoryUncheckedUpdateManyWithoutAlbumInput>
  }

  export type UserAlbumHistoryScalarWhereInput = {
    AND?: UserAlbumHistoryScalarWhereInput | UserAlbumHistoryScalarWhereInput[]
    OR?: UserAlbumHistoryScalarWhereInput[]
    NOT?: UserAlbumHistoryScalarWhereInput | UserAlbumHistoryScalarWhereInput[]
    id?: IntFilter<"UserAlbumHistory"> | number
    userId?: IntFilter<"UserAlbumHistory"> | number
    albumId?: IntFilter<"UserAlbumHistory"> | number
    listenedAt?: DateTimeFilter<"UserAlbumHistory"> | Date | string
  }

  export type TrackCreateWithoutArtistEntityInput = {
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    albumEntity?: AlbumCreateNestedOneWithoutTracksInput
    likedByUsers?: UserTrackLikeCreateNestedManyWithoutTrackInput
    listenedByUsers?: UserTrackHistoryCreateNestedManyWithoutTrackInput
    likedAsAudiobookByUsers?: UserAudiobookLikeCreateNestedManyWithoutTrackInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryCreateNestedManyWithoutTrackInput
    playlists?: PlaylistCreateNestedManyWithoutTracksInput
    folder?: FolderCreateNestedOneWithoutTracksInput
  }

  export type TrackUncheckedCreateWithoutArtistEntityInput = {
    id?: number
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    albumId?: number | null
    folderId?: number | null
    likedByUsers?: UserTrackLikeUncheckedCreateNestedManyWithoutTrackInput
    listenedByUsers?: UserTrackHistoryUncheckedCreateNestedManyWithoutTrackInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUncheckedCreateNestedManyWithoutTrackInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUncheckedCreateNestedManyWithoutTrackInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutTracksInput
  }

  export type TrackCreateOrConnectWithoutArtistEntityInput = {
    where: TrackWhereUniqueInput
    create: XOR<TrackCreateWithoutArtistEntityInput, TrackUncheckedCreateWithoutArtistEntityInput>
  }

  export type TrackCreateManyArtistEntityInputEnvelope = {
    data: TrackCreateManyArtistEntityInput | TrackCreateManyArtistEntityInput[]
  }

  export type TrackUpsertWithWhereUniqueWithoutArtistEntityInput = {
    where: TrackWhereUniqueInput
    update: XOR<TrackUpdateWithoutArtistEntityInput, TrackUncheckedUpdateWithoutArtistEntityInput>
    create: XOR<TrackCreateWithoutArtistEntityInput, TrackUncheckedCreateWithoutArtistEntityInput>
  }

  export type TrackUpdateWithWhereUniqueWithoutArtistEntityInput = {
    where: TrackWhereUniqueInput
    data: XOR<TrackUpdateWithoutArtistEntityInput, TrackUncheckedUpdateWithoutArtistEntityInput>
  }

  export type TrackUpdateManyWithWhereWithoutArtistEntityInput = {
    where: TrackScalarWhereInput
    data: XOR<TrackUpdateManyMutationInput, TrackUncheckedUpdateManyWithoutArtistEntityInput>
  }

  export type UserCreateWithoutLikedTracksInput = {
    username: string
    password: string
    is_admin?: boolean
    listenedTracks?: UserTrackHistoryCreateNestedManyWithoutUserInput
    likedAlbums?: UserAlbumLikeCreateNestedManyWithoutUserInput
    listenedAlbums?: UserAlbumHistoryCreateNestedManyWithoutUserInput
    likedAudiobooks?: UserAudiobookLikeCreateNestedManyWithoutUserInput
    listenedAudiobooks?: UserAudiobookHistoryCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    searchRecords?: SearchRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLikedTracksInput = {
    id?: number
    username: string
    password: string
    is_admin?: boolean
    listenedTracks?: UserTrackHistoryUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserAlbumLikeUncheckedCreateNestedManyWithoutUserInput
    listenedAlbums?: UserAlbumHistoryUncheckedCreateNestedManyWithoutUserInput
    likedAudiobooks?: UserAudiobookLikeUncheckedCreateNestedManyWithoutUserInput
    listenedAudiobooks?: UserAudiobookHistoryUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    searchRecords?: SearchRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLikedTracksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikedTracksInput, UserUncheckedCreateWithoutLikedTracksInput>
  }

  export type TrackCreateWithoutLikedByUsersInput = {
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistEntity?: ArtistCreateNestedOneWithoutTracksInput
    albumEntity?: AlbumCreateNestedOneWithoutTracksInput
    listenedByUsers?: UserTrackHistoryCreateNestedManyWithoutTrackInput
    likedAsAudiobookByUsers?: UserAudiobookLikeCreateNestedManyWithoutTrackInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryCreateNestedManyWithoutTrackInput
    playlists?: PlaylistCreateNestedManyWithoutTracksInput
    folder?: FolderCreateNestedOneWithoutTracksInput
  }

  export type TrackUncheckedCreateWithoutLikedByUsersInput = {
    id?: number
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistId?: number | null
    albumId?: number | null
    folderId?: number | null
    listenedByUsers?: UserTrackHistoryUncheckedCreateNestedManyWithoutTrackInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUncheckedCreateNestedManyWithoutTrackInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUncheckedCreateNestedManyWithoutTrackInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutTracksInput
  }

  export type TrackCreateOrConnectWithoutLikedByUsersInput = {
    where: TrackWhereUniqueInput
    create: XOR<TrackCreateWithoutLikedByUsersInput, TrackUncheckedCreateWithoutLikedByUsersInput>
  }

  export type UserUpsertWithoutLikedTracksInput = {
    update: XOR<UserUpdateWithoutLikedTracksInput, UserUncheckedUpdateWithoutLikedTracksInput>
    create: XOR<UserCreateWithoutLikedTracksInput, UserUncheckedCreateWithoutLikedTracksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikedTracksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikedTracksInput, UserUncheckedUpdateWithoutLikedTracksInput>
  }

  export type UserUpdateWithoutLikedTracksInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    listenedTracks?: UserTrackHistoryUpdateManyWithoutUserNestedInput
    likedAlbums?: UserAlbumLikeUpdateManyWithoutUserNestedInput
    listenedAlbums?: UserAlbumHistoryUpdateManyWithoutUserNestedInput
    likedAudiobooks?: UserAudiobookLikeUpdateManyWithoutUserNestedInput
    listenedAudiobooks?: UserAudiobookHistoryUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    searchRecords?: SearchRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLikedTracksInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    listenedTracks?: UserTrackHistoryUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserAlbumLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedAlbums?: UserAlbumHistoryUncheckedUpdateManyWithoutUserNestedInput
    likedAudiobooks?: UserAudiobookLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedAudiobooks?: UserAudiobookHistoryUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    searchRecords?: SearchRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TrackUpsertWithoutLikedByUsersInput = {
    update: XOR<TrackUpdateWithoutLikedByUsersInput, TrackUncheckedUpdateWithoutLikedByUsersInput>
    create: XOR<TrackCreateWithoutLikedByUsersInput, TrackUncheckedCreateWithoutLikedByUsersInput>
    where?: TrackWhereInput
  }

  export type TrackUpdateToOneWithWhereWithoutLikedByUsersInput = {
    where?: TrackWhereInput
    data: XOR<TrackUpdateWithoutLikedByUsersInput, TrackUncheckedUpdateWithoutLikedByUsersInput>
  }

  export type TrackUpdateWithoutLikedByUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistEntity?: ArtistUpdateOneWithoutTracksNestedInput
    albumEntity?: AlbumUpdateOneWithoutTracksNestedInput
    listenedByUsers?: UserTrackHistoryUpdateManyWithoutTrackNestedInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUpdateManyWithoutTrackNestedInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUpdateManyWithoutTrackNestedInput
    playlists?: PlaylistUpdateManyWithoutTracksNestedInput
    folder?: FolderUpdateOneWithoutTracksNestedInput
  }

  export type TrackUncheckedUpdateWithoutLikedByUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistId?: NullableIntFieldUpdateOperationsInput | number | null
    albumId?: NullableIntFieldUpdateOperationsInput | number | null
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    listenedByUsers?: UserTrackHistoryUncheckedUpdateManyWithoutTrackNestedInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUncheckedUpdateManyWithoutTrackNestedInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUncheckedUpdateManyWithoutTrackNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutTracksNestedInput
  }

  export type UserCreateWithoutListenedTracksInput = {
    username: string
    password: string
    is_admin?: boolean
    likedTracks?: UserTrackLikeCreateNestedManyWithoutUserInput
    likedAlbums?: UserAlbumLikeCreateNestedManyWithoutUserInput
    listenedAlbums?: UserAlbumHistoryCreateNestedManyWithoutUserInput
    likedAudiobooks?: UserAudiobookLikeCreateNestedManyWithoutUserInput
    listenedAudiobooks?: UserAudiobookHistoryCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    searchRecords?: SearchRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutListenedTracksInput = {
    id?: number
    username: string
    password: string
    is_admin?: boolean
    likedTracks?: UserTrackLikeUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserAlbumLikeUncheckedCreateNestedManyWithoutUserInput
    listenedAlbums?: UserAlbumHistoryUncheckedCreateNestedManyWithoutUserInput
    likedAudiobooks?: UserAudiobookLikeUncheckedCreateNestedManyWithoutUserInput
    listenedAudiobooks?: UserAudiobookHistoryUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    searchRecords?: SearchRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutListenedTracksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutListenedTracksInput, UserUncheckedCreateWithoutListenedTracksInput>
  }

  export type TrackCreateWithoutListenedByUsersInput = {
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistEntity?: ArtistCreateNestedOneWithoutTracksInput
    albumEntity?: AlbumCreateNestedOneWithoutTracksInput
    likedByUsers?: UserTrackLikeCreateNestedManyWithoutTrackInput
    likedAsAudiobookByUsers?: UserAudiobookLikeCreateNestedManyWithoutTrackInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryCreateNestedManyWithoutTrackInput
    playlists?: PlaylistCreateNestedManyWithoutTracksInput
    folder?: FolderCreateNestedOneWithoutTracksInput
  }

  export type TrackUncheckedCreateWithoutListenedByUsersInput = {
    id?: number
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistId?: number | null
    albumId?: number | null
    folderId?: number | null
    likedByUsers?: UserTrackLikeUncheckedCreateNestedManyWithoutTrackInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUncheckedCreateNestedManyWithoutTrackInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUncheckedCreateNestedManyWithoutTrackInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutTracksInput
  }

  export type TrackCreateOrConnectWithoutListenedByUsersInput = {
    where: TrackWhereUniqueInput
    create: XOR<TrackCreateWithoutListenedByUsersInput, TrackUncheckedCreateWithoutListenedByUsersInput>
  }

  export type DeviceCreateWithoutHistoriesInput = {
    name: string
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDevicesInput
  }

  export type DeviceUncheckedCreateWithoutHistoriesInput = {
    id?: number
    name: string
    userId: number
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceCreateOrConnectWithoutHistoriesInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutHistoriesInput, DeviceUncheckedCreateWithoutHistoriesInput>
  }

  export type UserUpsertWithoutListenedTracksInput = {
    update: XOR<UserUpdateWithoutListenedTracksInput, UserUncheckedUpdateWithoutListenedTracksInput>
    create: XOR<UserCreateWithoutListenedTracksInput, UserUncheckedCreateWithoutListenedTracksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutListenedTracksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutListenedTracksInput, UserUncheckedUpdateWithoutListenedTracksInput>
  }

  export type UserUpdateWithoutListenedTracksInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    likedTracks?: UserTrackLikeUpdateManyWithoutUserNestedInput
    likedAlbums?: UserAlbumLikeUpdateManyWithoutUserNestedInput
    listenedAlbums?: UserAlbumHistoryUpdateManyWithoutUserNestedInput
    likedAudiobooks?: UserAudiobookLikeUpdateManyWithoutUserNestedInput
    listenedAudiobooks?: UserAudiobookHistoryUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    searchRecords?: SearchRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutListenedTracksInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    likedTracks?: UserTrackLikeUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserAlbumLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedAlbums?: UserAlbumHistoryUncheckedUpdateManyWithoutUserNestedInput
    likedAudiobooks?: UserAudiobookLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedAudiobooks?: UserAudiobookHistoryUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    searchRecords?: SearchRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TrackUpsertWithoutListenedByUsersInput = {
    update: XOR<TrackUpdateWithoutListenedByUsersInput, TrackUncheckedUpdateWithoutListenedByUsersInput>
    create: XOR<TrackCreateWithoutListenedByUsersInput, TrackUncheckedCreateWithoutListenedByUsersInput>
    where?: TrackWhereInput
  }

  export type TrackUpdateToOneWithWhereWithoutListenedByUsersInput = {
    where?: TrackWhereInput
    data: XOR<TrackUpdateWithoutListenedByUsersInput, TrackUncheckedUpdateWithoutListenedByUsersInput>
  }

  export type TrackUpdateWithoutListenedByUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistEntity?: ArtistUpdateOneWithoutTracksNestedInput
    albumEntity?: AlbumUpdateOneWithoutTracksNestedInput
    likedByUsers?: UserTrackLikeUpdateManyWithoutTrackNestedInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUpdateManyWithoutTrackNestedInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUpdateManyWithoutTrackNestedInput
    playlists?: PlaylistUpdateManyWithoutTracksNestedInput
    folder?: FolderUpdateOneWithoutTracksNestedInput
  }

  export type TrackUncheckedUpdateWithoutListenedByUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistId?: NullableIntFieldUpdateOperationsInput | number | null
    albumId?: NullableIntFieldUpdateOperationsInput | number | null
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    likedByUsers?: UserTrackLikeUncheckedUpdateManyWithoutTrackNestedInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUncheckedUpdateManyWithoutTrackNestedInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUncheckedUpdateManyWithoutTrackNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutTracksNestedInput
  }

  export type DeviceUpsertWithoutHistoriesInput = {
    update: XOR<DeviceUpdateWithoutHistoriesInput, DeviceUncheckedUpdateWithoutHistoriesInput>
    create: XOR<DeviceCreateWithoutHistoriesInput, DeviceUncheckedCreateWithoutHistoriesInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutHistoriesInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutHistoriesInput, DeviceUncheckedUpdateWithoutHistoriesInput>
  }

  export type DeviceUpdateWithoutHistoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDevicesNestedInput
  }

  export type DeviceUncheckedUpdateWithoutHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutLikedAlbumsInput = {
    username: string
    password: string
    is_admin?: boolean
    likedTracks?: UserTrackLikeCreateNestedManyWithoutUserInput
    listenedTracks?: UserTrackHistoryCreateNestedManyWithoutUserInput
    listenedAlbums?: UserAlbumHistoryCreateNestedManyWithoutUserInput
    likedAudiobooks?: UserAudiobookLikeCreateNestedManyWithoutUserInput
    listenedAudiobooks?: UserAudiobookHistoryCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    searchRecords?: SearchRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLikedAlbumsInput = {
    id?: number
    username: string
    password: string
    is_admin?: boolean
    likedTracks?: UserTrackLikeUncheckedCreateNestedManyWithoutUserInput
    listenedTracks?: UserTrackHistoryUncheckedCreateNestedManyWithoutUserInput
    listenedAlbums?: UserAlbumHistoryUncheckedCreateNestedManyWithoutUserInput
    likedAudiobooks?: UserAudiobookLikeUncheckedCreateNestedManyWithoutUserInput
    listenedAudiobooks?: UserAudiobookHistoryUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    searchRecords?: SearchRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLikedAlbumsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikedAlbumsInput, UserUncheckedCreateWithoutLikedAlbumsInput>
  }

  export type AlbumCreateWithoutLikedByUsersInput = {
    name: string
    artist: string
    cover?: string | null
    year?: string | null
    type?: $Enums.TrackType
    tracks?: TrackCreateNestedManyWithoutAlbumEntityInput
    listenedByUsers?: UserAlbumHistoryCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUncheckedCreateWithoutLikedByUsersInput = {
    id?: number
    name: string
    artist: string
    cover?: string | null
    year?: string | null
    type?: $Enums.TrackType
    tracks?: TrackUncheckedCreateNestedManyWithoutAlbumEntityInput
    listenedByUsers?: UserAlbumHistoryUncheckedCreateNestedManyWithoutAlbumInput
  }

  export type AlbumCreateOrConnectWithoutLikedByUsersInput = {
    where: AlbumWhereUniqueInput
    create: XOR<AlbumCreateWithoutLikedByUsersInput, AlbumUncheckedCreateWithoutLikedByUsersInput>
  }

  export type UserUpsertWithoutLikedAlbumsInput = {
    update: XOR<UserUpdateWithoutLikedAlbumsInput, UserUncheckedUpdateWithoutLikedAlbumsInput>
    create: XOR<UserCreateWithoutLikedAlbumsInput, UserUncheckedCreateWithoutLikedAlbumsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikedAlbumsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikedAlbumsInput, UserUncheckedUpdateWithoutLikedAlbumsInput>
  }

  export type UserUpdateWithoutLikedAlbumsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    likedTracks?: UserTrackLikeUpdateManyWithoutUserNestedInput
    listenedTracks?: UserTrackHistoryUpdateManyWithoutUserNestedInput
    listenedAlbums?: UserAlbumHistoryUpdateManyWithoutUserNestedInput
    likedAudiobooks?: UserAudiobookLikeUpdateManyWithoutUserNestedInput
    listenedAudiobooks?: UserAudiobookHistoryUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    searchRecords?: SearchRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLikedAlbumsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    likedTracks?: UserTrackLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedTracks?: UserTrackHistoryUncheckedUpdateManyWithoutUserNestedInput
    listenedAlbums?: UserAlbumHistoryUncheckedUpdateManyWithoutUserNestedInput
    likedAudiobooks?: UserAudiobookLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedAudiobooks?: UserAudiobookHistoryUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    searchRecords?: SearchRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AlbumUpsertWithoutLikedByUsersInput = {
    update: XOR<AlbumUpdateWithoutLikedByUsersInput, AlbumUncheckedUpdateWithoutLikedByUsersInput>
    create: XOR<AlbumCreateWithoutLikedByUsersInput, AlbumUncheckedCreateWithoutLikedByUsersInput>
    where?: AlbumWhereInput
  }

  export type AlbumUpdateToOneWithWhereWithoutLikedByUsersInput = {
    where?: AlbumWhereInput
    data: XOR<AlbumUpdateWithoutLikedByUsersInput, AlbumUncheckedUpdateWithoutLikedByUsersInput>
  }

  export type AlbumUpdateWithoutLikedByUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    tracks?: TrackUpdateManyWithoutAlbumEntityNestedInput
    listenedByUsers?: UserAlbumHistoryUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumUncheckedUpdateWithoutLikedByUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    tracks?: TrackUncheckedUpdateManyWithoutAlbumEntityNestedInput
    listenedByUsers?: UserAlbumHistoryUncheckedUpdateManyWithoutAlbumNestedInput
  }

  export type UserCreateWithoutListenedAlbumsInput = {
    username: string
    password: string
    is_admin?: boolean
    likedTracks?: UserTrackLikeCreateNestedManyWithoutUserInput
    listenedTracks?: UserTrackHistoryCreateNestedManyWithoutUserInput
    likedAlbums?: UserAlbumLikeCreateNestedManyWithoutUserInput
    likedAudiobooks?: UserAudiobookLikeCreateNestedManyWithoutUserInput
    listenedAudiobooks?: UserAudiobookHistoryCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    searchRecords?: SearchRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutListenedAlbumsInput = {
    id?: number
    username: string
    password: string
    is_admin?: boolean
    likedTracks?: UserTrackLikeUncheckedCreateNestedManyWithoutUserInput
    listenedTracks?: UserTrackHistoryUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserAlbumLikeUncheckedCreateNestedManyWithoutUserInput
    likedAudiobooks?: UserAudiobookLikeUncheckedCreateNestedManyWithoutUserInput
    listenedAudiobooks?: UserAudiobookHistoryUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    searchRecords?: SearchRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutListenedAlbumsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutListenedAlbumsInput, UserUncheckedCreateWithoutListenedAlbumsInput>
  }

  export type AlbumCreateWithoutListenedByUsersInput = {
    name: string
    artist: string
    cover?: string | null
    year?: string | null
    type?: $Enums.TrackType
    tracks?: TrackCreateNestedManyWithoutAlbumEntityInput
    likedByUsers?: UserAlbumLikeCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUncheckedCreateWithoutListenedByUsersInput = {
    id?: number
    name: string
    artist: string
    cover?: string | null
    year?: string | null
    type?: $Enums.TrackType
    tracks?: TrackUncheckedCreateNestedManyWithoutAlbumEntityInput
    likedByUsers?: UserAlbumLikeUncheckedCreateNestedManyWithoutAlbumInput
  }

  export type AlbumCreateOrConnectWithoutListenedByUsersInput = {
    where: AlbumWhereUniqueInput
    create: XOR<AlbumCreateWithoutListenedByUsersInput, AlbumUncheckedCreateWithoutListenedByUsersInput>
  }

  export type UserUpsertWithoutListenedAlbumsInput = {
    update: XOR<UserUpdateWithoutListenedAlbumsInput, UserUncheckedUpdateWithoutListenedAlbumsInput>
    create: XOR<UserCreateWithoutListenedAlbumsInput, UserUncheckedCreateWithoutListenedAlbumsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutListenedAlbumsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutListenedAlbumsInput, UserUncheckedUpdateWithoutListenedAlbumsInput>
  }

  export type UserUpdateWithoutListenedAlbumsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    likedTracks?: UserTrackLikeUpdateManyWithoutUserNestedInput
    listenedTracks?: UserTrackHistoryUpdateManyWithoutUserNestedInput
    likedAlbums?: UserAlbumLikeUpdateManyWithoutUserNestedInput
    likedAudiobooks?: UserAudiobookLikeUpdateManyWithoutUserNestedInput
    listenedAudiobooks?: UserAudiobookHistoryUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    searchRecords?: SearchRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutListenedAlbumsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    likedTracks?: UserTrackLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedTracks?: UserTrackHistoryUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserAlbumLikeUncheckedUpdateManyWithoutUserNestedInput
    likedAudiobooks?: UserAudiobookLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedAudiobooks?: UserAudiobookHistoryUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    searchRecords?: SearchRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AlbumUpsertWithoutListenedByUsersInput = {
    update: XOR<AlbumUpdateWithoutListenedByUsersInput, AlbumUncheckedUpdateWithoutListenedByUsersInput>
    create: XOR<AlbumCreateWithoutListenedByUsersInput, AlbumUncheckedCreateWithoutListenedByUsersInput>
    where?: AlbumWhereInput
  }

  export type AlbumUpdateToOneWithWhereWithoutListenedByUsersInput = {
    where?: AlbumWhereInput
    data: XOR<AlbumUpdateWithoutListenedByUsersInput, AlbumUncheckedUpdateWithoutListenedByUsersInput>
  }

  export type AlbumUpdateWithoutListenedByUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    tracks?: TrackUpdateManyWithoutAlbumEntityNestedInput
    likedByUsers?: UserAlbumLikeUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumUncheckedUpdateWithoutListenedByUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    tracks?: TrackUncheckedUpdateManyWithoutAlbumEntityNestedInput
    likedByUsers?: UserAlbumLikeUncheckedUpdateManyWithoutAlbumNestedInput
  }

  export type UserCreateWithoutLikedAudiobooksInput = {
    username: string
    password: string
    is_admin?: boolean
    likedTracks?: UserTrackLikeCreateNestedManyWithoutUserInput
    listenedTracks?: UserTrackHistoryCreateNestedManyWithoutUserInput
    likedAlbums?: UserAlbumLikeCreateNestedManyWithoutUserInput
    listenedAlbums?: UserAlbumHistoryCreateNestedManyWithoutUserInput
    listenedAudiobooks?: UserAudiobookHistoryCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    searchRecords?: SearchRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLikedAudiobooksInput = {
    id?: number
    username: string
    password: string
    is_admin?: boolean
    likedTracks?: UserTrackLikeUncheckedCreateNestedManyWithoutUserInput
    listenedTracks?: UserTrackHistoryUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserAlbumLikeUncheckedCreateNestedManyWithoutUserInput
    listenedAlbums?: UserAlbumHistoryUncheckedCreateNestedManyWithoutUserInput
    listenedAudiobooks?: UserAudiobookHistoryUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    searchRecords?: SearchRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLikedAudiobooksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikedAudiobooksInput, UserUncheckedCreateWithoutLikedAudiobooksInput>
  }

  export type TrackCreateWithoutLikedAsAudiobookByUsersInput = {
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistEntity?: ArtistCreateNestedOneWithoutTracksInput
    albumEntity?: AlbumCreateNestedOneWithoutTracksInput
    likedByUsers?: UserTrackLikeCreateNestedManyWithoutTrackInput
    listenedByUsers?: UserTrackHistoryCreateNestedManyWithoutTrackInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryCreateNestedManyWithoutTrackInput
    playlists?: PlaylistCreateNestedManyWithoutTracksInput
    folder?: FolderCreateNestedOneWithoutTracksInput
  }

  export type TrackUncheckedCreateWithoutLikedAsAudiobookByUsersInput = {
    id?: number
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistId?: number | null
    albumId?: number | null
    folderId?: number | null
    likedByUsers?: UserTrackLikeUncheckedCreateNestedManyWithoutTrackInput
    listenedByUsers?: UserTrackHistoryUncheckedCreateNestedManyWithoutTrackInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUncheckedCreateNestedManyWithoutTrackInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutTracksInput
  }

  export type TrackCreateOrConnectWithoutLikedAsAudiobookByUsersInput = {
    where: TrackWhereUniqueInput
    create: XOR<TrackCreateWithoutLikedAsAudiobookByUsersInput, TrackUncheckedCreateWithoutLikedAsAudiobookByUsersInput>
  }

  export type UserUpsertWithoutLikedAudiobooksInput = {
    update: XOR<UserUpdateWithoutLikedAudiobooksInput, UserUncheckedUpdateWithoutLikedAudiobooksInput>
    create: XOR<UserCreateWithoutLikedAudiobooksInput, UserUncheckedCreateWithoutLikedAudiobooksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikedAudiobooksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikedAudiobooksInput, UserUncheckedUpdateWithoutLikedAudiobooksInput>
  }

  export type UserUpdateWithoutLikedAudiobooksInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    likedTracks?: UserTrackLikeUpdateManyWithoutUserNestedInput
    listenedTracks?: UserTrackHistoryUpdateManyWithoutUserNestedInput
    likedAlbums?: UserAlbumLikeUpdateManyWithoutUserNestedInput
    listenedAlbums?: UserAlbumHistoryUpdateManyWithoutUserNestedInput
    listenedAudiobooks?: UserAudiobookHistoryUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    searchRecords?: SearchRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLikedAudiobooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    likedTracks?: UserTrackLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedTracks?: UserTrackHistoryUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserAlbumLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedAlbums?: UserAlbumHistoryUncheckedUpdateManyWithoutUserNestedInput
    listenedAudiobooks?: UserAudiobookHistoryUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    searchRecords?: SearchRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TrackUpsertWithoutLikedAsAudiobookByUsersInput = {
    update: XOR<TrackUpdateWithoutLikedAsAudiobookByUsersInput, TrackUncheckedUpdateWithoutLikedAsAudiobookByUsersInput>
    create: XOR<TrackCreateWithoutLikedAsAudiobookByUsersInput, TrackUncheckedCreateWithoutLikedAsAudiobookByUsersInput>
    where?: TrackWhereInput
  }

  export type TrackUpdateToOneWithWhereWithoutLikedAsAudiobookByUsersInput = {
    where?: TrackWhereInput
    data: XOR<TrackUpdateWithoutLikedAsAudiobookByUsersInput, TrackUncheckedUpdateWithoutLikedAsAudiobookByUsersInput>
  }

  export type TrackUpdateWithoutLikedAsAudiobookByUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistEntity?: ArtistUpdateOneWithoutTracksNestedInput
    albumEntity?: AlbumUpdateOneWithoutTracksNestedInput
    likedByUsers?: UserTrackLikeUpdateManyWithoutTrackNestedInput
    listenedByUsers?: UserTrackHistoryUpdateManyWithoutTrackNestedInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUpdateManyWithoutTrackNestedInput
    playlists?: PlaylistUpdateManyWithoutTracksNestedInput
    folder?: FolderUpdateOneWithoutTracksNestedInput
  }

  export type TrackUncheckedUpdateWithoutLikedAsAudiobookByUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistId?: NullableIntFieldUpdateOperationsInput | number | null
    albumId?: NullableIntFieldUpdateOperationsInput | number | null
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    likedByUsers?: UserTrackLikeUncheckedUpdateManyWithoutTrackNestedInput
    listenedByUsers?: UserTrackHistoryUncheckedUpdateManyWithoutTrackNestedInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUncheckedUpdateManyWithoutTrackNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutTracksNestedInput
  }

  export type UserCreateWithoutListenedAudiobooksInput = {
    username: string
    password: string
    is_admin?: boolean
    likedTracks?: UserTrackLikeCreateNestedManyWithoutUserInput
    listenedTracks?: UserTrackHistoryCreateNestedManyWithoutUserInput
    likedAlbums?: UserAlbumLikeCreateNestedManyWithoutUserInput
    listenedAlbums?: UserAlbumHistoryCreateNestedManyWithoutUserInput
    likedAudiobooks?: UserAudiobookLikeCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    searchRecords?: SearchRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutListenedAudiobooksInput = {
    id?: number
    username: string
    password: string
    is_admin?: boolean
    likedTracks?: UserTrackLikeUncheckedCreateNestedManyWithoutUserInput
    listenedTracks?: UserTrackHistoryUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserAlbumLikeUncheckedCreateNestedManyWithoutUserInput
    listenedAlbums?: UserAlbumHistoryUncheckedCreateNestedManyWithoutUserInput
    likedAudiobooks?: UserAudiobookLikeUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    searchRecords?: SearchRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutListenedAudiobooksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutListenedAudiobooksInput, UserUncheckedCreateWithoutListenedAudiobooksInput>
  }

  export type TrackCreateWithoutListenedAsAudiobookByUsersInput = {
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistEntity?: ArtistCreateNestedOneWithoutTracksInput
    albumEntity?: AlbumCreateNestedOneWithoutTracksInput
    likedByUsers?: UserTrackLikeCreateNestedManyWithoutTrackInput
    listenedByUsers?: UserTrackHistoryCreateNestedManyWithoutTrackInput
    likedAsAudiobookByUsers?: UserAudiobookLikeCreateNestedManyWithoutTrackInput
    playlists?: PlaylistCreateNestedManyWithoutTracksInput
    folder?: FolderCreateNestedOneWithoutTracksInput
  }

  export type TrackUncheckedCreateWithoutListenedAsAudiobookByUsersInput = {
    id?: number
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistId?: number | null
    albumId?: number | null
    folderId?: number | null
    likedByUsers?: UserTrackLikeUncheckedCreateNestedManyWithoutTrackInput
    listenedByUsers?: UserTrackHistoryUncheckedCreateNestedManyWithoutTrackInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUncheckedCreateNestedManyWithoutTrackInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutTracksInput
  }

  export type TrackCreateOrConnectWithoutListenedAsAudiobookByUsersInput = {
    where: TrackWhereUniqueInput
    create: XOR<TrackCreateWithoutListenedAsAudiobookByUsersInput, TrackUncheckedCreateWithoutListenedAsAudiobookByUsersInput>
  }

  export type UserUpsertWithoutListenedAudiobooksInput = {
    update: XOR<UserUpdateWithoutListenedAudiobooksInput, UserUncheckedUpdateWithoutListenedAudiobooksInput>
    create: XOR<UserCreateWithoutListenedAudiobooksInput, UserUncheckedCreateWithoutListenedAudiobooksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutListenedAudiobooksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutListenedAudiobooksInput, UserUncheckedUpdateWithoutListenedAudiobooksInput>
  }

  export type UserUpdateWithoutListenedAudiobooksInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    likedTracks?: UserTrackLikeUpdateManyWithoutUserNestedInput
    listenedTracks?: UserTrackHistoryUpdateManyWithoutUserNestedInput
    likedAlbums?: UserAlbumLikeUpdateManyWithoutUserNestedInput
    listenedAlbums?: UserAlbumHistoryUpdateManyWithoutUserNestedInput
    likedAudiobooks?: UserAudiobookLikeUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    searchRecords?: SearchRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutListenedAudiobooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    likedTracks?: UserTrackLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedTracks?: UserTrackHistoryUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserAlbumLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedAlbums?: UserAlbumHistoryUncheckedUpdateManyWithoutUserNestedInput
    likedAudiobooks?: UserAudiobookLikeUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    searchRecords?: SearchRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TrackUpsertWithoutListenedAsAudiobookByUsersInput = {
    update: XOR<TrackUpdateWithoutListenedAsAudiobookByUsersInput, TrackUncheckedUpdateWithoutListenedAsAudiobookByUsersInput>
    create: XOR<TrackCreateWithoutListenedAsAudiobookByUsersInput, TrackUncheckedCreateWithoutListenedAsAudiobookByUsersInput>
    where?: TrackWhereInput
  }

  export type TrackUpdateToOneWithWhereWithoutListenedAsAudiobookByUsersInput = {
    where?: TrackWhereInput
    data: XOR<TrackUpdateWithoutListenedAsAudiobookByUsersInput, TrackUncheckedUpdateWithoutListenedAsAudiobookByUsersInput>
  }

  export type TrackUpdateWithoutListenedAsAudiobookByUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistEntity?: ArtistUpdateOneWithoutTracksNestedInput
    albumEntity?: AlbumUpdateOneWithoutTracksNestedInput
    likedByUsers?: UserTrackLikeUpdateManyWithoutTrackNestedInput
    listenedByUsers?: UserTrackHistoryUpdateManyWithoutTrackNestedInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUpdateManyWithoutTrackNestedInput
    playlists?: PlaylistUpdateManyWithoutTracksNestedInput
    folder?: FolderUpdateOneWithoutTracksNestedInput
  }

  export type TrackUncheckedUpdateWithoutListenedAsAudiobookByUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistId?: NullableIntFieldUpdateOperationsInput | number | null
    albumId?: NullableIntFieldUpdateOperationsInput | number | null
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    likedByUsers?: UserTrackLikeUncheckedUpdateManyWithoutTrackNestedInput
    listenedByUsers?: UserTrackHistoryUncheckedUpdateManyWithoutTrackNestedInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUncheckedUpdateManyWithoutTrackNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutTracksNestedInput
  }

  export type UserTrackLikeCreateWithoutUserInput = {
    createdAt?: Date | string
    track: TrackCreateNestedOneWithoutLikedByUsersInput
  }

  export type UserTrackLikeUncheckedCreateWithoutUserInput = {
    id?: number
    trackId: number
    createdAt?: Date | string
  }

  export type UserTrackLikeCreateOrConnectWithoutUserInput = {
    where: UserTrackLikeWhereUniqueInput
    create: XOR<UserTrackLikeCreateWithoutUserInput, UserTrackLikeUncheckedCreateWithoutUserInput>
  }

  export type UserTrackLikeCreateManyUserInputEnvelope = {
    data: UserTrackLikeCreateManyUserInput | UserTrackLikeCreateManyUserInput[]
  }

  export type UserTrackHistoryCreateWithoutUserInput = {
    listenedAt?: Date | string
    progress?: number
    deviceName: string
    isSyncMode?: boolean
    track: TrackCreateNestedOneWithoutListenedByUsersInput
    device: DeviceCreateNestedOneWithoutHistoriesInput
  }

  export type UserTrackHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    trackId: number
    listenedAt?: Date | string
    progress?: number
    deviceName: string
    deviceId: number
    isSyncMode?: boolean
  }

  export type UserTrackHistoryCreateOrConnectWithoutUserInput = {
    where: UserTrackHistoryWhereUniqueInput
    create: XOR<UserTrackHistoryCreateWithoutUserInput, UserTrackHistoryUncheckedCreateWithoutUserInput>
  }

  export type UserTrackHistoryCreateManyUserInputEnvelope = {
    data: UserTrackHistoryCreateManyUserInput | UserTrackHistoryCreateManyUserInput[]
  }

  export type UserAlbumLikeCreateWithoutUserInput = {
    createdAt?: Date | string
    album: AlbumCreateNestedOneWithoutLikedByUsersInput
  }

  export type UserAlbumLikeUncheckedCreateWithoutUserInput = {
    id?: number
    albumId: number
    createdAt?: Date | string
  }

  export type UserAlbumLikeCreateOrConnectWithoutUserInput = {
    where: UserAlbumLikeWhereUniqueInput
    create: XOR<UserAlbumLikeCreateWithoutUserInput, UserAlbumLikeUncheckedCreateWithoutUserInput>
  }

  export type UserAlbumLikeCreateManyUserInputEnvelope = {
    data: UserAlbumLikeCreateManyUserInput | UserAlbumLikeCreateManyUserInput[]
  }

  export type UserAlbumHistoryCreateWithoutUserInput = {
    listenedAt?: Date | string
    album: AlbumCreateNestedOneWithoutListenedByUsersInput
  }

  export type UserAlbumHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    albumId: number
    listenedAt?: Date | string
  }

  export type UserAlbumHistoryCreateOrConnectWithoutUserInput = {
    where: UserAlbumHistoryWhereUniqueInput
    create: XOR<UserAlbumHistoryCreateWithoutUserInput, UserAlbumHistoryUncheckedCreateWithoutUserInput>
  }

  export type UserAlbumHistoryCreateManyUserInputEnvelope = {
    data: UserAlbumHistoryCreateManyUserInput | UserAlbumHistoryCreateManyUserInput[]
  }

  export type UserAudiobookLikeCreateWithoutUserInput = {
    createdAt?: Date | string
    track: TrackCreateNestedOneWithoutLikedAsAudiobookByUsersInput
  }

  export type UserAudiobookLikeUncheckedCreateWithoutUserInput = {
    id?: number
    trackId: number
    createdAt?: Date | string
  }

  export type UserAudiobookLikeCreateOrConnectWithoutUserInput = {
    where: UserAudiobookLikeWhereUniqueInput
    create: XOR<UserAudiobookLikeCreateWithoutUserInput, UserAudiobookLikeUncheckedCreateWithoutUserInput>
  }

  export type UserAudiobookLikeCreateManyUserInputEnvelope = {
    data: UserAudiobookLikeCreateManyUserInput | UserAudiobookLikeCreateManyUserInput[]
  }

  export type UserAudiobookHistoryCreateWithoutUserInput = {
    listenedAt?: Date | string
    progress?: number
    track: TrackCreateNestedOneWithoutListenedAsAudiobookByUsersInput
  }

  export type UserAudiobookHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    trackId: number
    listenedAt?: Date | string
    progress?: number
  }

  export type UserAudiobookHistoryCreateOrConnectWithoutUserInput = {
    where: UserAudiobookHistoryWhereUniqueInput
    create: XOR<UserAudiobookHistoryCreateWithoutUserInput, UserAudiobookHistoryUncheckedCreateWithoutUserInput>
  }

  export type UserAudiobookHistoryCreateManyUserInputEnvelope = {
    data: UserAudiobookHistoryCreateManyUserInput | UserAudiobookHistoryCreateManyUserInput[]
  }

  export type PlaylistCreateWithoutUserInput = {
    name: string
    type?: $Enums.TrackType
    createdAt?: Date | string
    updatedAt?: Date | string
    tracks?: TrackCreateNestedManyWithoutPlaylistsInput
  }

  export type PlaylistUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    type?: $Enums.TrackType
    createdAt?: Date | string
    updatedAt?: Date | string
    tracks?: TrackUncheckedCreateNestedManyWithoutPlaylistsInput
  }

  export type PlaylistCreateOrConnectWithoutUserInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutUserInput, PlaylistUncheckedCreateWithoutUserInput>
  }

  export type PlaylistCreateManyUserInputEnvelope = {
    data: PlaylistCreateManyUserInput | PlaylistCreateManyUserInput[]
  }

  export type DeviceCreateWithoutUserInput = {
    name: string
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    histories?: UserTrackHistoryCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    histories?: UserTrackHistoryUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutUserInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput>
  }

  export type DeviceCreateManyUserInputEnvelope = {
    data: DeviceCreateManyUserInput | DeviceCreateManyUserInput[]
  }

  export type SearchRecordCreateWithoutUserInput = {
    keyword: string
    createdAt?: Date | string
  }

  export type SearchRecordUncheckedCreateWithoutUserInput = {
    id?: number
    keyword: string
    createdAt?: Date | string
  }

  export type SearchRecordCreateOrConnectWithoutUserInput = {
    where: SearchRecordWhereUniqueInput
    create: XOR<SearchRecordCreateWithoutUserInput, SearchRecordUncheckedCreateWithoutUserInput>
  }

  export type SearchRecordCreateManyUserInputEnvelope = {
    data: SearchRecordCreateManyUserInput | SearchRecordCreateManyUserInput[]
  }

  export type UserTrackLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserTrackLikeWhereUniqueInput
    update: XOR<UserTrackLikeUpdateWithoutUserInput, UserTrackLikeUncheckedUpdateWithoutUserInput>
    create: XOR<UserTrackLikeCreateWithoutUserInput, UserTrackLikeUncheckedCreateWithoutUserInput>
  }

  export type UserTrackLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserTrackLikeWhereUniqueInput
    data: XOR<UserTrackLikeUpdateWithoutUserInput, UserTrackLikeUncheckedUpdateWithoutUserInput>
  }

  export type UserTrackLikeUpdateManyWithWhereWithoutUserInput = {
    where: UserTrackLikeScalarWhereInput
    data: XOR<UserTrackLikeUpdateManyMutationInput, UserTrackLikeUncheckedUpdateManyWithoutUserInput>
  }

  export type UserTrackHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: UserTrackHistoryWhereUniqueInput
    update: XOR<UserTrackHistoryUpdateWithoutUserInput, UserTrackHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<UserTrackHistoryCreateWithoutUserInput, UserTrackHistoryUncheckedCreateWithoutUserInput>
  }

  export type UserTrackHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: UserTrackHistoryWhereUniqueInput
    data: XOR<UserTrackHistoryUpdateWithoutUserInput, UserTrackHistoryUncheckedUpdateWithoutUserInput>
  }

  export type UserTrackHistoryUpdateManyWithWhereWithoutUserInput = {
    where: UserTrackHistoryScalarWhereInput
    data: XOR<UserTrackHistoryUpdateManyMutationInput, UserTrackHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAlbumLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAlbumLikeWhereUniqueInput
    update: XOR<UserAlbumLikeUpdateWithoutUserInput, UserAlbumLikeUncheckedUpdateWithoutUserInput>
    create: XOR<UserAlbumLikeCreateWithoutUserInput, UserAlbumLikeUncheckedCreateWithoutUserInput>
  }

  export type UserAlbumLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAlbumLikeWhereUniqueInput
    data: XOR<UserAlbumLikeUpdateWithoutUserInput, UserAlbumLikeUncheckedUpdateWithoutUserInput>
  }

  export type UserAlbumLikeUpdateManyWithWhereWithoutUserInput = {
    where: UserAlbumLikeScalarWhereInput
    data: XOR<UserAlbumLikeUpdateManyMutationInput, UserAlbumLikeUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAlbumHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAlbumHistoryWhereUniqueInput
    update: XOR<UserAlbumHistoryUpdateWithoutUserInput, UserAlbumHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<UserAlbumHistoryCreateWithoutUserInput, UserAlbumHistoryUncheckedCreateWithoutUserInput>
  }

  export type UserAlbumHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAlbumHistoryWhereUniqueInput
    data: XOR<UserAlbumHistoryUpdateWithoutUserInput, UserAlbumHistoryUncheckedUpdateWithoutUserInput>
  }

  export type UserAlbumHistoryUpdateManyWithWhereWithoutUserInput = {
    where: UserAlbumHistoryScalarWhereInput
    data: XOR<UserAlbumHistoryUpdateManyMutationInput, UserAlbumHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAudiobookLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAudiobookLikeWhereUniqueInput
    update: XOR<UserAudiobookLikeUpdateWithoutUserInput, UserAudiobookLikeUncheckedUpdateWithoutUserInput>
    create: XOR<UserAudiobookLikeCreateWithoutUserInput, UserAudiobookLikeUncheckedCreateWithoutUserInput>
  }

  export type UserAudiobookLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAudiobookLikeWhereUniqueInput
    data: XOR<UserAudiobookLikeUpdateWithoutUserInput, UserAudiobookLikeUncheckedUpdateWithoutUserInput>
  }

  export type UserAudiobookLikeUpdateManyWithWhereWithoutUserInput = {
    where: UserAudiobookLikeScalarWhereInput
    data: XOR<UserAudiobookLikeUpdateManyMutationInput, UserAudiobookLikeUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAudiobookHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAudiobookHistoryWhereUniqueInput
    update: XOR<UserAudiobookHistoryUpdateWithoutUserInput, UserAudiobookHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<UserAudiobookHistoryCreateWithoutUserInput, UserAudiobookHistoryUncheckedCreateWithoutUserInput>
  }

  export type UserAudiobookHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAudiobookHistoryWhereUniqueInput
    data: XOR<UserAudiobookHistoryUpdateWithoutUserInput, UserAudiobookHistoryUncheckedUpdateWithoutUserInput>
  }

  export type UserAudiobookHistoryUpdateManyWithWhereWithoutUserInput = {
    where: UserAudiobookHistoryScalarWhereInput
    data: XOR<UserAudiobookHistoryUpdateManyMutationInput, UserAudiobookHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type PlaylistUpsertWithWhereUniqueWithoutUserInput = {
    where: PlaylistWhereUniqueInput
    update: XOR<PlaylistUpdateWithoutUserInput, PlaylistUncheckedUpdateWithoutUserInput>
    create: XOR<PlaylistCreateWithoutUserInput, PlaylistUncheckedCreateWithoutUserInput>
  }

  export type PlaylistUpdateWithWhereUniqueWithoutUserInput = {
    where: PlaylistWhereUniqueInput
    data: XOR<PlaylistUpdateWithoutUserInput, PlaylistUncheckedUpdateWithoutUserInput>
  }

  export type PlaylistUpdateManyWithWhereWithoutUserInput = {
    where: PlaylistScalarWhereInput
    data: XOR<PlaylistUpdateManyMutationInput, PlaylistUncheckedUpdateManyWithoutUserInput>
  }

  export type DeviceUpsertWithWhereUniqueWithoutUserInput = {
    where: DeviceWhereUniqueInput
    update: XOR<DeviceUpdateWithoutUserInput, DeviceUncheckedUpdateWithoutUserInput>
    create: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput>
  }

  export type DeviceUpdateWithWhereUniqueWithoutUserInput = {
    where: DeviceWhereUniqueInput
    data: XOR<DeviceUpdateWithoutUserInput, DeviceUncheckedUpdateWithoutUserInput>
  }

  export type DeviceUpdateManyWithWhereWithoutUserInput = {
    where: DeviceScalarWhereInput
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyWithoutUserInput>
  }

  export type DeviceScalarWhereInput = {
    AND?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
    OR?: DeviceScalarWhereInput[]
    NOT?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
    id?: IntFilter<"Device"> | number
    name?: StringFilter<"Device"> | string
    userId?: IntFilter<"Device"> | number
    isOnline?: BoolFilter<"Device"> | boolean
    createdAt?: DateTimeFilter<"Device"> | Date | string
    updatedAt?: DateTimeFilter<"Device"> | Date | string
  }

  export type SearchRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: SearchRecordWhereUniqueInput
    update: XOR<SearchRecordUpdateWithoutUserInput, SearchRecordUncheckedUpdateWithoutUserInput>
    create: XOR<SearchRecordCreateWithoutUserInput, SearchRecordUncheckedCreateWithoutUserInput>
  }

  export type SearchRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: SearchRecordWhereUniqueInput
    data: XOR<SearchRecordUpdateWithoutUserInput, SearchRecordUncheckedUpdateWithoutUserInput>
  }

  export type SearchRecordUpdateManyWithWhereWithoutUserInput = {
    where: SearchRecordScalarWhereInput
    data: XOR<SearchRecordUpdateManyMutationInput, SearchRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type SearchRecordScalarWhereInput = {
    AND?: SearchRecordScalarWhereInput | SearchRecordScalarWhereInput[]
    OR?: SearchRecordScalarWhereInput[]
    NOT?: SearchRecordScalarWhereInput | SearchRecordScalarWhereInput[]
    id?: IntFilter<"SearchRecord"> | number
    keyword?: StringFilter<"SearchRecord"> | string
    createdAt?: DateTimeFilter<"SearchRecord"> | Date | string
    userId?: IntFilter<"SearchRecord"> | number
  }

  export type UserCreateWithoutSearchRecordsInput = {
    username: string
    password: string
    is_admin?: boolean
    likedTracks?: UserTrackLikeCreateNestedManyWithoutUserInput
    listenedTracks?: UserTrackHistoryCreateNestedManyWithoutUserInput
    likedAlbums?: UserAlbumLikeCreateNestedManyWithoutUserInput
    listenedAlbums?: UserAlbumHistoryCreateNestedManyWithoutUserInput
    likedAudiobooks?: UserAudiobookLikeCreateNestedManyWithoutUserInput
    listenedAudiobooks?: UserAudiobookHistoryCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSearchRecordsInput = {
    id?: number
    username: string
    password: string
    is_admin?: boolean
    likedTracks?: UserTrackLikeUncheckedCreateNestedManyWithoutUserInput
    listenedTracks?: UserTrackHistoryUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserAlbumLikeUncheckedCreateNestedManyWithoutUserInput
    listenedAlbums?: UserAlbumHistoryUncheckedCreateNestedManyWithoutUserInput
    likedAudiobooks?: UserAudiobookLikeUncheckedCreateNestedManyWithoutUserInput
    listenedAudiobooks?: UserAudiobookHistoryUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSearchRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSearchRecordsInput, UserUncheckedCreateWithoutSearchRecordsInput>
  }

  export type UserUpsertWithoutSearchRecordsInput = {
    update: XOR<UserUpdateWithoutSearchRecordsInput, UserUncheckedUpdateWithoutSearchRecordsInput>
    create: XOR<UserCreateWithoutSearchRecordsInput, UserUncheckedCreateWithoutSearchRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSearchRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSearchRecordsInput, UserUncheckedUpdateWithoutSearchRecordsInput>
  }

  export type UserUpdateWithoutSearchRecordsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    likedTracks?: UserTrackLikeUpdateManyWithoutUserNestedInput
    listenedTracks?: UserTrackHistoryUpdateManyWithoutUserNestedInput
    likedAlbums?: UserAlbumLikeUpdateManyWithoutUserNestedInput
    listenedAlbums?: UserAlbumHistoryUpdateManyWithoutUserNestedInput
    likedAudiobooks?: UserAudiobookLikeUpdateManyWithoutUserNestedInput
    listenedAudiobooks?: UserAudiobookHistoryUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSearchRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    likedTracks?: UserTrackLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedTracks?: UserTrackHistoryUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserAlbumLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedAlbums?: UserAlbumHistoryUncheckedUpdateManyWithoutUserNestedInput
    likedAudiobooks?: UserAudiobookLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedAudiobooks?: UserAudiobookHistoryUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDevicesInput = {
    username: string
    password: string
    is_admin?: boolean
    likedTracks?: UserTrackLikeCreateNestedManyWithoutUserInput
    listenedTracks?: UserTrackHistoryCreateNestedManyWithoutUserInput
    likedAlbums?: UserAlbumLikeCreateNestedManyWithoutUserInput
    listenedAlbums?: UserAlbumHistoryCreateNestedManyWithoutUserInput
    likedAudiobooks?: UserAudiobookLikeCreateNestedManyWithoutUserInput
    listenedAudiobooks?: UserAudiobookHistoryCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    searchRecords?: SearchRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDevicesInput = {
    id?: number
    username: string
    password: string
    is_admin?: boolean
    likedTracks?: UserTrackLikeUncheckedCreateNestedManyWithoutUserInput
    listenedTracks?: UserTrackHistoryUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserAlbumLikeUncheckedCreateNestedManyWithoutUserInput
    listenedAlbums?: UserAlbumHistoryUncheckedCreateNestedManyWithoutUserInput
    likedAudiobooks?: UserAudiobookLikeUncheckedCreateNestedManyWithoutUserInput
    listenedAudiobooks?: UserAudiobookHistoryUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    searchRecords?: SearchRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDevicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
  }

  export type UserTrackHistoryCreateWithoutDeviceInput = {
    listenedAt?: Date | string
    progress?: number
    deviceName: string
    isSyncMode?: boolean
    user: UserCreateNestedOneWithoutListenedTracksInput
    track: TrackCreateNestedOneWithoutListenedByUsersInput
  }

  export type UserTrackHistoryUncheckedCreateWithoutDeviceInput = {
    id?: number
    userId: number
    trackId: number
    listenedAt?: Date | string
    progress?: number
    deviceName: string
    isSyncMode?: boolean
  }

  export type UserTrackHistoryCreateOrConnectWithoutDeviceInput = {
    where: UserTrackHistoryWhereUniqueInput
    create: XOR<UserTrackHistoryCreateWithoutDeviceInput, UserTrackHistoryUncheckedCreateWithoutDeviceInput>
  }

  export type UserTrackHistoryCreateManyDeviceInputEnvelope = {
    data: UserTrackHistoryCreateManyDeviceInput | UserTrackHistoryCreateManyDeviceInput[]
  }

  export type UserUpsertWithoutDevicesInput = {
    update: XOR<UserUpdateWithoutDevicesInput, UserUncheckedUpdateWithoutDevicesInput>
    create: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDevicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDevicesInput, UserUncheckedUpdateWithoutDevicesInput>
  }

  export type UserUpdateWithoutDevicesInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    likedTracks?: UserTrackLikeUpdateManyWithoutUserNestedInput
    listenedTracks?: UserTrackHistoryUpdateManyWithoutUserNestedInput
    likedAlbums?: UserAlbumLikeUpdateManyWithoutUserNestedInput
    listenedAlbums?: UserAlbumHistoryUpdateManyWithoutUserNestedInput
    likedAudiobooks?: UserAudiobookLikeUpdateManyWithoutUserNestedInput
    listenedAudiobooks?: UserAudiobookHistoryUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    searchRecords?: SearchRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDevicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    likedTracks?: UserTrackLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedTracks?: UserTrackHistoryUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserAlbumLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedAlbums?: UserAlbumHistoryUncheckedUpdateManyWithoutUserNestedInput
    likedAudiobooks?: UserAudiobookLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedAudiobooks?: UserAudiobookHistoryUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    searchRecords?: SearchRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserTrackHistoryUpsertWithWhereUniqueWithoutDeviceInput = {
    where: UserTrackHistoryWhereUniqueInput
    update: XOR<UserTrackHistoryUpdateWithoutDeviceInput, UserTrackHistoryUncheckedUpdateWithoutDeviceInput>
    create: XOR<UserTrackHistoryCreateWithoutDeviceInput, UserTrackHistoryUncheckedCreateWithoutDeviceInput>
  }

  export type UserTrackHistoryUpdateWithWhereUniqueWithoutDeviceInput = {
    where: UserTrackHistoryWhereUniqueInput
    data: XOR<UserTrackHistoryUpdateWithoutDeviceInput, UserTrackHistoryUncheckedUpdateWithoutDeviceInput>
  }

  export type UserTrackHistoryUpdateManyWithWhereWithoutDeviceInput = {
    where: UserTrackHistoryScalarWhereInput
    data: XOR<UserTrackHistoryUpdateManyMutationInput, UserTrackHistoryUncheckedUpdateManyWithoutDeviceInput>
  }

  export type UserCreateWithoutPlaylistsInput = {
    username: string
    password: string
    is_admin?: boolean
    likedTracks?: UserTrackLikeCreateNestedManyWithoutUserInput
    listenedTracks?: UserTrackHistoryCreateNestedManyWithoutUserInput
    likedAlbums?: UserAlbumLikeCreateNestedManyWithoutUserInput
    listenedAlbums?: UserAlbumHistoryCreateNestedManyWithoutUserInput
    likedAudiobooks?: UserAudiobookLikeCreateNestedManyWithoutUserInput
    listenedAudiobooks?: UserAudiobookHistoryCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    searchRecords?: SearchRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlaylistsInput = {
    id?: number
    username: string
    password: string
    is_admin?: boolean
    likedTracks?: UserTrackLikeUncheckedCreateNestedManyWithoutUserInput
    listenedTracks?: UserTrackHistoryUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserAlbumLikeUncheckedCreateNestedManyWithoutUserInput
    listenedAlbums?: UserAlbumHistoryUncheckedCreateNestedManyWithoutUserInput
    likedAudiobooks?: UserAudiobookLikeUncheckedCreateNestedManyWithoutUserInput
    listenedAudiobooks?: UserAudiobookHistoryUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    searchRecords?: SearchRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlaylistsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlaylistsInput, UserUncheckedCreateWithoutPlaylistsInput>
  }

  export type TrackCreateWithoutPlaylistsInput = {
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistEntity?: ArtistCreateNestedOneWithoutTracksInput
    albumEntity?: AlbumCreateNestedOneWithoutTracksInput
    likedByUsers?: UserTrackLikeCreateNestedManyWithoutTrackInput
    listenedByUsers?: UserTrackHistoryCreateNestedManyWithoutTrackInput
    likedAsAudiobookByUsers?: UserAudiobookLikeCreateNestedManyWithoutTrackInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryCreateNestedManyWithoutTrackInput
    folder?: FolderCreateNestedOneWithoutTracksInput
  }

  export type TrackUncheckedCreateWithoutPlaylistsInput = {
    id?: number
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistId?: number | null
    albumId?: number | null
    folderId?: number | null
    likedByUsers?: UserTrackLikeUncheckedCreateNestedManyWithoutTrackInput
    listenedByUsers?: UserTrackHistoryUncheckedCreateNestedManyWithoutTrackInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUncheckedCreateNestedManyWithoutTrackInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUncheckedCreateNestedManyWithoutTrackInput
  }

  export type TrackCreateOrConnectWithoutPlaylistsInput = {
    where: TrackWhereUniqueInput
    create: XOR<TrackCreateWithoutPlaylistsInput, TrackUncheckedCreateWithoutPlaylistsInput>
  }

  export type UserUpsertWithoutPlaylistsInput = {
    update: XOR<UserUpdateWithoutPlaylistsInput, UserUncheckedUpdateWithoutPlaylistsInput>
    create: XOR<UserCreateWithoutPlaylistsInput, UserUncheckedCreateWithoutPlaylistsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlaylistsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlaylistsInput, UserUncheckedUpdateWithoutPlaylistsInput>
  }

  export type UserUpdateWithoutPlaylistsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    likedTracks?: UserTrackLikeUpdateManyWithoutUserNestedInput
    listenedTracks?: UserTrackHistoryUpdateManyWithoutUserNestedInput
    likedAlbums?: UserAlbumLikeUpdateManyWithoutUserNestedInput
    listenedAlbums?: UserAlbumHistoryUpdateManyWithoutUserNestedInput
    likedAudiobooks?: UserAudiobookLikeUpdateManyWithoutUserNestedInput
    listenedAudiobooks?: UserAudiobookHistoryUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    searchRecords?: SearchRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlaylistsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_admin?: BoolFieldUpdateOperationsInput | boolean
    likedTracks?: UserTrackLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedTracks?: UserTrackHistoryUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserAlbumLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedAlbums?: UserAlbumHistoryUncheckedUpdateManyWithoutUserNestedInput
    likedAudiobooks?: UserAudiobookLikeUncheckedUpdateManyWithoutUserNestedInput
    listenedAudiobooks?: UserAudiobookHistoryUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    searchRecords?: SearchRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TrackUpsertWithWhereUniqueWithoutPlaylistsInput = {
    where: TrackWhereUniqueInput
    update: XOR<TrackUpdateWithoutPlaylistsInput, TrackUncheckedUpdateWithoutPlaylistsInput>
    create: XOR<TrackCreateWithoutPlaylistsInput, TrackUncheckedCreateWithoutPlaylistsInput>
  }

  export type TrackUpdateWithWhereUniqueWithoutPlaylistsInput = {
    where: TrackWhereUniqueInput
    data: XOR<TrackUpdateWithoutPlaylistsInput, TrackUncheckedUpdateWithoutPlaylistsInput>
  }

  export type TrackUpdateManyWithWhereWithoutPlaylistsInput = {
    where: TrackScalarWhereInput
    data: XOR<TrackUpdateManyMutationInput, TrackUncheckedUpdateManyWithoutPlaylistsInput>
  }

  export type FolderCreateWithoutChildrenInput = {
    path: string
    name: string
    type?: $Enums.TrackType
    parent?: FolderCreateNestedOneWithoutChildrenInput
    tracks?: TrackCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutChildrenInput = {
    id?: number
    path: string
    name: string
    parentId?: number | null
    type?: $Enums.TrackType
    tracks?: TrackUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutChildrenInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutChildrenInput, FolderUncheckedCreateWithoutChildrenInput>
  }

  export type FolderCreateWithoutParentInput = {
    path: string
    name: string
    type?: $Enums.TrackType
    children?: FolderCreateNestedManyWithoutParentInput
    tracks?: TrackCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutParentInput = {
    id?: number
    path: string
    name: string
    type?: $Enums.TrackType
    children?: FolderUncheckedCreateNestedManyWithoutParentInput
    tracks?: TrackUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutParentInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput>
  }

  export type FolderCreateManyParentInputEnvelope = {
    data: FolderCreateManyParentInput | FolderCreateManyParentInput[]
  }

  export type TrackCreateWithoutFolderInput = {
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistEntity?: ArtistCreateNestedOneWithoutTracksInput
    albumEntity?: AlbumCreateNestedOneWithoutTracksInput
    likedByUsers?: UserTrackLikeCreateNestedManyWithoutTrackInput
    listenedByUsers?: UserTrackHistoryCreateNestedManyWithoutTrackInput
    likedAsAudiobookByUsers?: UserAudiobookLikeCreateNestedManyWithoutTrackInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryCreateNestedManyWithoutTrackInput
    playlists?: PlaylistCreateNestedManyWithoutTracksInput
  }

  export type TrackUncheckedCreateWithoutFolderInput = {
    id?: number
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistId?: number | null
    albumId?: number | null
    likedByUsers?: UserTrackLikeUncheckedCreateNestedManyWithoutTrackInput
    listenedByUsers?: UserTrackHistoryUncheckedCreateNestedManyWithoutTrackInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUncheckedCreateNestedManyWithoutTrackInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUncheckedCreateNestedManyWithoutTrackInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutTracksInput
  }

  export type TrackCreateOrConnectWithoutFolderInput = {
    where: TrackWhereUniqueInput
    create: XOR<TrackCreateWithoutFolderInput, TrackUncheckedCreateWithoutFolderInput>
  }

  export type TrackCreateManyFolderInputEnvelope = {
    data: TrackCreateManyFolderInput | TrackCreateManyFolderInput[]
  }

  export type FolderUpsertWithoutChildrenInput = {
    update: XOR<FolderUpdateWithoutChildrenInput, FolderUncheckedUpdateWithoutChildrenInput>
    create: XOR<FolderCreateWithoutChildrenInput, FolderUncheckedCreateWithoutChildrenInput>
    where?: FolderWhereInput
  }

  export type FolderUpdateToOneWithWhereWithoutChildrenInput = {
    where?: FolderWhereInput
    data: XOR<FolderUpdateWithoutChildrenInput, FolderUncheckedUpdateWithoutChildrenInput>
  }

  export type FolderUpdateWithoutChildrenInput = {
    path?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    parent?: FolderUpdateOneWithoutChildrenNestedInput
    tracks?: TrackUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    tracks?: TrackUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderUpsertWithWhereUniqueWithoutParentInput = {
    where: FolderWhereUniqueInput
    update: XOR<FolderUpdateWithoutParentInput, FolderUncheckedUpdateWithoutParentInput>
    create: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput>
  }

  export type FolderUpdateWithWhereUniqueWithoutParentInput = {
    where: FolderWhereUniqueInput
    data: XOR<FolderUpdateWithoutParentInput, FolderUncheckedUpdateWithoutParentInput>
  }

  export type FolderUpdateManyWithWhereWithoutParentInput = {
    where: FolderScalarWhereInput
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyWithoutParentInput>
  }

  export type FolderScalarWhereInput = {
    AND?: FolderScalarWhereInput | FolderScalarWhereInput[]
    OR?: FolderScalarWhereInput[]
    NOT?: FolderScalarWhereInput | FolderScalarWhereInput[]
    id?: IntFilter<"Folder"> | number
    path?: StringFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    parentId?: IntNullableFilter<"Folder"> | number | null
    type?: EnumTrackTypeFilter<"Folder"> | $Enums.TrackType
  }

  export type TrackUpsertWithWhereUniqueWithoutFolderInput = {
    where: TrackWhereUniqueInput
    update: XOR<TrackUpdateWithoutFolderInput, TrackUncheckedUpdateWithoutFolderInput>
    create: XOR<TrackCreateWithoutFolderInput, TrackUncheckedCreateWithoutFolderInput>
  }

  export type TrackUpdateWithWhereUniqueWithoutFolderInput = {
    where: TrackWhereUniqueInput
    data: XOR<TrackUpdateWithoutFolderInput, TrackUncheckedUpdateWithoutFolderInput>
  }

  export type TrackUpdateManyWithWhereWithoutFolderInput = {
    where: TrackScalarWhereInput
    data: XOR<TrackUpdateManyMutationInput, TrackUncheckedUpdateManyWithoutFolderInput>
  }

  export type UserTrackLikeCreateManyTrackInput = {
    id?: number
    userId: number
    createdAt?: Date | string
  }

  export type UserTrackHistoryCreateManyTrackInput = {
    id?: number
    userId: number
    listenedAt?: Date | string
    progress?: number
    deviceName: string
    deviceId: number
    isSyncMode?: boolean
  }

  export type UserAudiobookLikeCreateManyTrackInput = {
    id?: number
    userId: number
    createdAt?: Date | string
  }

  export type UserAudiobookHistoryCreateManyTrackInput = {
    id?: number
    userId: number
    listenedAt?: Date | string
    progress?: number
  }

  export type UserTrackLikeUpdateWithoutTrackInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedTracksNestedInput
  }

  export type UserTrackLikeUncheckedUpdateWithoutTrackInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTrackLikeUncheckedUpdateManyWithoutTrackInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTrackHistoryUpdateWithoutTrackInput = {
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    deviceName?: StringFieldUpdateOperationsInput | string
    isSyncMode?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutListenedTracksNestedInput
    device?: DeviceUpdateOneRequiredWithoutHistoriesNestedInput
  }

  export type UserTrackHistoryUncheckedUpdateWithoutTrackInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    deviceName?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    isSyncMode?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserTrackHistoryUncheckedUpdateManyWithoutTrackInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    deviceName?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    isSyncMode?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAudiobookLikeUpdateWithoutTrackInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedAudiobooksNestedInput
  }

  export type UserAudiobookLikeUncheckedUpdateWithoutTrackInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAudiobookLikeUncheckedUpdateManyWithoutTrackInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAudiobookHistoryUpdateWithoutTrackInput = {
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutListenedAudiobooksNestedInput
  }

  export type UserAudiobookHistoryUncheckedUpdateWithoutTrackInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserAudiobookHistoryUncheckedUpdateManyWithoutTrackInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type PlaylistUpdateWithoutTracksInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlaylistsNestedInput
  }

  export type PlaylistUncheckedUpdateWithoutTracksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type PlaylistUncheckedUpdateManyWithoutTracksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type TrackCreateManyAlbumEntityInput = {
    id?: number
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistId?: number | null
    folderId?: number | null
  }

  export type UserAlbumLikeCreateManyAlbumInput = {
    id?: number
    userId: number
    createdAt?: Date | string
  }

  export type UserAlbumHistoryCreateManyAlbumInput = {
    id?: number
    userId: number
    listenedAt?: Date | string
  }

  export type TrackUpdateWithoutAlbumEntityInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistEntity?: ArtistUpdateOneWithoutTracksNestedInput
    likedByUsers?: UserTrackLikeUpdateManyWithoutTrackNestedInput
    listenedByUsers?: UserTrackHistoryUpdateManyWithoutTrackNestedInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUpdateManyWithoutTrackNestedInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUpdateManyWithoutTrackNestedInput
    playlists?: PlaylistUpdateManyWithoutTracksNestedInput
    folder?: FolderUpdateOneWithoutTracksNestedInput
  }

  export type TrackUncheckedUpdateWithoutAlbumEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistId?: NullableIntFieldUpdateOperationsInput | number | null
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    likedByUsers?: UserTrackLikeUncheckedUpdateManyWithoutTrackNestedInput
    listenedByUsers?: UserTrackHistoryUncheckedUpdateManyWithoutTrackNestedInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUncheckedUpdateManyWithoutTrackNestedInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUncheckedUpdateManyWithoutTrackNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutTracksNestedInput
  }

  export type TrackUncheckedUpdateManyWithoutAlbumEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistId?: NullableIntFieldUpdateOperationsInput | number | null
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserAlbumLikeUpdateWithoutAlbumInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedAlbumsNestedInput
  }

  export type UserAlbumLikeUncheckedUpdateWithoutAlbumInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlbumLikeUncheckedUpdateManyWithoutAlbumInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlbumHistoryUpdateWithoutAlbumInput = {
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutListenedAlbumsNestedInput
  }

  export type UserAlbumHistoryUncheckedUpdateWithoutAlbumInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlbumHistoryUncheckedUpdateManyWithoutAlbumInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackCreateManyArtistEntityInput = {
    id?: number
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    albumId?: number | null
    folderId?: number | null
  }

  export type TrackUpdateWithoutArtistEntityInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    albumEntity?: AlbumUpdateOneWithoutTracksNestedInput
    likedByUsers?: UserTrackLikeUpdateManyWithoutTrackNestedInput
    listenedByUsers?: UserTrackHistoryUpdateManyWithoutTrackNestedInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUpdateManyWithoutTrackNestedInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUpdateManyWithoutTrackNestedInput
    playlists?: PlaylistUpdateManyWithoutTracksNestedInput
    folder?: FolderUpdateOneWithoutTracksNestedInput
  }

  export type TrackUncheckedUpdateWithoutArtistEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    albumId?: NullableIntFieldUpdateOperationsInput | number | null
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    likedByUsers?: UserTrackLikeUncheckedUpdateManyWithoutTrackNestedInput
    listenedByUsers?: UserTrackHistoryUncheckedUpdateManyWithoutTrackNestedInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUncheckedUpdateManyWithoutTrackNestedInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUncheckedUpdateManyWithoutTrackNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutTracksNestedInput
  }

  export type TrackUncheckedUpdateManyWithoutArtistEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    albumId?: NullableIntFieldUpdateOperationsInput | number | null
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserTrackLikeCreateManyUserInput = {
    id?: number
    trackId: number
    createdAt?: Date | string
  }

  export type UserTrackHistoryCreateManyUserInput = {
    id?: number
    trackId: number
    listenedAt?: Date | string
    progress?: number
    deviceName: string
    deviceId: number
    isSyncMode?: boolean
  }

  export type UserAlbumLikeCreateManyUserInput = {
    id?: number
    albumId: number
    createdAt?: Date | string
  }

  export type UserAlbumHistoryCreateManyUserInput = {
    id?: number
    albumId: number
    listenedAt?: Date | string
  }

  export type UserAudiobookLikeCreateManyUserInput = {
    id?: number
    trackId: number
    createdAt?: Date | string
  }

  export type UserAudiobookHistoryCreateManyUserInput = {
    id?: number
    trackId: number
    listenedAt?: Date | string
    progress?: number
  }

  export type PlaylistCreateManyUserInput = {
    id?: number
    name: string
    type?: $Enums.TrackType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceCreateManyUserInput = {
    id?: number
    name: string
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchRecordCreateManyUserInput = {
    id?: number
    keyword: string
    createdAt?: Date | string
  }

  export type UserTrackLikeUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    track?: TrackUpdateOneRequiredWithoutLikedByUsersNestedInput
  }

  export type UserTrackLikeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTrackLikeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTrackHistoryUpdateWithoutUserInput = {
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    deviceName?: StringFieldUpdateOperationsInput | string
    isSyncMode?: BoolFieldUpdateOperationsInput | boolean
    track?: TrackUpdateOneRequiredWithoutListenedByUsersNestedInput
    device?: DeviceUpdateOneRequiredWithoutHistoriesNestedInput
  }

  export type UserTrackHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    deviceName?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    isSyncMode?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserTrackHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    deviceName?: StringFieldUpdateOperationsInput | string
    deviceId?: IntFieldUpdateOperationsInput | number
    isSyncMode?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAlbumLikeUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneRequiredWithoutLikedByUsersNestedInput
  }

  export type UserAlbumLikeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    albumId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlbumLikeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    albumId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlbumHistoryUpdateWithoutUserInput = {
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneRequiredWithoutListenedByUsersNestedInput
  }

  export type UserAlbumHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    albumId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlbumHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    albumId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAudiobookLikeUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    track?: TrackUpdateOneRequiredWithoutLikedAsAudiobookByUsersNestedInput
  }

  export type UserAudiobookLikeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAudiobookLikeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAudiobookHistoryUpdateWithoutUserInput = {
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    track?: TrackUpdateOneRequiredWithoutListenedAsAudiobookByUsersNestedInput
  }

  export type UserAudiobookHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserAudiobookHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type PlaylistUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tracks?: TrackUpdateManyWithoutPlaylistsNestedInput
  }

  export type PlaylistUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tracks?: TrackUncheckedUpdateManyWithoutPlaylistsNestedInput
  }

  export type PlaylistUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    histories?: UserTrackHistoryUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    histories?: UserTrackHistoryUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchRecordUpdateWithoutUserInput = {
    keyword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchRecordUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchRecordUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTrackHistoryCreateManyDeviceInput = {
    id?: number
    userId: number
    trackId: number
    listenedAt?: Date | string
    progress?: number
    deviceName: string
    isSyncMode?: boolean
  }

  export type UserTrackHistoryUpdateWithoutDeviceInput = {
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    deviceName?: StringFieldUpdateOperationsInput | string
    isSyncMode?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutListenedTracksNestedInput
    track?: TrackUpdateOneRequiredWithoutListenedByUsersNestedInput
  }

  export type UserTrackHistoryUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    trackId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    deviceName?: StringFieldUpdateOperationsInput | string
    isSyncMode?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserTrackHistoryUncheckedUpdateManyWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    trackId?: IntFieldUpdateOperationsInput | number
    listenedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    deviceName?: StringFieldUpdateOperationsInput | string
    isSyncMode?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TrackUpdateWithoutPlaylistsInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistEntity?: ArtistUpdateOneWithoutTracksNestedInput
    albumEntity?: AlbumUpdateOneWithoutTracksNestedInput
    likedByUsers?: UserTrackLikeUpdateManyWithoutTrackNestedInput
    listenedByUsers?: UserTrackHistoryUpdateManyWithoutTrackNestedInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUpdateManyWithoutTrackNestedInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUpdateManyWithoutTrackNestedInput
    folder?: FolderUpdateOneWithoutTracksNestedInput
  }

  export type TrackUncheckedUpdateWithoutPlaylistsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistId?: NullableIntFieldUpdateOperationsInput | number | null
    albumId?: NullableIntFieldUpdateOperationsInput | number | null
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    likedByUsers?: UserTrackLikeUncheckedUpdateManyWithoutTrackNestedInput
    listenedByUsers?: UserTrackHistoryUncheckedUpdateManyWithoutTrackNestedInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUncheckedUpdateManyWithoutTrackNestedInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUncheckedUpdateManyWithoutTrackNestedInput
  }

  export type TrackUncheckedUpdateManyWithoutPlaylistsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistId?: NullableIntFieldUpdateOperationsInput | number | null
    albumId?: NullableIntFieldUpdateOperationsInput | number | null
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FolderCreateManyParentInput = {
    id?: number
    path: string
    name: string
    type?: $Enums.TrackType
  }

  export type TrackCreateManyFolderInput = {
    id?: number
    name: string
    path: string
    artist: string
    album: string
    cover?: string | null
    duration?: number | null
    lyrics?: string | null
    index?: number | null
    type?: $Enums.TrackType
    createdAt?: Date | string
    fileModifiedAt?: Date | string | null
    episodeNumber?: number | null
    artistId?: number | null
    albumId?: number | null
  }

  export type FolderUpdateWithoutParentInput = {
    path?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    children?: FolderUpdateManyWithoutParentNestedInput
    tracks?: TrackUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    children?: FolderUncheckedUpdateManyWithoutParentNestedInput
    tracks?: TrackUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
  }

  export type TrackUpdateWithoutFolderInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistEntity?: ArtistUpdateOneWithoutTracksNestedInput
    albumEntity?: AlbumUpdateOneWithoutTracksNestedInput
    likedByUsers?: UserTrackLikeUpdateManyWithoutTrackNestedInput
    listenedByUsers?: UserTrackHistoryUpdateManyWithoutTrackNestedInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUpdateManyWithoutTrackNestedInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUpdateManyWithoutTrackNestedInput
    playlists?: PlaylistUpdateManyWithoutTracksNestedInput
  }

  export type TrackUncheckedUpdateWithoutFolderInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistId?: NullableIntFieldUpdateOperationsInput | number | null
    albumId?: NullableIntFieldUpdateOperationsInput | number | null
    likedByUsers?: UserTrackLikeUncheckedUpdateManyWithoutTrackNestedInput
    listenedByUsers?: UserTrackHistoryUncheckedUpdateManyWithoutTrackNestedInput
    likedAsAudiobookByUsers?: UserAudiobookLikeUncheckedUpdateManyWithoutTrackNestedInput
    listenedAsAudiobookByUsers?: UserAudiobookHistoryUncheckedUpdateManyWithoutTrackNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutTracksNestedInput
  }

  export type TrackUncheckedUpdateManyWithoutFolderInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    index?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTrackTypeFieldUpdateOperationsInput | $Enums.TrackType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileModifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    artistId?: NullableIntFieldUpdateOperationsInput | number | null
    albumId?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}